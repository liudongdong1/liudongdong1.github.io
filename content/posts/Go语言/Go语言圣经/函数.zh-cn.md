---
title: "ã€Go è¯­è¨€åœ£ç»ã€‘å‡½æ•°"
subtitle: ""
date: 2022-10-19T11:44:24+08:00
description: ""
keywords: ""
tags: ["Goè¯­è¨€åœ£ç»"]
categories: ["Programming"]
---

{{< admonition quote >}}
æœ¬æ–‡å†…å®¹æ¥è‡ªï¼š[Goè¯­è¨€åœ£ç»ï¼ˆä¸­æ–‡ç‰ˆï¼‰](https://golang-china.github.io/gopl-zh/)
{{< /admonition >}}

**ç¯å¢ƒé…ç½®ï¼š**
- ç³»ç»Ÿï¼š*Windows11*
- ç¼–è¾‘å™¨ï¼š*vscode*

{{< admonition  >}}
æœ¬æ–‡å‡è®¾ä½ å·²ç»å®‰è£…äº†Goå¹¶é…ç½®å¥½ç›¸å…³ç¯å¢ƒï¼Œå¦‚æœä½ è¿˜æ²¡æœ‰å®‰è£…Goï¼Œè¯·å‰å¾€Goå®˜æ–¹ç½‘ç«™è¿›è¡Œ[ä¸‹è½½å®‰è£…](https://golang.google.cn/dl/)
{{< /admonition >}}

#### ğŸŒ¶ï¸ å‡½æ•°å£°æ˜
å‡½æ•°å£°æ˜åŒ…æ‹¬å‡½æ•°åã€å½¢å¼å‚æ•°åˆ—è¡¨ã€è¿”å›å€¼åˆ—è¡¨ï¼ˆå¯çœç•¥ï¼‰ä»¥åŠå‡½æ•°ä½“ã€‚
```go
func name(parameter-list) (result-list) {
    body
}

```
å½¢å¼å‚æ•°åˆ—è¡¨æè¿°äº†å‡½æ•°çš„å‚æ•°åä»¥åŠå‚æ•°ç±»å‹ã€‚è¿™äº›å‚æ•°ä½œä¸ºå±€éƒ¨å˜é‡ï¼Œå…¶å€¼ç”±å‚æ•°è°ƒç”¨è€…æä¾›ã€‚

#### ğŸ¥• é€’å½’
**ä½¿ç”¨é€’å½’å¤„ç†HTMLæ–‡ä»¶**
1. æ–°å»ºé¡¹ç›®æ–‡ä»¶å¤¹`chapter05`å¹¶ç”¨vscodeæ‰“å¼€
2. åœ¨æ ¹ç›®å½•`chapter05`ä¸‹æ–°å»ºæ–‡ä»¶`fetch`
3. åœ¨`fetch`ä¸‹æ–°å»ºæ–‡ä»¶`main.go`:
```go
package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"path"
)

//!+
// Fetch downloads the URL and returns the
// name and length of the local file.
func fetch(url string) (filename string, n int64, err error) {
	resp, err := http.Get(url)
	if err != nil {
		return "", 0, err
	}
	defer resp.Body.Close()

	local := path.Base(resp.Request.URL.Path)
	if local == "/" {
		local = "index.html"
	}
	f, err := os.Create(local)
	if err != nil {
		return "", 0, err
	}
	n, err = io.Copy(f, resp.Body)
	// Close file, but prefer error from Copy, if any.
	if closeErr := f.Close(); err == nil {
		err = closeErr
	}
	return local, n, err
}

//!-

func main() {
	for _, url := range os.Args[1:] {
		local, n, err := fetch(url)
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch %s: %v\n", url, err)
			continue
		}
		fmt.Fprintf(os.Stderr, "%s => %s (%d bytes).\n", url, local, n)
	}
}
```
4. åœ¨æ ¹ç›®å½•`chapter05`ä¸‹æ–°å»ºæ–‡ä»¶`findlinks1`
5. åœ¨`findlinks1`ä¸‹æ–°å»ºæ–‡ä»¶`main.go`:
```go
// Findlinks1 prints the links in an HTML document read from standard input.
package main

import (
    "fmt"
    "os"

    "golang.org/x/net/html"
)

func main() {
    doc, err := html.Parse(os.Stdin)
    if err != nil {
        fmt.Fprintf(os.Stderr, "findlinks1: %v\n", err)
        os.Exit(1)
    }
    for _, link := range visit(nil, doc) {
        fmt.Println(link)
    }
}
// visit appends to links each link found in n and returns the result.
func visit(links []string, n *html.Node) []string {
	if n.Type == html.ElementNode && n.Data == "a" {
			for _, a := range n.Attr {
					if a.Key == "href" {
							links = append(links, a.Val)
					}
			}
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
			links = visit(links, c)
	}
	return links
}
```
5. åœ¨æ ¹ç›®å½•`chapter05`ä¸‹æ‰§è¡Œå‘½ä»¤ï¼š
```shell
go mod init chapter05
```
```shell
go mod tidy
```
```shell
go build chapter05/fetch
```
```shell
go build chapter05/findlinks1
```
```shell
./fetch https://baidu.com | ./findlinks1
```
6. æ‰§è¡Œæ‰€æœ‰å‘½ä»¤ååœ¨æ ¹ç›®å½•`chapter05`ä¸‹ä¼šç”Ÿæˆæ–‡ä»¶`index.html`

#### ğŸ„ 
åœ¨Goä¸­ï¼Œå‡½æ•°è¢«çœ‹ä½œç¬¬ä¸€ç±»å€¼ï¼ˆfirst-class valuesï¼‰ï¼šå‡½æ•°åƒå…¶ä»–å€¼ä¸€æ ·ï¼Œæ‹¥æœ‰ç±»å‹ï¼Œå¯ä»¥è¢«èµ‹å€¼ç»™å…¶ä»–å˜é‡ï¼Œä¼ é€’ç»™å‡½æ•°ï¼Œä»å‡½æ•°è¿”å›ã€‚
```go
    func square(n int) int { return n * n }
    func negative(n int) int { return -n }
    func product(m, n int) int { return m * n }

    f := square
    fmt.Println(f(3)) // "9"

    f = negative
    fmt.Println(f(3))     // "-3"
    fmt.Printf("%T\n", f) // "func(int) int"

    f = product // compile error: can't assign func(int, int) int to func(int) int
```

#### ğŸš åŒ¿åå‡½æ•°
å‡½æ•°å­—é¢é‡çš„è¯­æ³•å’Œå‡½æ•°å£°æ˜ç›¸ä¼¼ï¼ŒåŒºåˆ«åœ¨äºfuncå…³é”®å­—åæ²¡æœ‰å‡½æ•°åã€‚å‡½æ•°å€¼å­—é¢é‡æ˜¯ä¸€ç§è¡¨è¾¾å¼ï¼Œå®ƒçš„å€¼è¢«ç§°ä¸ºåŒ¿åå‡½æ•°ï¼ˆanonymous functionï¼‰ã€‚
```go
// squaresè¿”å›ä¸€ä¸ªåŒ¿åå‡½æ•°ã€‚
// è¯¥åŒ¿åå‡½æ•°æ¯æ¬¡è¢«è°ƒç”¨æ—¶éƒ½ä¼šè¿”å›ä¸‹ä¸€ä¸ªæ•°çš„å¹³æ–¹ã€‚
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // "1"
    fmt.Println(f()) // "4"
    fmt.Println(f()) // "9"
    fmt.Println(f()) // "16"
}
```

#### ğŸ  å¯å˜å‚æ•°
å‚æ•°æ•°é‡å¯å˜çš„å‡½æ•°ç§°ä¸ºå¯å˜å‚æ•°å‡½æ•°ã€‚
```go
func sum(vals ...int) int {
    total := 0
    for _, val := range vals {
        total += val
    }
    return total
}
```

#### ğŸœ Deferredå‡½æ•°
deferè¯­å¥ç»å¸¸è¢«ç”¨äºå¤„ç†æˆå¯¹çš„æ“ä½œï¼Œå¦‚æ‰“å¼€ã€å…³é—­ã€è¿æ¥ã€æ–­å¼€è¿æ¥ã€åŠ é”ã€é‡Šæ”¾é”ã€‚é€šè¿‡deferæœºåˆ¶ï¼Œä¸è®ºå‡½æ•°é€»è¾‘å¤šå¤æ‚ï¼Œéƒ½èƒ½ä¿è¯åœ¨ä»»ä½•æ‰§è¡Œè·¯å¾„ä¸‹ï¼Œèµ„æºè¢«é‡Šæ”¾ã€‚é‡Šæ”¾èµ„æºçš„deferåº”è¯¥ç›´æ¥è·Ÿåœ¨è¯·æ±‚èµ„æºçš„è¯­å¥åã€‚
```go
package ioutil
func ReadFile(filename string) ([]byte, error) {
    f, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer f.Close()
    return ReadAll(f)
}
```
å¤„ç†äº’æ–¥é”ï¼ˆ9.2ç« ï¼‰:
```go
var mu sync.Mutex
var m = make(map[string]int)
func lookup(key string) int {
    mu.Lock()
    defer mu.Unlock()
    return m[key]
}
```

#### ğŸ£ Panicå¼‚å¸¸
Goçš„ç±»å‹ç³»ç»Ÿä¼šåœ¨ç¼–è¯‘æ—¶æ•è·å¾ˆå¤šé”™è¯¯ï¼Œä½†æœ‰äº›é”™è¯¯åªèƒ½åœ¨è¿è¡Œæ—¶æ£€æŸ¥ï¼Œå¦‚æ•°ç»„è®¿é—®è¶Šç•Œã€ç©ºæŒ‡é’ˆå¼•ç”¨ç­‰ã€‚è¿™äº›è¿è¡Œæ—¶é”™è¯¯ä¼šå¼•èµ·panicå¼‚å¸¸ã€‚

ä¸æ˜¯æ‰€æœ‰çš„panicå¼‚å¸¸éƒ½æ¥è‡ªè¿è¡Œæ—¶ï¼Œç›´æ¥è°ƒç”¨å†…ç½®çš„panicå‡½æ•°ä¹Ÿä¼šå¼•å‘panicå¼‚å¸¸ï¼›panicå‡½æ•°æ¥å—ä»»ä½•å€¼ä½œä¸ºå‚æ•°ã€‚å½“æŸäº›ä¸åº”è¯¥å‘ç”Ÿçš„åœºæ™¯å‘ç”Ÿæ—¶ï¼Œæˆ‘ä»¬å°±åº”è¯¥è°ƒç”¨panicã€‚
```go
switch s := suit(drawCard()); s {
case "Spades":                                // ...
case "Hearts":                                // ...
case "Diamonds":                              // ...
case "Clubs":                                 // ...
default:
    panic(fmt.Sprintf("invalid suit %q", s)) // Joker?
}
```

#### ğŸ¡ Recoveræ•è·å¼‚å¸¸
å¦‚æœåœ¨deferredå‡½æ•°ä¸­è°ƒç”¨äº†å†…ç½®å‡½æ•°recoverï¼Œå¹¶ä¸”å®šä¹‰è¯¥deferè¯­å¥çš„å‡½æ•°å‘ç”Ÿäº†panicå¼‚å¸¸ï¼Œrecoverä¼šä½¿ç¨‹åºä»panicä¸­æ¢å¤ï¼Œå¹¶è¿”å›panic valueã€‚å¯¼è‡´panicå¼‚å¸¸çš„å‡½æ•°ä¸ä¼šç»§ç»­è¿è¡Œï¼Œä½†èƒ½æ­£å¸¸è¿”å›ã€‚åœ¨æœªå‘ç”Ÿpanicæ—¶è°ƒç”¨recoverï¼Œrecoverä¼šè¿”å›nilã€‚
```go
func Parse(input string) (s *Syntax, err error) {
    defer func() {
        if p := recover(); p != nil {
            err = fmt.Errorf("internal error: %v", p)
        }
    }()
    // ...parser...
}
```