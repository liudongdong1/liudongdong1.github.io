---
title: "ã€æ‘˜æŠ„ã€‘åç«¯é¢è¯•é¢˜é›†02"
subtitle: ""
date: 2022-10-16T15:55:37+08:00
description: ""
keywords: ""
tags: ["interview","Golang"]
categories: ["Programming"]
---

{{< admonition  >}}
æœ¬æ–‡å†…å®¹æ¥æºäºï¼š[ã€Githubã€‘åç«¯é¢è¯•é¢˜é›†](https://github.com/xiaobaiTech/golangFamily)
{{< /admonition >}}

#### ğŸ† è¯´ä¸‹Goä¸­çš„é”æœ‰å“ªäº›?ä¸‰ç§é”ï¼Œè¯»å†™é”ï¼Œäº’æ–¥é”ï¼Œè¿˜æœ‰mapçš„å®‰å…¨çš„é”?
*Goä¸­çš„ä¸‰ç§é”åŒ…æ‹¬:äº’æ–¥é”,è¯»å†™é”,sync.Mapçš„å®‰å…¨çš„é”.*

**äº’æ–¥é”**

Goå¹¶å‘ç¨‹åºå¯¹å…±äº«èµ„æºè¿›â¾è®¿é—®æ§åˆ¶çš„ä¸»è¦â¼¿æ®µï¼Œç”±æ ‡å‡†åº“ä»£ç åŒ…ä¸­syncä¸­çš„Mutexç»“æ„ä½“è¡¨ç¤ºã€‚
```go
//Mutex æ˜¯äº’æ–¥é”ï¼Œ é›¶å€¼æ˜¯è§£é”çš„äº’æ–¥é”ï¼Œ â¾¸æ¬¡ä½¿â½¤åä¸å¾—å¤åˆ¶äº’æ–¥é”ã€‚
type Mutex struct {
 state int32
 sema uint32
}
```
*sync.MutexåŒ…ä¸­çš„ç±»å‹åªæœ‰ä¸¤ä¸ªå…¬å¼€çš„æŒ‡é’ˆâ½…æ³•Lockå’ŒUnlockã€‚*
```go
//Lockerè¡¨ç¤ºå¯ä»¥é”å®šå’Œè§£é”çš„å¯¹è±¡ã€‚
type Locker interface {
 Lock()
 Unlock()
}
//é”å®šå½“å‰çš„äº’æ–¥é‡
//å¦‚æœé”å·²è¢«ä½¿â½¤ï¼Œåˆ™è°ƒâ½¤goroutine
//é˜»å¡ç›´åˆ°äº’æ–¥é”å¯â½¤ã€‚
func (m *Mutex) Lock()
//å¯¹å½“å‰äº’æ–¥é‡è¿›â¾è§£é”
//å¦‚æœåœ¨è¿›â¼Šè§£é”æ—¶æœªé”å®šmï¼Œåˆ™ä¸ºè¿â¾æ—¶é”™è¯¯ã€‚
//é”å®šçš„äº’æ–¥é”ä¸ç‰¹å®šçš„goroutineâ½†å…³ã€‚
//å…è®¸â¼€ä¸ªgoroutineé”å®šMutexç„¶åå®‰æ’å¦â¼€ä¸ªgoroutineæ¥è§£é”å®ƒã€‚
func (m *Mutex) Unlock()
```
****
**å£°æ˜â¼€ä¸ªäº’æ–¥é”ï¼š**
```go
var mutex sync.Mutex
```
ä¸åƒCæˆ–Javaçš„é”ç±»â¼¯å…·ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šçŠ¯â¼€ä¸ªé”™è¯¯ï¼šå¿˜è®°åŠæ—¶è§£å¼€å·²è¢«é”ä½çš„é”ï¼Œä»â½½å¯¼è‡´æµç¨‹å¼‚å¸¸ã€‚ä½†Goç”±äºå­˜åœ¨deferï¼Œæ‰€ä»¥æ­¤ç±»é—®é¢˜å‡ºç°çš„æ¦‚ç‡æä½ã€‚å…³äºdeferè§£é”çš„â½…å¼å¦‚ä¸‹ï¼š
```go
var mutex sync.Mutex
func Write() {
 mutex.Lock()
 defer mutex.Unlock()
}
```
å¦‚æœå¯¹â¼€ä¸ªå·²ç»ä¸Šé”çš„å¯¹è±¡å†æ¬¡ä¸Šé”ï¼Œé‚£ä¹ˆå°±ä¼šå¯¼è‡´è¯¥é”å®šæ“ä½œè¢«é˜»å¡ï¼Œç›´åˆ°è¯¥äº’æ–¥é”å›åˆ°è¢«è§£é”çŠ¶æ€.
```go
ort (
 "fmt"
 "sync"
 "time"
)
func main() {
 var mutex sync.Mutex
 fmt.Println("begin lock")
 mutex.Lock()
 fmt.Println("get locked")
 for i := 1; i <= 3; i++ {
 go func(i int) {
 fmt.Println("begin lock ", i)
 mutex.Lock()
 fmt.Println("get locked ", i)
 }(i)
 }
 time.Sleep(time.Second)
 fmt.Println("Unlock the lock")
 mutex.Unlock()
 fmt.Println("get unlocked")
 time.Sleep(time.Second)
}
```
æˆ‘ä»¬åœ¨forå¾ªç¯ä¹‹å‰å¼€å§‹åŠ é”ï¼Œç„¶ååœ¨æ¯â¼€æ¬¡å¾ªç¯ä¸­åˆ›å»ºâ¼€ä¸ªåç¨‹ï¼Œå¹¶å¯¹å…¶åŠ é”ï¼Œä½†æ˜¯ç”±äºä¹‹å‰å·²ç»åŠ é”äº†ï¼Œæ‰€ä»¥è¿™ä¸ªforå¾ªç¯ä¸­çš„åŠ é”ä¼šé™·â¼Šé˜»å¡ç›´åˆ°mainä¸­çš„é”è¢«è§£é”ï¼Œ time.Sleep(time.Second) æ˜¯ä¸ºäº†èƒ½è®©ç³»ç»Ÿæœ‰â¾œå¤Ÿçš„æ—¶é—´è¿â¾forå¾ªç¯ï¼Œè¾“å‡ºç»“æœå¦‚ä¸‹ï¼š
```shell
> go run mutex.go
begin lock
get locked
begin lock 3
begin lock 1
begin lock 2
Unlock the lock
get unlocked
get locked 3
```
è¿™â¾¥å¯ä»¥çœ‹åˆ°è§£é”åï¼Œä¸‰ä¸ªåç¨‹ä¼šé‡æ–°æŠ¢å¤ºäº’æ–¥é”æƒï¼Œæœ€ç»ˆåç¨‹3è·èƒœã€‚

äº’æ–¥é”é”å®šæ“ä½œçš„é€†æ“ä½œå¹¶ä¸ä¼šå¯¼è‡´åç¨‹é˜»å¡ï¼Œä½†æ˜¯æœ‰å¯èƒ½å¯¼è‡´å¼•å‘â¼€ä¸ªâ½†æ³•æ¢å¤çš„è¿â¾æ—¶çš„panicï¼Œâ½å¦‚å¯¹â¼€ä¸ªæœªé”å®šçš„äº’æ–¥é”è¿›â¾è§£é”æ—¶å°±ä¼šå‘â½£panicã€‚é¿å…è¿™ç§æƒ…å†µçš„æœ€æœ‰æ•ˆâ½…å¼å°±æ˜¯ä½¿â½¤deferã€‚

æˆ‘ä»¬çŸ¥é“å¦‚æœé‡åˆ°panicï¼Œå¯ä»¥ä½¿â½¤recoverâ½…æ³•è¿›â¾æ¢å¤ï¼Œä½†æ˜¯å¦‚æœå¯¹é‡å¤è§£é”äº’æ–¥é”å¼•å‘çš„panicå´æ˜¯â½†â½¤çš„ï¼ˆGo 1.8åŠä»¥åï¼‰ã€‚
```go
package main
import (
 "fmt"
 "sync"
)
func main() {
 defer func() {
 fmt.Println("Try to recover the panic")
 if p := recover(); p != nil {
 fmt.Println("recover the panic : ", p)
 }
 }()
 var mutex sync.Mutex
 fmt.Println("begin lock")
 mutex.Lock()
 fmt.Println("get locked")
 fmt.Println("unlock lock")
 mutex.Unlock()
 fmt.Println("lock is unlocked")
 fmt.Println("unlock lock again")
 mutex.Unlock()
}
```
**è¿â¾:**
```shell
> go run mutex.go
begin lock
get locked
unlock lock
l error: sync: unlock of unlocked mutex
goroutine 1 [running]:
runtime.throw(0x4bc1a8, 0x1e)
 /home/keke/soft/go/src/runtime/panic.go:617 +0x72 fp=0xc000084ea8
sp=0xc000084e78 pc=0x427ba2
sync.throw(0x4bc1a8, 0x1e)
 /home/keke/soft/go/src/runtime/panic.go:603 +0x35 fp=0xc000084ec8
sp=0xc000084ea8 pc=0x427b25
sync.(*Mutex).Unlock(0xc00001a0c8)
 /home/keke/soft/go/src/sync/mutex.go:184 +0xc1 fp=0xc000084ef0 sp=0xc000084ec8
pc=0x45f821
main.main()
 /home/keke/go/Test/mutex.go:25 +0x25f fp=0xc000084f98 sp=0xc000084ef0
pc=0x486c1f
runtime.main()
 /home/keke/soft/go/src/runtime/proc.go:200 +0x20c fp=0xc000084fe0
sp=0xc000084f98 pc=0x4294ec
runtime.goexit()
 /home/keke/soft/go/src/runtime/asm_amd64.s:1337 +0x1 fp=0xc000084fe8
sp=0xc000084fe0 pc=0x450ad1
exit status 2
```
è¿™â¾¥è¯•å›¾å¯¹é‡å¤è§£é”å¼•å‘çš„panicè¿›â¾recoverï¼Œä½†æ˜¯æˆ‘ä»¬å‘ç°æ“ä½œå¤±è´¥ï¼Œè™½ç„¶äº’æ–¥é”å¯ä»¥è¢«å¤šä¸ªåç¨‹å…±äº«ï¼Œä½†è¿˜æ˜¯å»ºè®®å°†å¯¹åŒâ¼€ä¸ªäº’æ–¥é”çš„åŠ é”è§£é”æ“ä½œæ”¾åœ¨åŒâ¼€ä¸ªå±‚æ¬¡çš„ä»£ç ä¸­ã€‚

**è¯»å†™é”**
è¯»å†™é”æ˜¯é’ˆå¯¹è¯»å†™æ“ä½œçš„äº’æ–¥é”ï¼Œå¯ä»¥åˆ†åˆ«é’ˆå¯¹è¯»æ“ä½œä¸å†™æ“ä½œè¿›â¾é”å®šå’Œè§£é”æ“ä½œ ã€‚

**è¯»å†™é”çš„è®¿é—®æ§åˆ¶è§„åˆ™å¦‚ä¸‹ï¼š**
1. å¤šä¸ªå†™æ“ä½œä¹‹é—´æ˜¯äº’æ–¥çš„
2. å†™æ“ä½œä¸è¯»æ“ä½œä¹‹é—´ä¹Ÿæ˜¯äº’æ–¥çš„
3. å¤šä¸ªè¯»æ“ä½œä¹‹é—´ä¸æ˜¯äº’æ–¥çš„

åœ¨è¿™æ ·çš„æ§åˆ¶è§„åˆ™ä¸‹ï¼Œè¯»å†™é”å¯ä»¥â¼¤â¼¤é™ä½æ€§èƒ½æŸè€—ã€‚

åœ¨Goçš„æ ‡å‡†åº“ä»£ç åŒ…ä¸­syncä¸­çš„RWMutexç»“æ„ä½“è¡¨ç¤ºä¸º:
```go
// RWMutexæ˜¯â¼€ä¸ªè¯»/å†™äº’æ–¥é”ï¼Œå¯ä»¥ç”±ä»»æ„æ•°é‡çš„è¯»æ“ä½œæˆ–å•ä¸ªå†™æ“ä½œæŒæœ‰ã€‚
// RWMutexçš„é›¶å€¼æ˜¯æœªé”å®šçš„äº’æ–¥é”ã€‚
//â¾¸æ¬¡ä½¿â½¤åï¼Œä¸å¾—å¤åˆ¶RWMutexã€‚
//å¦‚æœgoroutineæŒæœ‰RWMutexè¿›â¾è¯»å–â½½å¦â¼€ä¸ªgoroutineå¯èƒ½ä¼šè°ƒâ½¤Lockï¼Œé‚£ä¹ˆåœ¨é‡Šæ”¾åˆå§‹è¯»é”ä¹‹å‰ï¼Œ
goroutineä¸åº”è¯¥æœŸæœ›èƒ½å¤Ÿè·å–è¯»é”å®šã€‚
//ç‰¹åˆ«æ˜¯ï¼Œè¿™ç§ç¦â½Œé€’å½’è¯»é”å®šã€‚ è¿™æ˜¯ä¸ºäº†ç¡®ä¿é”æœ€ç»ˆå˜å¾—å¯â½¤; é˜»â½Œçš„é”å®šä¼šé˜»â½Œæ–°è¯»æ“ä½œè·å–é”å®šã€‚
type RWMutex struct {
 w Mutex //å¦‚æœæœ‰å¾…å¤„ç†çš„å†™æ“ä½œå°±æŒæœ‰
 writerSem uint32 // å†™æ“ä½œç­‰å¾…è¯»æ“ä½œå®Œæˆçš„ä¿¡å·é‡
 readerSem uint32 //è¯»æ“ä½œç­‰å¾…å†™æ“ä½œå®Œæˆçš„ä¿¡å·é‡
 readerCount int32 // å¾…å¤„ç†çš„è¯»æ“ä½œæ•°é‡
 readerWait int32 // number of departing readers
}
```
syncä¸­çš„RWMutexæœ‰ä»¥ä¸‹â¼ç§â½…æ³•ï¼š
```go
//å¯¹è¯»æ“ä½œçš„é”å®š
func (rw *RWMutex) RLock()
//å¯¹è¯»æ“ä½œçš„è§£é”
func (rw *RWMutex) RUnlock()
//å¯¹å†™æ“ä½œçš„é”å®š
func (rw *RWMutex) Lock()
//å¯¹å†™æ“ä½œçš„è§£é”
func (rw *RWMutex) Unlock()
//è¿”å›â¼€ä¸ªå®ç°äº†sync.Lockeræ¥â¼ç±»å‹çš„å€¼ï¼Œå®é™…ä¸Šæ˜¯å›è°ƒrw.RLock and rw.RUnlock.
func (rw *RWMutex) RLocker() Locker
```

Unlockâ½…æ³•ä¼šè¯•å›¾å”¤é†’æ‰€æœ‰æƒ³è¿›â¾è¯»é”å®šâ½½è¢«é˜»å¡çš„åç¨‹ï¼Œâ½½ RUnlockâ½…æ³•åªä¼šåœ¨å·²â½†ä»»ä½•è¯»é”å®šçš„æƒ…å†µä¸‹ï¼Œè¯•å›¾å”¤é†’â¼€ä¸ªå› æ¬²è¿›â¾å†™é”å®šâ½½è¢«é˜»å¡çš„åç¨‹ã€‚è‹¥å¯¹â¼€ä¸ªæœªè¢«å†™é”å®šçš„è¯»å†™é”è¿›â¾å†™è§£é”ï¼Œå°±ä¼šå¼•å‘â¼€ä¸ªä¸å¯æ¢å¤çš„panicï¼ŒåŒç†å¯¹â¼€ä¸ªæœªè¢«è¯»é”å®šçš„è¯»å†™é”è¿›â¾è¯»å†™é”ä¹Ÿä¼šå¦‚æ­¤ã€‚

ç”±äºè¯»å†™é”æ§åˆ¶ä¸‹çš„å¤šä¸ªè¯»æ“ä½œä¹‹é—´ä¸æ˜¯äº’æ–¥çš„ï¼Œå› æ­¤å¯¹äºè¯»è§£é”æ›´å®¹æ˜“è¢«å¿½è§†ã€‚å¯¹äºåŒâ¼€ä¸ªè¯»å†™é”ï¼Œæ·»åŠ å¤šå°‘ä¸ªè¯»é”å®šï¼Œå°±å¿…è¦æœ‰ç­‰é‡çš„è¯»è§£é”ï¼Œè¿™æ ·æ‰èƒ½å…¶ä»–åç¨‹æœ‰æœºä¼šè¿›â¾æ“ä½œã€‚
```go
package main
import (
 "fmt"
 "sync"
 "time"
)
func main() {
 var rwm sync.RWMutex
 for i := 0; i < 5; i++ {
  go func(i int) {
  fmt.Println("try to lock read ", i)
  rwm.RLock()
  fmt.Println("get locked ", i)
  time.Sleep(time.Second * 2)
  fmt.Println("try to unlock for reading ", i)
  rwm.RUnlock()
  fmt.Println("unlocked for reading ", i)
  }(i)
 }
 time.Sleep(time.Millisecond * 1000)
 fmt.Println("try to lock for writing")
 rwm.Lock()
 fmt.Println("locked for writing")
}
```
**è¿â¾:**
```shell
> go run rwmutex.go
try to lock read 0
get locked 0
try to lock read 4
get locked 4
try to lock read 3
get locked 3
try to lock read 1
get locked 1
try to lock read 2
get locked 2
try to lock for writing
try to unlock for reading 0
unlocked for reading 0
try to unlock for reading 2
unlocked for reading 2
try to unlock for reading 1
unlocked for reading 1
try to unlock for reading 3
unlocked for reading 3
try to unlock for reading 4
unlocked for reading 4
locked for writing
```
è¿™â¾¥å¯ä»¥çœ‹åˆ°åˆ›å»ºäº†äº”ä¸ªåç¨‹â½¤äºå¯¹è¯»å†™é”çš„è¯»é”å®šä¸è¯»è§£é”æ“ä½œã€‚åœ¨ rwm.Lock()ç§ä¼šå¯¹mainä¸­åç¨‹è¿›â¾å†™é”å®šï¼Œä½†æ˜¯forå¾ªç¯ä¸­çš„è¯»è§£é”å°šæœªå®Œæˆï¼Œå› æ­¤ä¼šé€ æˆmianä¸­çš„åç¨‹é˜»å¡ã€‚å½“forå¾ªç¯ä¸­çš„è¯»è§£é”æ“ä½œéƒ½å®Œæˆåå°±ä¼šè¯•å›¾å”¤é†’mainä¸­é˜»å¡çš„åç¨‹ï¼Œmainä¸­çš„å†™é”å®šæ‰ä¼šå®Œæˆã€‚

**sync.Mapå®‰å…¨é”**

golangä¸­çš„sync.Mapæ˜¯å¹¶å‘å®‰å…¨çš„ï¼Œå…¶å®ä¹Ÿå°±æ˜¯syncåŒ…ä¸­golangâ¾ƒå®šä¹‰çš„â¼€ä¸ªåå«Mapçš„ç»“æ„ä½“ã€‚
```go
package main
import (
 "sync"
 "fmt"
)
func main() {
 //å¼€ç®±å³â½¤
 var sm sync.Map
 //store â½…æ³•,æ·»åŠ å…ƒç´ 
 sm.Store(1,"a")
 //Load â½…æ³•ï¼Œè·å¾—value
 if v,ok:=sm.Load(1);ok{
 fmt.Println(v)
 }
 //LoadOrStoreâ½…æ³•ï¼Œè·å–æˆ–è€…ä¿å­˜
 //å‚æ•°æ˜¯â¼€å¯¹keyï¼švalueï¼Œå¦‚æœè¯¥keyå­˜åœ¨ä¸”æ²¡æœ‰è¢«æ ‡è®°åˆ é™¤åˆ™è¿”å›åŸå…ˆçš„valueï¼ˆä¸æ›´æ–°ï¼‰å’Œtrueï¼›ä¸å­˜åœ¨åˆ™
storeï¼Œè¿”å›è¯¥value å’Œfalse
 if vv,ok:=sm.LoadOrStore(1,"c");ok{
 fmt.Println(vv)
 }
 if vv,ok:=sm.LoadOrStore(2,"c");!ok{
 fmt.Println(vv)
 }
 //éå†è¯¥mapï¼Œå‚æ•°æ˜¯ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°å‚çš„ä¸¤ä¸ªå‚æ•°æ˜¯éå†è·å¾—çš„keyå’Œvalueï¼Œè¿”å›â¼€ä¸ªboolå€¼ï¼Œå½“è¿”å›false
æ—¶ï¼Œéå†â½´åˆ»ç»“æŸã€‚
 sm.Range(func(k,v interface{})bool{
 fmt.Print(k)
 fmt.Print(":")
 fmt.Print(v)
 fmt.Println()
 return true
 })
}
```
**è¿â¾ :**
```shell
a
a
c
1:a
2:c
```
**sync.Mapçš„æ•°æ®ç»“æ„:**
```go
type Map struct {
 // è¯¥é”â½¤æ¥ä¿æŠ¤dirty
 mu Mutex
 // å­˜è¯»çš„æ•°æ®ï¼Œå› ä¸ºæ˜¯atomic.valueç±»å‹ï¼Œåªè¯»ç±»å‹ï¼Œæ‰€ä»¥å®ƒçš„è¯»æ˜¯å¹¶å‘å®‰å…¨çš„
 read atomic.Value // readOnly
 //åŒ…å«æœ€æ–°çš„å†™â¼Šçš„æ•°æ®ï¼Œå¹¶ä¸”åœ¨å†™çš„æ—¶å€™ï¼Œä¼šæŠŠread ä¸­æœªè¢«åˆ é™¤çš„æ•°æ®æ‹·â»‰åˆ°è¯¥dirtyä¸­ï¼Œå› ä¸ºæ˜¯æ™®é€šçš„map
å­˜åœ¨å¹¶å‘å®‰å…¨é—®é¢˜ï¼Œéœ€è¦â½¤åˆ°ä¸Šâ¾¯çš„muå­—æ®µã€‚
 dirty map[interface{}]*entry
 // ä»readè¯»æ•°æ®çš„æ—¶å€™ï¼Œä¼šå°†è¯¥å­—æ®µ+1ï¼Œå½“ç­‰äºlenï¼ˆdirtyï¼‰çš„æ—¶å€™ï¼Œä¼šå°†dirtyæ‹·â»‰åˆ°readä¸­ï¼ˆä»â½½æå‡
è¯»çš„æ€§èƒ½ï¼‰ã€‚
 misses int
}
```
**readçš„æ•°æ®ç»“æ„æ˜¯ï¼š**
```go
type readOnly struct {
 m map[interface{}]*entry
 // å¦‚æœMap.dirtyçš„æ•°æ®å’Œm ä¸­çš„æ•°æ®ä¸â¼€æ ·æ˜¯ä¸ºtrue
 amended bool
}
```
**entryçš„æ•°æ®ç»“æ„ï¼š**
```go
type entry struct {
 //å¯â»…valueæ˜¯ä¸ªæŒ‡é’ˆç±»å‹ï¼Œè™½ç„¶readå’Œdirtyå­˜åœ¨å†—ä½™æƒ…å†µï¼ˆamended=falseï¼‰ï¼Œä½†æ˜¯ç”±äºæ˜¯æŒ‡é’ˆç±»å‹ï¼Œå­˜
å‚¨çš„ç©ºé—´åº”è¯¥ä¸æ˜¯é—®é¢˜
 p unsafe.Pointer // *interface{}
}
```
**Delete â½…æ³•:**
```go
func (m *Map) Delete(key interface{}) {
 read, _ := m.read.Load().(readOnly)
 e, ok := read.m[key]
 //å¦‚æœreadä¸­æ²¡æœ‰ï¼Œå¹¶ä¸”dirtyä¸­æœ‰æ–°å…ƒç´ ï¼Œé‚£ä¹ˆå°±å»dirtyä¸­å»æ‰¾
 if !ok && read.amended {
 m.mu.Lock()
 //è¿™æ˜¯åŒæ£€æŸ¥ï¼ˆä¸Šâ¾¯çš„ifåˆ¤æ–­å’Œé”ä¸æ˜¯â¼€ä¸ªåŸâ¼¦æ€§æ“ä½œï¼‰
 read, _ = m.read.Load().(readOnly)
 e, ok = read.m[key]
 if !ok && read.amended {
 //ç›´æ¥åˆ é™¤
 delete(m.dirty, key)
 }
 m.mu.Unlock()
 }
 if ok {
//å¦‚æœreadä¸­å­˜åœ¨è¯¥keyï¼Œåˆ™å°†è¯¥value èµ‹å€¼nilï¼ˆé‡‡â½¤æ ‡è®°çš„â½…å¼åˆ é™¤ï¼ï¼‰
 e.delete()
 }
}
func (e *entry) delete() (hadValue bool) {
 for {
  p := atomic.LoadPointer(&e.p)
  if p == nil || p == expunged {
  return false
  }
  if atomic.CompareAndSwapPointer(&e.p, p, nil) {
  return true
  }
 }
}
```
**Store â½…æ³•:**
```go
func (m *Map) Store(key, value interface{}) {
  // å¦‚æœm.readå­˜åœ¨è¿™ä¸ªkeyï¼Œå¹¶ä¸”æ²¡æœ‰è¢«æ ‡è®°åˆ é™¤ï¼Œåˆ™å°è¯•æ›´æ–°ã€‚
  read, _ := m.read.Load().(readOnly)
  if e, ok := read.m[key]; ok && e.tryStore(&value) {
  return
 }
 // å¦‚æœreadä¸å­˜åœ¨æˆ–è€…å·²ç»è¢«æ ‡è®°åˆ é™¤
 m.mu.Lock()
 read, _ = m.read.Load().(readOnly)
 if e, ok := read.m[key]; ok {
  //å¦‚æœentryè¢«æ ‡è®°expungeï¼Œåˆ™è¡¨æ˜dirtyæ²¡æœ‰keyï¼Œå¯æ·»åŠ â¼Šdirtyï¼Œå¹¶æ›´æ–°entry
  if e.unexpungeLocked() {
  //åŠ â¼Šdirtyä¸­
  m.dirty[key] = e
  }
  //æ›´æ–°valueå€¼
  e.storeLocked(&value)
 //dirty å­˜åœ¨è¯¥keyï¼Œæ›´æ–°
 } else if e, ok := m.dirty[key]; ok {
  e.storeLocked(&value)
 //read å’Œdirtyéƒ½æ²¡æœ‰ï¼Œæ–°æ·»åŠ â¼€æ¡
 } else {
  //dirtyä¸­æ²¡æœ‰æ–°çš„æ•°æ®ï¼Œå¾€dirtyä¸­å¢åŠ ç¬¬â¼€ä¸ªæ–°é”®
  if !read.amended {
  //å°†readä¸­æœªåˆ é™¤çš„æ•°æ®åŠ â¼Šåˆ°dirtyä¸­
  m.dirtyLocked()
  m.read.Store(readOnly{m: read.m, amended: true})
  }
  m.dirty[key] = newEntry(value)
 }
}
//å°†readä¸­æœªåˆ é™¤çš„æ•°æ®åŠ â¼Šåˆ°dirtyä¸­
func (m *Map) dirtyLocked() {
 if m.dirty != nil {
  return
 }
 read, _ := m.read.Load().(readOnly)
 m.dirty = make(map[interface{}]*entry, len(read.m))
 //readå¦‚æœè¾ƒâ¼¤çš„è¯ï¼Œå¯èƒ½å½±å“æ€§èƒ½
 for k, e := range read.m {
  //é€šè¿‡æ­¤æ¬¡æ“ä½œï¼Œdirtyä¸­çš„å…ƒç´ éƒ½æ˜¯æœªè¢«åˆ é™¤çš„ï¼Œå¯â»…expungeçš„å…ƒç´ ä¸åœ¨dirtyä¸­
  if !e.tryExpungeLocked() {
  m.dirty[k] = e
  }
 }
}
//åˆ¤æ–­entryæ˜¯å¦è¢«æ ‡è®°åˆ é™¤ï¼Œå¹¶ä¸”å°†æ ‡è®°ä¸ºnilçš„entryæ›´æ–°æ ‡è®°ä¸ºexpunge
func (e *entry) tryExpungeLocked() (isExpunged bool) {
 p := atomic.LoadPointer(&e.p)
 for p == nil {
 // å°†å·²ç»åˆ é™¤æ ‡è®°ä¸ºnilçš„æ•°æ®æ ‡è®°ä¸ºexpunged
 if atomic.CompareAndSwapPointer(&e.p, nil, expunged) {
 return true
 }
 p = atomic.LoadPointer(&e.p)
 }
 return p == expunged
}
//å¯¹entry å°è¯•æ›´æ–°
func (e *entry) tryStore(i *interface{}) bool {
  p := atomic.LoadPointer(&e.p)
  if p == expunged {
  return false
 }
 for {
  if atomic.CompareAndSwapPointer(&e.p, p, unsafe.Pointer(i)) {
  return true
  }
  p = atomic.LoadPointer(&e.p)
  if p == expunged {
  return false
  }
 }
}
//readâ¾¥ å°†æ ‡è®°ä¸ºexpungeçš„æ›´æ–°ä¸ºnil
func (e *entry) unexpungeLocked() (wasExpunged bool) {
 return atomic.CompareAndSwapPointer(&e.p, expunged, nil)
}
//æ›´æ–°entry
func (e *entry) storeLocked(i *interface{}) {
 atomic.StorePointer(&e.p, unsafe.Pointer(i))
}
```
å› æ­¤ï¼Œæ¯æ¬¡æ“ä½œå…ˆæ£€æŸ¥readï¼Œå› ä¸ºread å¹¶å‘å®‰å…¨ï¼Œæ€§èƒ½å¥½äº›ï¼›readä¸æ»¡â¾œï¼Œåˆ™åŠ é”æ£€æŸ¥dirtyï¼Œâ¼€æ—¦æ˜¯æ–°çš„é”®å€¼ï¼Œdirtyä¼šè¢«readæ›´æ–°ã€‚

Loadâ½…æ³•:

Loadâ½…æ³•æ˜¯â¼€ä¸ªåŠ è½½â½…æ³•ï¼ŒæŸ¥æ‰¾keyã€‚
```go
func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
 //å› readåªè¯»ï¼Œçº¿ç¨‹å®‰å…¨ï¼Œå…ˆæŸ¥çœ‹æ˜¯å¦æ»¡â¾œæ¡ä»¶
 read, _ := m.read.Load().(readOnly)
 e, ok := read.m[key]
 //å¦‚æœreadæ²¡æœ‰ï¼Œå¹¶ä¸”dirtyæœ‰æ–°æ•°æ®ï¼Œé‚£ä»dirtyä¸­æŸ¥æ‰¾ï¼Œç”±äºdirtyæ˜¯æ™®é€šmapï¼Œçº¿ç¨‹ä¸å®‰å…¨ï¼Œè¿™ä¸ªæ—¶å€™â½¤
åˆ°äº’æ–¥é”äº†
 if !ok && read.amended {
 m.mu.Lock()
 // åŒé‡æ£€æŸ¥
 read, _ = m.read.Load().(readOnly)
 e, ok = read.m[key]
 // å¦‚æœreadä¸­è¿˜æ˜¯ä¸å­˜åœ¨ï¼Œå¹¶ä¸”dirtyä¸­æœ‰æ–°æ•°æ®
 if !ok && read.amended {
 e, ok = m.dirty[key]
 // mssLockedï¼ˆï¼‰å‡½æ•°æ˜¯æ€§èƒ½æ˜¯sync.Map æ€§èƒ½å¾—ä»¥ä¿è¯çš„é‡è¦å‡½æ•°ï¼Œâ½¬çš„è®²æœ‰é”çš„dirtyæ•°æ®ï¼Œ
æ›¿æ¢åˆ°åªè¯»çº¿ç¨‹å®‰å…¨çš„readâ¾¥
 m.missLocked()
 }
 m.mu.Unlock()
 }
 if !ok {
 return nil, false
 }
 return e.load()
}
//dirty æå‡â¾„read å…³é”®å‡½æ•°ï¼Œå½“misses ç»è¿‡å¤šæ¬¡å› ä¸ºloadä¹‹åï¼Œâ¼¤â¼©ç­‰äºlenï¼ˆdirtyï¼‰æ—¶å€™ï¼Œè®²dirtyæ›¿æ¢
åˆ°readâ¾¥ï¼Œä»¥æ­¤è¾¾åˆ°æ€§èƒ½æå‡ã€‚
func (m *Map) missLocked() {
 m.misses++
 if m.misses < len(m.dirty) {
 return
 }
//åŸâ¼¦æ“ä½œï¼Œè€—æ—¶å¾ˆâ¼©
 m.read.Store(readOnly{m: m.dirty})
 m.dirty = nil
 m.misses = 0
}
```
*sync.Mapæ˜¯é€šè¿‡å†—ä½™çš„ä¸¤ä¸ªæ•°æ®ç»“æ„(readã€dirty),å®ç°æ€§èƒ½çš„æå‡ã€‚ä¸ºäº†æå‡æ€§èƒ½ï¼Œloadã€deleteã€storeç­‰æ“ä½œå°½é‡ä½¿â½¤åªè¯»çš„readï¼›ä¸ºäº†æâ¾¼readçš„keyå‡»ä¸­æ¦‚ç‡ï¼Œé‡‡â½¤åŠ¨æ€è°ƒæ•´ï¼Œå°†dirtyæ•°æ®æå‡ä¸ºreadï¼›å¯¹äºæ•°æ®çš„åˆ é™¤ï¼Œé‡‡â½¤å»¶è¿Ÿæ ‡è®°åˆ é™¤æ³•ï¼Œåªæœ‰åœ¨æå‡dirtyçš„æ—¶å€™æ‰åˆ é™¤ã€‚*