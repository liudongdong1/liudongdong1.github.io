# FinalStatic


### 1. final

> final 意为最终的、不可更改的，它可以用来修饰类、方法、属性、局部变量等。

#### .1. 修饰类

> - `被 final 修改的类不能被其它类所继承`，如 Integer、String 类，都是被 final 修饰的。因此被 final 修饰的类中，其成员方法是没有机会被覆盖的。但需要注意的是：**final 类中所有的成员方法都会被隐式的指定为 final 方法**。
>
> - 对于不可变类（被 final 修饰的类）来说，它们的对象是只读的，在多线程环境下会安全的共享，不用外的开销

#### .2. 修饰方法

> - 一个类`不允许其子类重写某个方法`，则可以将这个方法声明为 final 方法。而类中的`所有 private 方法都被隐式的指定为 final`。

重写（Override）和重载（Overload）的区别：

- 重写是指**子类对父类**的允许访问的方法的`实现过程进行重新编写`，`返回值和形参都不能改变`。即外壳不变，内容重写。
- 重载是指在**同一个类里面**，`方法名字相同，而参数不同，返回值类型可以相同也可以不同`

#### .3. 修饰变量

> - 需要将某些`数据规定为固定不变的`，这种类型的变量只能被赋值一次，一旦赋值之后就不能再改变了。
> - 该变量是**基本数据类型**，则`其数值一旦初始化之后就不能被更改`；
> - 该变量是**引用类型的变量**，则对其初始化之后该变量的`引用地址不可变`，但`地址中的内容是可以改变的。`
>   - 也就是说，当 final 用于对象时，final 会使该对象的引用恒定不变，一旦引用指向了一个对象，就无法再把它改为指向另一个对象。

#### .4. 修饰形参

> 假如一个方法中的形参被 final 所修饰，则当我们调用此方法时，给定其一个实参，一旦赋值以后就只能在方法体内使用此形参，但不能进行重新赋值。

```java
public void show(final int NUM) {
    // NUM = 10; 不能再次修改被 final 修饰的形参
    Syetem.out.println(NUM); // 可以进行读操作
}
```

### 2. static

> - 当我们在`创建一个类的时候`，其实就是在`描述其对象的属性和行为`，`并没有产生实质上的对象`，只有`通过 new 关键字才会产生出对象`，这时系统才会`分配内存空间给对象`，其方法才可以供外部调用。
>
> - **某些特定的数据在内存空间里只有一份**，即我只想`为某一特定区域分配单一存储空间`，而不用去考虑它创建了多少对象。此外，我希望`某个方法不与包含它的类的任何对象联系在一起，即使没有创建对象，也能够调用这个方法`，此时可以使用 static 关键字。

#### .1. 修饰变量

- 成员变量：位于`类的内部以及方法体之外`。按照是否是静态的，可以将成员变量分为两种：
  - 被 static 修饰的变量称为`静态变量`或`类变量`；
  - 不被 static 修饰的变量称为`实例变量`。
- 局部变量：`位于方法体内部`。其中，局部变量可以分为三种：
  - 在方法中、构造器中定义的变量称为`形参`；
  - 在方法内部定义的变量称为`方法局部变量`；
  - 在代码块内定义的变量称为`代码块局部变量`。

> 对于`静态变量`，其在内存中只有一份拷贝，`JVM 只为静态变量分配一次内存`，在加载类的过程中完成静态变量的内存分配。而对于`实例变量`来说，每创建一个实例，就会为实例变量分配一次内存，实例变量在内存中可以有多份拷贝，互不影响。

#### .2. 修饰方法

> 随着类的加载而加载，可通过使用`类名.静态方法名()`的方式进行调用。在`静态方法中，只能调用静态的方法或变量`；而在非静态方法中，既可以调用非静态的方法或变量，也可以调用静态的方法和变量。因此，在静态方法内，不能使用`this`、`super`关键字。

#### .3. 修饰代码块

> 被 static 修饰的代码块称为`静态代码块`，`JVM 在加载类时会执行静态代码块`，如果有多个静态代码块，则按照顺序执行，每个代码块只会被执行一次。

#### .4. 修饰内部类

> 非静态内部类依赖于外部类的实例，也就是说：需要先创建外部类的实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。静态内部类不能访问外部类的非静态变量和方法。



---

> 作者: liudongdong1  
> URL: https://liudongdong1.github.io/finalstatic/  

