<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="PytorchGNN, AIOT,Space&amp;Temporal Sequence Analysis,SpringBoot,liudongdong1,cloud">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>PytorchGNN | DaybyDay</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="DaybyDay" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">DaybyDay</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">

      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/about">
          
          <i class="fas fa-user-circle" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>about</span>
        </a>
      </li>
      
      <li>
        <a href="/resume">
          
          <i class="fa fa-user-secret" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>resume</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/gallery" class="waves-effect waves-light">
      
      <i class="fas fa-camera" style="zoom: 0.6;"></i>
      
      <span>Galleries</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">DaybyDay</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-user-circle"></i>
			
			About
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/about " style="margin-left:75px">
				  
				   <i class="fa fas fa-user-circle" style="position: absolute;left:50px" ></i>
			      
		          <span>about</span>
                  </a>
                </li>
              
                <li>

                  <a href="/resume " style="margin-left:75px">
				  
				   <i class="fa fa fa-user-secret" style="position: absolute;left:50px" ></i>
			      
		          <span>resume</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/gallery" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-camera"></i>
			
			Galleries
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/liudongdong1" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/liudongdong1" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.pixabay.com/photo/2021/05/19/14/31/dandelion-6266230__340.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">PytorchGNN</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    .toc-fixed .toc-link::before{
        position: fixed!important;/*当toc的位置改为fixed时，.toc-link::before也要改为fixed*/
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/pytorch/">
                                <span class="chip bg-color">pytorch</span>
                            </a>
                        
                            <a href="/tags/GNN/">
                                <span class="chip bg-color">GNN</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%97%B6%E7%A9%BA%E6%95%B0%E6%8D%AE/" class="post-category">
                                时空数据
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2021-06-14
                </div>
                

                <!-- 
                    <i class="fa fa-pencil"></i> Author: liudongdong1
                  -->

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2021-09-06
                </div>
                

                <!-- 
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    10.2k
                </div>
                 -->

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    58 Min
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p>论文对GNN模型分类如下：</p>
<ul>
<li><code>图卷积网络(Graph convolutional networks)</code>和<code>图注意力网络(graph attention networks)</code>，因为涉及到传播步骤(propagation step)。</li>
<li><code>图的空域网络(spatial-temporal networks)</code>，因为该模型通常用在动态图(dynamic graph)上。</li>
<li>图的自编码(auto-encoder)，因为该模型通常使用无监督学习(unsupervised)的方式。</li>
<li><code>图生成网络(generative networks)</code>，因为是生成式网络。</li>
</ul>
</blockquote>
<p>$$<br>\mathbf{h}<em>{v}=f\left(\mathbf{x}</em>{v}, \mathbf{x}<em>{c o[v]}, \mathbf{h}</em>{n e[v]}, \mathbf{x}_{n e[v]}\right)\label{eq:1}<br>$$</p>
<p>$$<br>\mathbf{o}<em>{v}=g\left(\mathbf{h}</em>{v}, \mathbf{x}_{v}\right)<br>$$</p>
<p>其中，$\mathbf{x}<em>{v}$，$\mathbf{x}</em>{c o[v]}$，$\mathbf{h}<em>{n e[v]}$，$\mathbf{x}</em>{n e[v]}$分别表示节点$v$的特征向量，节点$v$边的特征向量，节点$v$邻居节点的状态向量和节点$v$邻居节点特征向量。</p>
<p>假设将所有的状态向量，所有的输出向量，所有的特征向量叠加起来分别使用矩阵$\mathbf{H}$，$\mathbf{O}$，$ \mathbf{X}$和 $\mathbf{X}_{N}$来表示，那么可以得到更加紧凑的表示：<br>$$<br>\mathbf{H}=F(\mathbf{H}, \mathbf{X})\label{eq:3}<br>$$</p>
<p>$$<br>\mathbf{O}=G\left(\mathbf{H}, \mathbf{X}_{N}\right)<br>$$</p>
<p>其中，$F$表示全局转化函数(global transition function)，$G$表示全局输出函数(global output function)，分别是所有节点$f$和$g$的叠加形式</p>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/graph_type.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/propa_step.png" alt=""></p>
<p>不同类别模型的Aggregator计算方法和Updater计算方法如下表</p>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/gnn_table.png" alt=""></p>
<blockquote>
<p>Fey M, Lenssen J E. Fast graph representation learning with PyTorch Geometric[J]. arXiv preprint arXiv:1903.02428, 2019. [<a href="https://scholar.google.com/scholar_url?url=https://arxiv.org/pdf/1903.02428&amp;hl=zh-CN&amp;sa=T&amp;oi=gsb-gga&amp;ct=res&amp;cd=0&amp;d=8986807541681358909&amp;ei=M1LMYND3EsSsywSBmKRw&amp;scisig=AAGBfm2Raynm1DnoD_UxQ8L7vr2Nf8M3xQ" target="_blank" rel="noopener">pdf</a>]</p>
<p>Rozemberczki B, Scherer P, He Y, et al. PyTorch Geometric Temporal: Spatiotemporal Signal Processing with Neural Machine Learning Models[J]. arXiv preprint arXiv:2104.07788, 2021. <a href="https://github.com/benedekrozemberczki/pytorch_geometric_temporal" target="_blank" rel="noopener">geometrictemporal</a></p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/table.png" alt=""></p>
<h3 id="1-Structure"><a href="#1-Structure" class="headerlink" title="1. Structure"></a>1. Structure</h3><blockquote>
<p>provide easy to use data iterators which are parametrized with spatiotemporal data. These iterators can serve snapshots which are formed by a single graph or multiple graphs which are batched together with the block diagonal batching trick.</p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210617111513969.png" alt=""></p>
<ul>
<li><p><strong>Temporal signal iterators</strong></p>
<ul>
<li><code>StaticGraphTemporalSignal</code> - Is designed for <strong>temporal signals</strong> defined on a <strong>static</strong> graph.</li>
<li><code>DynamicGraphTemporalSignal</code> - Is designed for <strong>temporal signals</strong> defined on a <strong>dynamic</strong> graph.</li>
<li><code>DynamicGraphStaticSignal</code> - Is designed for <strong>static signals</strong> defined on a <strong>dynamic</strong> graph.</li>
</ul>
</li>
<li><p><strong>Temporal Data Snapshots</strong></p>
<ul>
<li><code>data.x</code>: Node feature matrix with shape <code>[num_nodes, num_node_features]</code></li>
<li><code>data.edge_index</code>: Graph connectivity in COO format with shape <code>[2, num_edges]</code> and type <code>torch.long</code></li>
<li><code>data.edge_attr</code>: Edge feature matrix with shape <code>[num_edges, num_edge_features]</code></li>
<li><code>data.y</code>: Target to train against (may have arbitrary shape), <em>e.g.</em>, node-level targets of shape <code>[num_nodes, *]</code> or graph-level targets of shape <code>[1, *]</code></li>
<li><code>data.pos</code>: Node position matrix with shape <code>[num_nodes, num_dimensions]</code></li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618090628020.png" alt=""></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建了一个新的Data</span></span><br><span class="line"><span class="comment">#方式一</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data</span><br><span class="line">x = torch.tensor([[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">7</span>],[<span class="number">12</span>,<span class="number">0</span>]],dtype=torch.float)</span><br><span class="line">y = torch.tensor([[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]],dtype=torch.long)</span><br><span class="line">edge_index = torch.tensor([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>],</span><br><span class="line">                          [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]],dtype=torch,long)</span><br><span class="line">data = Data(x=x,y=y,edge_index=edge_index)</span><br><span class="line"><span class="comment">#方式二：</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data</span><br><span class="line">x = torch.tensor([[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">7</span>],[<span class="number">12</span>,<span class="number">0</span>]],dtype=torch.float)</span><br><span class="line">y = torch.tensor([[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]],dtype=torch.long)</span><br><span class="line">edge_index = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                           [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                           [<span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                           [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">                           [<span class="number">2</span>, <span class="number">3</span>]], dtype=torch.long)</span><br><span class="line">data = Data(x=x,y=y,edge_index=edge_index.contiguous())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loader = DataLoader(dataset, batch_size=<span class="number">512</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">Batch(x=[<span class="number">1024</span>, <span class="number">21</span>], edge_index=[<span class="number">2</span>, <span class="number">1568</span>], y=[<span class="number">512</span>], batch=[<span class="number">1024</span>])</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>Train-Test Splitting</strong> &amp;&amp; <strong>Integrated Benchmark Dataset Loaders</strong></li>
</ul>
<h3 id="2-Dataset"><a href="#2-Dataset" class="headerlink" title="2. Dataset"></a>2. <a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/introduction.html" target="_blank" rel="noopener">Dataset</a></h3><h4 id="1-offered-dataset"><a href="#1-offered-dataset" class="headerlink" title=".1. offered dataset"></a>.1. offered dataset</h4><ul>
<li><a href="https://pytorch-geometric-temporal.readthedocs.io/en/latest/modules/dataset.html#torch_geometric_temporal.data.dataset.chickenpox.ChickenpoxDatasetLoader" target="_blank" rel="noopener">Hungarian Chickenpox Dataset.</a></li>
<li><a href="https://pytorch-geometric-temporal.readthedocs.io/en/latest/modules/dataset.html#torch_geometric_temporal.data.dataset.pedalme.PedalMeDatasetLoader" target="_blank" rel="noopener">PedalMe London Dataset.</a></li>
<li><a href="https://pytorch-geometric-temporal.readthedocs.io/en/latest/modules/dataset.html#torch_geometric_temporal.data.dataset.wikimath.WikiMathsDatasetLoader" target="_blank" rel="noopener">Wikipedia Vital Math Dataset.</a></li>
<li><a href="https://pytorch-geometric-temporal.readthedocs.io/en/latest/modules/dataset.html#torch_geometric_temporal.data.dataset.windmill.WindmillOutputDatasetLoader" target="_blank" rel="noopener">Windmill Output Dataset.</a></li>
<li><a href="https://pytorch-geometric-temporal.readthedocs.io/en/latest/modules/dataset.html#torch_geometric_temporal.data.dataset.pems_bay.PemsBayDatasetLoader" target="_blank" rel="noopener">Pems Bay Dataset.</a></li>
<li><a href="https://pytorch-geometric-temporal.readthedocs.io/en/latest/modules/dataset.html#torch_geometric_temporal.data.dataset.metr_la.METRLADatasetLoader" target="_blank" rel="noopener">Metr LA Dataset.</a></li>
<li><a href="https://pytorch-geometric-temporal.readthedocs.io/en/latest/modules/dataset.html#torch_geometric_temporal.data.dataset.encovid.EnglandCovidDatasetLoader" target="_blank" rel="noopener">England COVID 19.</a></li>
<li><a href="https://pytorch-geometric-temporal.readthedocs.io/en/latest/modules/dataset.html#torch_geometric_temporal.data.dataset.twitter_tennis.TwitterTennisDatasetLoader" target="_blank" rel="noopener">Twitter Tennis.</a></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> TUDataset</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> DataLoader</span><br><span class="line">dataset = TUDataset(root=<span class="string">'/tmp/ENZYMES'</span>, name=<span class="string">'ENZYMES'</span>, use_node_attr=<span class="literal">True</span>)</span><br><span class="line">loader = DataLoader(dataset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> loader:</span><br><span class="line">    batch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Batch(batch=[<span class="number">1082</span>], edge_index=[<span class="number">2</span>, <span class="number">4066</span>], x=[<span class="number">1082</span>, <span class="number">21</span>], y=[<span class="number">32</span>])</span><br><span class="line">    batch.num_graphs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">32</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dataset split</span></span><br><span class="line"><span class="keyword">from</span> torch_geometric_temporal.dataset <span class="keyword">import</span> ChickenpoxDatasetLoader</span><br><span class="line"><span class="keyword">from</span> torch_geometric_temporal.signal <span class="keyword">import</span> temporal_signal_split</span><br><span class="line">loader = ChickenpoxDatasetLoader()</span><br><span class="line">dataset = loader.get_dataset()</span><br><span class="line">dataset = dataset.shuffle()   <span class="comment">#shuffle dataset</span></span><br><span class="line">train_dataset, test_dataset = temporal_signal_split(dataset, train_ratio=<span class="number">0.8</span>)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>Mini-Batch</strong></li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618092943939.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618093025169.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618160343566.png" alt=""></p>
<h5 id="1-Planetoid-类实例化流程"><a href="#1-Planetoid-类实例化流程" class="headerlink" title="1. Planetoid 类实例化流程"></a>1. Planetoid 类实例化流程</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataset = Planetoid(root=<span class="string">'dataset/PlanetoidPubMed'</span>,transform=NormalizeFeatures())</span><br><span class="line">data = dataset[<span class="number">0</span>].to(device) <span class="comment">#这一步才执行transform的函数</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>首先，检查数据原始文件是否已下载：</p>
<ul>
<li>检查<code>self.raw_dir</code>目录下是否存在<code>raw_file_names()</code>属性方法返回的每个文件，</li>
<li>如有文件不存在，则调用<code>download()</code>方法执行原始文件下载。</li>
</ul>
</li>
<li><p>其次，检查数据是否经过处理：</p>
<ul>
<li><p>首先，检查之前对数据做变换的方法：检查</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.processed_dir</span><br></pre></td></tr></tbody></table></figure>

<p>目录下是否存在</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre_transform.pt</span><br></pre></td></tr></tbody></table></figure>

<p>文件：</p>
<ul>
<li><p>如果存在，意味着之前进行过数据变换，接着需要加载该文件，以获取之前所用的数据变换的方法，并检查它与当前</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre_transform</span><br></pre></td></tr></tbody></table></figure>

<p>参数指定的方法是否相同，</p>
<ul>
<li>如果不相同则会报出一个警告，“The pre_transform argument differs from the one used in ……”。</li>
</ul>
</li>
</ul>
</li>
<li><p>其次，检查之前的样本过滤的方法：检查</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.processed_dir</span><br></pre></td></tr></tbody></table></figure>

<p>目录下是否存在</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre_filter.pt</span><br></pre></td></tr></tbody></table></figure>

<p>文件：</p>
<ul>
<li><p>如果存在，则加载该文件并获取之前所用的样本过滤的方法，并检查它与当前</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre_filter</span><br></pre></td></tr></tbody></table></figure>

<p>参数指定的方法是否相同，</p>
<ul>
<li>如果不相同则会报出一个警告，“The pre_filter argument differs from the one used in ……”。</li>
</ul>
</li>
</ul>
</li>
<li><p>接着，检查是否存在处理好的数据：检查</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.processed_dir</span><br></pre></td></tr></tbody></table></figure>

<p>目录下是否存在</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.processed_file_names</span><br></pre></td></tr></tbody></table></figure>

<p>属性方法返回的所有文件，如有文件不存在，则需要执行以下的操作：</p>
<ul>
<li><p>调用<code>process()</code>方法，进行数据处理。</p>
</li>
<li><p>如果<code>pre_transform</code>参数不为<code>None</code>，则调用<code>pre_transform()</code>函数进行数据处理。</p>
</li>
<li><p>如果<code>pre_filter</code>参数不为<code>None</code>，则进行样本过滤（此例子中不需要进行样本过滤，<code>pre_filter</code>参数为<code>None</code>）。</p>
</li>
<li><p>保存处理好的数据到文件，文件存储在</p>
<p>processed_paths()</p>
<p>属性方法返回的文件路径。如果将数据保存到多个文件中，则返回的路径有多个。</p>
<ul>
<li><strong><code>processed_paths()</code>属性方法是在基类（<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html?highlight=dataset#torch_geometric.data.Dataset" target="_blank" rel="noopener">DataSet</a>）中定义的</strong>，它对<code>self.processed_dir</code>文件夹与<code>processed_file_names()</code>属性方法的返回每一个文件名做拼接，然后返回。</li>
</ul>
</li>
<li><p>最后保存新的<code>pre_transform.pt</code>文件和<code>pre_filter.pt</code>文件，它们分别存储当前使用的数据处理方法和样本过滤方法。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>保证有预处理的文件后，在<code>self.data, self.slices = torch.load(self.processed_paths[0])</code>时从预处理文件路径中加载预处理后的数据。</p>
</li>
<li><p>在执行<code>data = dataset[0]</code>时才调用选择的<code>transform</code>函数。</p>
</li>
</ol>
<h4 id="2-customed-dataset"><a href="#2-customed-dataset" class="headerlink" title=".2. customed dataset"></a>.2. customed dataset</h4><blockquote>
<p>PyG提供两种不同的数据集类：Dataset,InMemoryDataset ,InMemoryDataset继承Dataset, 如果要继承InMemoryDataset 需要实现以下几个类</p>
<ul>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.InMemoryDataset.raw_file_names" target="_blank" rel="noopener"><code>torch_geometric.data.InMemoryDataset.raw_file_names()</code></a>: A list of files in the <code>raw_dir</code> which needs to be found in order to skip the download.</li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.InMemoryDataset.processed_file_names" target="_blank" rel="noopener"><code>torch_geometric.data.InMemoryDataset.processed_file_names()</code></a>: A list of files in the <code>processed_dir</code> which needs to be found in order to skip the processing.</li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.InMemoryDataset.download" target="_blank" rel="noopener"><code>torch_geometric.data.InMemoryDataset.download()</code></a>: Downloads raw data into <code>raw_dir</code>.</li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.InMemoryDataset.process" target="_blank" rel="noopener"><code>torch_geometric.data.InMemoryDataset.process()</code></a>: Processes raw data and saves it into the <code>processed_dir</code>.</li>
</ul>
</blockquote>
<ul>
<li><code>root</code>：字符串类型，存储数据集的文件夹的路径下。该文件夹下有两个文件夹：<ul>
<li>一个文件夹为记录在<strong><code>raw_dir</code></strong>，它用于存储未处理的文件，从网络上下载的<strong>数据集原始文件</strong>会被存放到这里；</li>
<li>另一个文件夹记录在<strong><code>processed_dir</code></strong>，<strong>处理后的数据</strong>被保存到这里，以后从此文件夹下加载文件即可获得<code>Data</code>对象。</li>
<li>注：<code>raw_dir</code>和<code>processed_dir</code>是属性方法，我们可以自定义要使用的文件夹。</li>
</ul>
</li>
<li><code>transform</code>：函数类型，一个数据转换函数，它接收一个<code>Data</code>对象并返回一个转换后的<code>Data</code>对象。<strong>此函数在每一次数据获取过程中都会被执行</strong>。获取数据的函数首先使用此函数对<code>Data</code>对象做转换，然后才返回数据。此函数应该用于数据增广（Data Augmentation）。该参数默认值为<code>None</code>，表示不对数据做转换。</li>
<li><code>pre_transform</code>：函数类型，一个数据转换函数，它接收一个<code>Data</code>对象并返回一个转换后的<code>Data</code>对象。<strong>此函数在<code>Data</code>对象被保存到文件前调用</strong>。因此它应该用于只执行一次的数据预处理。该参数默认值为<code>None</code>，表示不做数据预处理。</li>
<li><code>pre_filter</code>：函数类型，<strong>一个检查数据是否要保留的函数</strong>，它接收一个<code>Data</code>对象，返回此<code>Data</code>对象是否应该被包含在最终的数据集中。此函数也在<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.Data" target="_blank" rel="noopener"><code>Data</code></a>对象被保存到文件前调用。该参数默认值为<code>None</code>，表示不做数据检查，保留所有的数据。</li>
<li>raw_file_names(): 属性方法，返回一个<strong>数据集原始文件</strong>的文件名列表，<strong>数据集原始文件应该能在<code>raw_dir</code>文件夹中找到</strong>，否则调用<code>download()</code>函数下载文件到<code>raw_dir</code>文件夹。</li>
<li>processed_file_names: 属性方法，返回一个存储<strong>处理过的数据的文件</strong>的文件名列表，存储处理过的数据的文件应该能在<code>processed_dir</code>文件夹中找到，否则调用<code>process()</code>函数对样本做处理，然后保存处理过的数据到<code>processed_dir</code>文件夹下的文件里。</li>
<li>download: 根据定义的<code>url</code>属性<strong>下载数据集原始文件</strong>到<code>raw_dir</code>文件夹。</li>
<li>processed: <strong>调用读取数据函数，将数据包装成Data</strong>，然后<strong>处理数据</strong>，保存处理好的数据到<code>processed_dir</code>文件夹下的文件。</li>
<li>raw_dir: 属性方法，原始数据存储的文件夹路径，我们可以自定义要使用的文件夹。</li>
<li>processed_dir: 属性方法，处理后数据存储的文件夹路径，我们可以自定义要使用的文件夹。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> InMemoryDataset</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOwnDataset</span><span class="params">(InMemoryDataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, transform=None, pre_transform=None)</span>:</span></span><br><span class="line">        super(MyOwnDataset, self).__init__(root, transform, pre_transform)</span><br><span class="line">        self.data, self.slices = torch.load(self.processed_paths[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line"><span class="comment">#它返回一个包含没有处理的数据的名字的list。如果你只有一个文件，那么它返回的list将只包含一个元素。事实上，你可以返回一个空list，然后确定你的文件在后面的函数process()中。</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">raw_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'some_file_1'</span>, <span class="string">'some_file_2'</span>, ...]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#它返回一个包含所有处理过的数据的list。在调用process()这个函数后，通常返回的list只有一个元素，它只保存已经处理过的数据的名字。</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processed_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'data.pt'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#下载数据到你正在工作的目录中，你可以在self.raw_dir中指定。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Download to `self.raw_dir`.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Read data into huge `Data` list.</span></span><br><span class="line">        data_list = [...]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.pre_filter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            data_list [data <span class="keyword">for</span> data <span class="keyword">in</span> data_list <span class="keyword">if</span> self.pre_filter(data)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.pre_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            data_list = [self.pre_transform(data) <span class="keyword">for</span> data <span class="keyword">in</span> data_list]</span><br><span class="line"></span><br><span class="line">        data, slices = self.collate(data_list)</span><br><span class="line">        torch.save((data, slices), self.processed_paths[<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li><code>torch_geometric.data.Dataset.len()</code>: Returns the number of examples in your dataset.</li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.Dataset.get" target="_blank" rel="noopener"><code>torch_geometric.data.Dataset.get()</code></a>: Implements the logic to load a single graph.</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Dataset, download_url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOwnDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, transform=None, pre_transform=None)</span>:</span></span><br><span class="line">        super(MyOwnDataset, self).__init__(root, transform, pre_transform)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">raw_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'some_file_1'</span>, <span class="string">'some_file_2'</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processed_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'data_1.pt'</span>, <span class="string">'data_2.pt'</span>, ...]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Download to `self.raw_dir`.</span></span><br><span class="line">        path = download_url(url, self.raw_dir)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self)</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> raw_path <span class="keyword">in</span> self.raw_paths:</span><br><span class="line">            <span class="comment"># Read data from `raw_path`.</span></span><br><span class="line">            data = Data(...)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.pre_filter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> self.pre_filter(data):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.pre_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                data = self.pre_transform(data)</span><br><span class="line"></span><br><span class="line">            torch.save(data, osp.join(self.processed_dir, <span class="string">'data_{}.pt'</span>.format(i)))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">len</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.processed_file_names)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        data = torch.load(osp.join(self.processed_dir, <span class="string">'data_{}.pt'</span>.format(idx)))</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-Transformer"><a href="#3-Transformer" class="headerlink" title=".3. Transformer"></a>.3. <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html" target="_blank" rel="noopener">Transformer</a></h4><blockquote>
<p>Transforms can be chained together using <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.Compose" target="_blank" rel="noopener"><code>torch_geometric. transforms. Compose</code></a> and are applied before saving a processed dataset on disk (<code>pre_transform</code>) or before accessing a graph in a dataset (<code>transform</code>).</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#convert the point cloud dataset into a graph dataset by generating nearest neighbor graphs from the point clouds via transform</span></span><br><span class="line"><span class="keyword">import</span> torch_geometric.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> ShapeNet</span><br><span class="line"></span><br><span class="line">dataset = ShapeNet(root=<span class="string">'/tmp/ShapeNet'</span>, categories=[<span class="string">'Airplane'</span>],</span><br><span class="line">                    pre_transform=T.KNNGraph(k=<span class="number">6</span>))</span><br><span class="line">dataset[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Data(edge_index=[<span class="number">2</span>, <span class="number">15108</span>], pos=[<span class="number">2518</span>, <span class="number">3</span>], y=[<span class="number">2518</span>])</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.Compose" target="_blank" rel="noopener"><code>Compose</code></a></th>
<th>Composes several transforms together.</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.ToSparseTensor" target="_blank" rel="noopener"><code>ToSparseTensor</code></a></td>
<td>Converts the <code>edge_index</code> attribute of a data object into a (transposed) <code>torch_sparse.SparseTensor</code> type with key <code>adj_.t</code>.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.ToUndirected" target="_blank" rel="noopener"><code>ToUndirected</code></a></td>
<td>Converts the graph to an undirected graph, so that (j,i)∈E(j,i)∈E for every edge (i,j)∈E(i,j)∈E.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.Constant" target="_blank" rel="noopener"><code>Constant</code></a></td>
<td>Adds a constant value to each node feature.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.Distance" target="_blank" rel="noopener"><code>Distance</code></a></td>
<td>Saves the Euclidean distance of linked nodes in its edge attributes.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.Cartesian" target="_blank" rel="noopener"><code>Cartesian</code></a></td>
<td>Saves the relative Cartesian coordinates of linked nodes in its edge attributes.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.LocalCartesian" target="_blank" rel="noopener"><code>LocalCartesian</code></a></td>
<td>Saves the relative Cartesian coordinates of linked nodes in its edge attributes.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.Polar" target="_blank" rel="noopener"><code>Polar</code></a></td>
<td>Saves the <code>polar coordinates</code> of linked nodes in its edge attributes.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.Spherical" target="_blank" rel="noopener"><code>Spherical</code></a></td>
<td>Saves the spherical coordinates of linked nodes in its edge attributes.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.PointPairFeatures" target="_blank" rel="noopener"><code>PointPairFeatures</code></a></td>
<td>Computes the rotation-invariant Point Pair Features</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.OneHotDegree" target="_blank" rel="noopener"><code>OneHotDegree</code></a></td>
<td>Adds the node degree as one hot encodings to the node features.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.TargetIndegree" target="_blank" rel="noopener"><code>TargetIndegree</code></a></td>
<td>Saves the globally normalized degree of target nodes</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.LocalDegreeProfile" target="_blank" rel="noopener"><code>LocalDegreeProfile</code></a></td>
<td>Appends the Local Degree Profile (LDP) from the <a href="https://arxiv.org/abs/1811.03508" target="_blank" rel="noopener">“A Simple yet Effective Baseline for Non-attribute Graph Classification”</a> paper</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.Center" target="_blank" rel="noopener"><code>Center</code></a></td>
<td>Centers node positions around the origin.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.NormalizeRotation" target="_blank" rel="noopener"><code>NormalizeRotation</code></a></td>
<td><code>Rotates all points according to the eigenvectors of the point cloud.</code></td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.NormalizeScale" target="_blank" rel="noopener"><code>NormalizeScale</code></a></td>
<td>Centers and normalizes node positions to the interval (−1,1)(−1,1).</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.RandomTranslate" target="_blank" rel="noopener"><code>RandomTranslate</code></a></td>
<td>Translates node positions by randomly sampled translation values within a given interval.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.RandomFlip" target="_blank" rel="noopener"><code>RandomFlip</code></a></td>
<td>Flips node positions along a given axis randomly with a given probability.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.LinearTransformation" target="_blank" rel="noopener"><code>LinearTransformation</code></a></td>
<td>Transforms node positions with a square transformation matrix computed offline.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.RandomScale" target="_blank" rel="noopener"><code>RandomScale</code></a></td>
<td>Scales node positions by a randomly sampled factor ss within a given interval, <em>e.g.</em>, resulting in the transformation matrix</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.RandomRotate" target="_blank" rel="noopener"><code>RandomRotate</code></a></td>
<td><code>Rotates node positions around a specific axis by a randomly sampled factor within a given interval.</code></td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.RandomShear" target="_blank" rel="noopener"><code>RandomShear</code></a></td>
<td>Shears node positions by randomly sampled factors ss within a given interval, <em>e.g.</em>, resulting in the transformation matrix</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.NormalizeFeatures" target="_blank" rel="noopener"><code>NormalizeFeatures</code></a></td>
<td>Row-normalizes node features to sum-up to one.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.AddSelfLoops" target="_blank" rel="noopener"><code>AddSelfLoops</code></a></td>
<td>Adds self-loops to edge indices.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.RemoveIsolatedNodes" target="_blank" rel="noopener"><code>RemoveIsolatedNodes</code></a></td>
<td>Removes isolated nodes from the graph.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.KNNGraph" target="_blank" rel="noopener"><code>KNNGraph</code></a></td>
<td>Creates a<code>k-NN graph</code> based on node positions <code>pos</code>.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.RadiusGraph" target="_blank" rel="noopener"><code>RadiusGraph</code></a></td>
<td>Creates edges based on node positions <code>pos</code> to all points within a given distance.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.FaceToEdge" target="_blank" rel="noopener"><code>FaceToEdge</code></a></td>
<td>Converts<code>mesh faces</code> <code>[3, num_faces]</code> to edge indices <code>[2, num_edges]</code>.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.SamplePoints" target="_blank" rel="noopener"><code>SamplePoints</code></a></td>
<td>Uniformly samples <code>num</code> points on the mesh faces according to their face area.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.FixedPoints" target="_blank" rel="noopener"><code>FixedPoints</code></a></td>
<td>Samples a fixed number of <code>num</code> points and features from a point cloud.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.ToDense" target="_blank" rel="noopener"><code>ToDense</code></a></td>
<td>Converts a sparse adjacency matrix to a dense adjacency matrix with shape <code>[num_nodes, num_nodes, *]</code>.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.TwoHop" target="_blank" rel="noopener"><code>TwoHop</code></a></td>
<td>Adds the two hop edges to the edge indices.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.LineGraph" target="_blank" rel="noopener"><code>LineGraph</code></a></td>
<td>Converts a graph to its corresponding line-graph:</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.LaplacianLambdaMax" target="_blank" rel="noopener"><code>LaplacianLambdaMax</code></a></td>
<td>Computes the highest eigenvalue of the graph Laplacian given by <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/utils.html#torch_geometric.utils.get_laplacian" target="_blank" rel="noopener"><code>torch_geometric.utils.get_laplacian()</code></a>.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.GenerateMeshNormals" target="_blank" rel="noopener"><code>GenerateMeshNormals</code></a></td>
<td>Generate normal vectors for each mesh node based on neighboring faces.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.Delaunay" target="_blank" rel="noopener"><code>Delaunay</code></a></td>
<td>Computes the delaunay triangulation of a set of points.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.ToSLIC" target="_blank" rel="noopener"><code>ToSLIC</code></a></td>
<td>Converts an image to a superpixel representation using the <code>skimage.segmentation.slic()</code> algorithm, resulting in a <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.Data" target="_blank" rel="noopener"><code>torch_geometric.data.Data</code></a> object holding the centroids of superpixels in <code>pos</code> and their mean color in <code>x</code>.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.GDC" target="_blank" rel="noopener"><code>GDC</code></a></td>
<td>Processes the graph via Graph Diffusion Convolution (GDC) from the <a href="https://www.kdd.in.tum.de/gdc" target="_blank" rel="noopener">“Diffusion Improves Graph Learning”</a> paper.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.SIGN" target="_blank" rel="noopener"><code>SIGN</code></a></td>
<td>The Scalable Inception Graph Neural Network module (SIGN) from the <a href="https://arxiv.org/abs/2004.11198" target="_blank" rel="noopener">“SIGN: Scalable Inception Graph Neural Networks”</a> paper, which precomputes the fixed representations</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.GridSampling" target="_blank" rel="noopener"><code>GridSampling</code></a></td>
<td>Clusters points into voxels with size <code>size</code>.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.GCNNorm" target="_blank" rel="noopener"><code>GCNNorm</code></a></td>
<td>Applies the GCN normalization from the <a href="https://arxiv.org/abs/1609.02907" target="_blank" rel="noopener">“Semi-supervised Classification with Graph Convolutional Networks”</a> paper.</td>
</tr>
<tr>
<td><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.AddTrainValTestMask" target="_blank" rel="noopener"><code>AddTrainValTestMask</code></a></td>
<td>Adds a node-level random split via <code>train_mask</code>, <code>val_mask</code> and <code>test_mask</code> attributes to the <code>data</code> object.</td>
</tr>
</tbody></table>
<h3 id="3-Models"><a href="#3-Models" class="headerlink" title="3. Models"></a>3. Models</h3><h4 id="1-MLs"><a href="#1-MLs" class="headerlink" title=".1. MLs"></a>.1. MLs</h4><ul>
<li><strong>Temporal Deep learning:</strong> <ul>
<li><code>LSTM or GRU</code> generates in-memory representations of data points which are iteratively updated as it learns by new snapshots;</li>
<li><code>attention mechanism</code>: to learn representation of the data points which are adaptively recontextualized based on the temporal history.</li>
</ul>
</li>
<li>*<em>Static Graph Representation Learning: *</em> <ul>
<li><code>message passing formalism</code>: learning representations of vertices, edges, and whole graphs with GNN.</li>
<li>models are differentiated by assumptions about the input graph ( eg. node heterogeneity, multiplexity, presence of edge attributes ), message compression function, propagation scheme, message aggregation function.</li>
</ul>
</li>
<li><strong>Spatio-temporal Deep Learning:</strong>  combine temporal deep learning technique and graph representation learning.</li>
<li><strong>Predictive Perfromance:</strong> <ul>
<li><code>Incremental:</code> the loss is back-propagated and model wights are updated after each temporal snapshot;</li>
<li><code>Cumulative:</code> aggregated loss from every temporal snapshot and update weights with optimizer per epoch.</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210617112633539.png" alt=""></p>
<ul>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#convolutional-layers" target="_blank" rel="noopener">Convolutional Layers</a></li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#dense-convolutional-layers" target="_blank" rel="noopener">Dense Convolutional Layers</a></li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#normalization-layers" target="_blank" rel="noopener">Normalization Layers</a></li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#global-pooling-layers" target="_blank" rel="noopener">Global Pooling Layers</a></li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#pooling-layers" target="_blank" rel="noopener">Pooling Layers</a></li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#dense-pooling-layers" target="_blank" rel="noopener">Dense Pooling Layers</a></li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#unpooling-layers" target="_blank" rel="noopener">Unpooling Layers</a></li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#models" target="_blank" rel="noopener">Models</a></li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#functional" target="_blank" rel="noopener">Functional</a></li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#module-torch_geometric.nn.data_parallel" target="_blank" rel="noopener">DataParallel Layers</a></li>
</ul>
<h4 id="2-MessagePassing-amp-neighborhood-aggregation"><a href="#2-MessagePassing-amp-neighborhood-aggregation" class="headerlink" title=".2. MessagePassing&amp;neighborhood aggregation"></a>.2. MessagePassing&amp;neighborhood aggregation</h4><p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618160144302.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618095312400.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618155312167.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618095445424.png" alt="image-20210618095445424"></p>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618160311559.png" alt=""></p>
<ul>
<li><code>MessagePassing(aggr="add", flow="source_to_target", node_dim=-2)</code>: Defines the aggregation scheme to use (<code>"add"</code>, <code>"mean"</code> or <code>"max"</code>) and the flow direction of message passing (either <code>"source_to_target"</code> or <code>"target_to_source"</code>). Furthermore, the <code>node_dim</code> attribute indicates along which axis to propagate.</li>
<li><code>MessagePassing.propagate(edge_index, size=None, **kwargs)</code>: The initial call to start propagating messages. Takes in the edge indices and all additional data which is needed to construct messages and to update node embeddings. Note that <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.conv.message_passing.MessagePassing.propagate" target="_blank" rel="noopener"><code>propagate()</code></a> is not limited to exchange messages in symmetric adjacency matrices of shape <code>[N, N]</code> only, but can also exchange messages in general sparse assignment matrices, <em>.e.g.</em>, bipartite graphs, of shape <code>[N, M]</code> by passing <code>size=(N, M)</code> as an additional argument. If set to <a href="https://docs.python.org/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>, the assignment matrix is assumed to be symmetric. For bipartite graphs with two independent sets of nodes and indices, and each set holding its own information, this split can be marked by passing the information as a tuple, <em>e.g.</em> <code>x=(x_N, x_M)</code>.</li>
<li><code>MessagePassing.message(...)</code>: Constructs messages to node i in analogy to ϕϕfor each edge in (j,i)∈E(j,i)∈E if <code>flow="source_to_target"</code> and (i,j)∈E(i,j)∈E if <code>flow="target_to_source"</code>. Can take any argument which was initially passed to <code>propagate()</code>. In addition, tensors passed to <code>propagate()</code> can be mapped to the respective nodes ii and jj by appending <code>_i</code> or <code>_j</code> to the variable name, <em>.e.g.</em> <code>x_i</code> and <code>x_j</code>. Note that we generally refer to ii as the central nodes that aggregates information, and refer to jj as the neighboring nodes, since this is the most common notation.</li>
<li><code>MessagePassing.update(aggr_out, ...)</code>: Updates node embeddings in analogy to γγ for each node i∈Vi∈V. Takes in the output of aggregation as first argument and any argument which was initially passed to <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.conv.message_passing.MessagePassing.propagate" target="_blank" rel="noopener"><code>propagate()</code></a>.</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618104838632.png" alt=""></p>
<h5 id="1-GCN-Layer"><a href="#1-GCN-Layer" class="headerlink" title=".1. GCN Layer"></a>.1. <a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/create_gnn.html#id2" target="_blank" rel="noopener">GCN Layer</a></h5><p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618095657408.png" alt=""></p>
<blockquote>
<ol>
<li>Add self-loops to the adjacency matrix.</li>
<li>Linearly transform node feature matrix.</li>
<li>Compute normalization coefficients.</li>
<li>Normalize node features in ϕϕ.</li>
<li>Sum up neighboring node features (<code>"add"</code> aggregation).</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> MessagePassing</span><br><span class="line"><span class="keyword">from</span> torch_geometric.utils <span class="keyword">import</span> add_self_loops, degree</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCNConv</span><span class="params">(MessagePassing)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_channels, out_channels)</span>:</span></span><br><span class="line">        super(GCNConv, self).__init__(aggr=<span class="string">'add'</span>)  <span class="comment"># "Add" aggregation (Step 5).</span></span><br><span class="line">        self.lin = torch.nn.Linear(in_channels, out_channels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, edge_index)</span>:</span></span><br><span class="line">        <span class="comment"># x has shape [N, in_channels]</span></span><br><span class="line">        <span class="comment"># edge_index has shape [2, E]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1: Add self-loops to the adjacency matrix.</span></span><br><span class="line">        edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: Linearly transform node feature matrix.</span></span><br><span class="line">        x = self.lin(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 3: Compute normalization.</span></span><br><span class="line">        row, col = edge_index</span><br><span class="line">        deg = degree(col, x.size(<span class="number">0</span>), dtype=x.dtype)</span><br><span class="line">        deg_inv_sqrt = deg.pow(<span class="number">-0.5</span>)</span><br><span class="line">        deg_inv_sqrt[deg_inv_sqrt == float(<span class="string">'inf'</span>)] = <span class="number">0</span></span><br><span class="line">        norm = deg_inv_sqrt[row] * deg_inv_sqrt[col]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 4-5: Start propagating messages.</span></span><br><span class="line">        <span class="keyword">return</span> self.propagate(edge_index, x=x, norm=norm)  <span class="comment">#当我们调用 propagate() 的时候，内部会自动的调用 message() 和 update() 函数，传递的参数是 x 。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">message</span><span class="params">(self, x_j, norm)</span>:</span></span><br><span class="line">        <span class="comment"># x_j has shape [E, out_channels]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 4: Normalize node features.</span></span><br><span class="line">        <span class="keyword">return</span> norm.view(<span class="number">-1</span>, <span class="number">1</span>) * x_j</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618103522520.png" alt=""></p>
<h5 id="2-Edge-Convolution"><a href="#2-Edge-Convolution" class="headerlink" title=".2.Edge Convolution"></a>.2.<a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/create_gnn.html#id3" target="_blank" rel="noopener">Edge Convolution</a></h5><p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618100719167.png" alt=""></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Sequential <span class="keyword">as</span> Seq, Linear, ReLU</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> MessagePassing</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeConv</span><span class="params">(MessagePassing)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_channels, out_channels)</span>:</span></span><br><span class="line">        super(EdgeConv, self).__init__(aggr=<span class="string">'max'</span>) <span class="comment">#  "Max" aggregation.</span></span><br><span class="line">        self.mlp = Seq(Linear(<span class="number">2</span> * in_channels, out_channels),</span><br><span class="line">                       ReLU(),</span><br><span class="line">                       Linear(out_channels, out_channels))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, edge_index)</span>:</span></span><br><span class="line">        <span class="comment"># x has shape [N, in_channels]</span></span><br><span class="line">        <span class="comment"># edge_index has shape [2, E]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.propagate(edge_index, x=x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">message</span><span class="params">(self, x_i, x_j)</span>:</span></span><br><span class="line">        <span class="comment"># x_i has shape [E, in_channels]</span></span><br><span class="line">        <span class="comment"># x_j has shape [E, in_channels]</span></span><br><span class="line"></span><br><span class="line">        tmp = torch.cat([x_i, x_j - x_i], dim=<span class="number">1</span>)  <span class="comment"># tmp has shape [E, 2 * in_channels]</span></span><br><span class="line">        <span class="keyword">return</span> self.mlp(tmp)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> knn_graph</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicEdgeConv</span><span class="params">(EdgeConv)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_channels, out_channels, k=<span class="number">6</span>)</span>:</span></span><br><span class="line">        super(DynamicEdgeConv, self).__init__(in_channels, out_channels)</span><br><span class="line">        self.k = k</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, batch=None)</span>:</span></span><br><span class="line">        edge_index = knn_graph(x, self.k, batch, loop=<span class="literal">False</span>, flow=self.flow)</span><br><span class="line">        <span class="keyword">return</span> super(DynamicEdgeConv, self).forward(x, edge_index)</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-Global-Pooling"><a href="#3-Global-Pooling" class="headerlink" title=".3. Global Pooling"></a>.3. Global Pooling</h5><blockquote>
<p>PyG also supports <code>graph-level outputs</code>as opposed to node-level outputs by providing a variety of <code>readout functions such as global add, mean or max pooling</code>. We additionaly offer more sophisticated methods such as set-to-set (Vinyals et al., 2016), sort pooling (Zhang et al., 2018) or the global soft attention layer from Li et al. (2016).</p>
</blockquote>
<h5 id="4-Hierarchical-Pooling"><a href="#4-Hierarchical-Pooling" class="headerlink" title=".4. Hierarchical Pooling"></a>.4. Hierarchical Pooling</h5><blockquote>
<p>To further <code>extract hierarchical information</code> and to allow deeper GNN models, various<code>pooling approaches can be applied in a spatial or data-dependent manner.</code> We currently provide implementation examples for <code>Graclus</code> (Dhillon et al., 2007; Fagginger Auer &amp; Bisseling, 2011) and <code>voxel grid pooling</code> (Simonovsky &amp; Komodakis, 2017), the <code>iterative farthest point sampling algorithm</code> (Qi et al., 2017) followed by <code>k-NN or query ball graph generation</code> (Qi et al., 2017; Wang et al., 2018b), and differentiable pooling mechanisms such as <code>DiffPool</code> (Ying et al., 2018) and<code>topk pooling</code> (Gao &amp; Ji, 2018; Cangea et al., 2018)</p>
</blockquote>
<h3 id="4-Application"><a href="#4-Application" class="headerlink" title="4.  Application"></a>4.  Application</h3><blockquote>
<p>epidemiological forecasting, ride-hail demand prediction, web-traffic management, document labeling, fraud detection, traffic forecasting, chem-informatics systems</p>
</blockquote>
<h4 id="1-Epidemiological-Forecasting"><a href="#1-Epidemiological-Forecasting" class="headerlink" title=".1. Epidemiological Forecasting"></a>.1. Epidemiological Forecasting</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric_temporal.dataset <span class="keyword">import</span> ChickenpoxDatasetLoader</span><br><span class="line"><span class="keyword">from</span> torch_geometric_temporal.signal <span class="keyword">import</span> temporal_signal_split</span><br><span class="line">loader = ChickenpoxDatasetLoader()</span><br><span class="line">dataset = loader.get_dataset()</span><br><span class="line">train_dataset, test_dataset = temporal_signal_split(dataset, train_ratio=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_geometric_temporal.nn.recurrent <span class="keyword">import</span> DCRNN</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecurrentGCN</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, node_features)</span>:</span></span><br><span class="line">        super(RecurrentGCN, self).__init__()</span><br><span class="line">        self.recurrent = DCRNN(node_features, <span class="number">32</span>, <span class="number">1</span>)</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">32</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, edge_index, edge_weight)</span>:</span></span><br><span class="line">        h = self.recurrent(x, edge_index, edge_weight)</span><br><span class="line">        h = F.relu(h)</span><br><span class="line">        h = self.linear(h)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line">model = RecurrentGCN(node_features = <span class="number">4</span>)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> tqdm(range(<span class="number">200</span>)):</span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> time, snapshot <span class="keyword">in</span> enumerate(train_dataset):</span><br><span class="line">        y_hat = model(snapshot.x, snapshot.edge_index, snapshot.edge_attr)</span><br><span class="line">        cost = cost + torch.mean((y_hat-snapshot.y)**<span class="number">2</span>)</span><br><span class="line">    cost = cost / (time+<span class="number">1</span>)</span><br><span class="line">    cost.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    </span><br><span class="line">model.eval()</span><br><span class="line">cost = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> time, snapshot <span class="keyword">in</span> enumerate(test_dataset):</span><br><span class="line">    y_hat = model(snapshot.x, snapshot.edge_index, snapshot.edge_attr)</span><br><span class="line">    cost = cost + torch.mean((y_hat-snapshot.y)**<span class="number">2</span>)</span><br><span class="line">cost = cost / (time+<span class="number">1</span>)</span><br><span class="line">cost = cost.item()</span><br><span class="line">print(<span class="string">"MSE: {:.4f}"</span>.format(cost))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MSE: <span class="number">0.6866</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-Web-Traffic-Prediction"><a href="#2-Web-Traffic-Prediction" class="headerlink" title=".2. Web Traffic Prediction"></a>.2. Web Traffic Prediction</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric_temporal.dataset <span class="keyword">import</span> WikiMathsDatasetLoader</span><br><span class="line"><span class="keyword">from</span> torch_geometric_temporal.signal <span class="keyword">import</span> temporal_signal_split</span><br><span class="line">loader = WikiMathsDatasetLoader()</span><br><span class="line">dataset = loader.get_dataset(lags=<span class="number">14</span>)</span><br><span class="line">train_dataset, test_dataset = temporal_signal_split(dataset, train_ratio=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_geometric_temporal.nn.recurrent <span class="keyword">import</span> GConvGRU</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecurrentGCN</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, node_features, filters)</span>:</span></span><br><span class="line">        super(RecurrentGCN, self).__init__()</span><br><span class="line">        self.recurrent = GConvGRU(node_features, filters, <span class="number">2</span>)</span><br><span class="line">        self.linear = torch.nn.Linear(filters, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, edge_index, edge_weight)</span>:</span></span><br><span class="line">        h = self.recurrent(x, edge_index, edge_weight)</span><br><span class="line">        h = F.relu(h)</span><br><span class="line">        h = self.linear(h)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line">model = RecurrentGCN(node_features=<span class="number">14</span>, filters=<span class="number">32</span>)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> tqdm(range(<span class="number">50</span>)):</span><br><span class="line">    <span class="keyword">for</span> time, snapshot <span class="keyword">in</span> enumerate(train_dataset):</span><br><span class="line">        y_hat = model(snapshot.x, snapshot.edge_index, snapshot.edge_attr)</span><br><span class="line">        cost = torch.mean((y_hat-snapshot.y)**<span class="number">2</span>)</span><br><span class="line">        cost.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        </span><br><span class="line">model.eval()</span><br><span class="line">cost = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> time, snapshot <span class="keyword">in</span> enumerate(test_dataset):</span><br><span class="line">    y_hat = model(snapshot.x, snapshot.edge_index, snapshot.edge_attr)</span><br><span class="line">    cost = cost + torch.mean((y_hat-snapshot.y)**<span class="number">2</span>)</span><br><span class="line">cost = cost / (time+<span class="number">1</span>)</span><br><span class="line">cost = cost.item()</span><br><span class="line">print(<span class="string">"MSE: {:.4f}"</span>.format(cost))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MSE: <span class="number">0.7760</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-Cora-2layerGCN"><a href="#3-Cora-2layerGCN" class="headerlink" title=".3. Cora 2layerGCN"></a>.3. Cora 2layerGCN</h4><blockquote>
<p>一个epoch中的一个data包含一个完整的数据集</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line">dataset = Planetoid(root=<span class="string">'/tmp/Cora'</span>, name=<span class="string">'Cora'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        self.conv1 = GCNConv(dataset.num_node_features, <span class="number">16</span>)</span><br><span class="line">        self.conv2 = GCNConv(<span class="number">16</span>, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        x, edge_index = data.x, data.edge_index</span><br><span class="line"></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = F.dropout(x, training=self.training)</span><br><span class="line">        x = self.conv2(x, edge_index)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">model = Net().to(device)</span><br><span class="line">data = dataset[<span class="number">0</span>].to(device)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line"></span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">200</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    out = model(data)</span><br><span class="line">    loss = F.nll_loss(out[data.train_mask], data.y[data.train_mask])</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">model.eval()</span><br><span class="line">_, pred = model(data).max(dim=<span class="number">1</span>)</span><br><span class="line">correct = int(pred[data.test_mask].eq(data.y[data.test_mask]).sum().item())</span><br><span class="line">acc = correct / int(data.test_mask.sum())</span><br><span class="line">print(<span class="string">'Accuracy: {:.4f}'</span>.format(acc))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Accuracy: <span class="number">0.8150</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"><span class="keyword">import</span> torch_geometric.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"></span><br><span class="line">dataset = Planetoid(<span class="string">"Planetoid"</span>, name=<span class="string">"Cora"</span>, transform=T.ToSparseTensor())</span><br><span class="line">data = dataset[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Data(adj_t=[<span class="number">2708</span>, <span class="number">2708</span>, nnz=<span class="number">10556</span>], x=[<span class="number">2708</span>, <span class="number">1433</span>], y=[<span class="number">2708</span>], ...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        self.conv1 = GCNConv(dataset.num_features, <span class="number">16</span>, cached=<span class="literal">True</span>)</span><br><span class="line">        self.conv2 = GCNConv(<span class="number">16</span>, dataset.num_classes, cached=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, adj_t)</span>:</span></span><br><span class="line">        x = self.conv1(x, adj_t)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.conv2(x, adj_t)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(data)</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    out = model(data.x, data.adj_t)</span><br><span class="line">    loss = F.nll_loss(out, data.y)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    <span class="keyword">return</span> float(loss)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    loss = train(data)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-karate-club"><a href="#4-karate-club" class="headerlink" title=".4. karate club"></a>.4. karate club</h4><blockquote>
<p><strong>Zachary’s karate club</strong> is a social network of a university karate club, described in the paper “An Information Flow Model for Conflict and Fission in Small Groups” by Wayne W. Zachary. The network became a popular example of <a href="https://en.wikipedia.org/wiki/Community_structure" target="_blank" rel="noopener">community structure</a> in networks after its use by <a href="https://en.wikipedia.org/wiki/Michelle_Girvan" target="_blank" rel="noopener">Michelle Girvan</a> and <a href="https://en.wikipedia.org/wiki/Mark_Newman" target="_blank" rel="noopener">Mark Newman</a> in 2002.<a href="https://en.wikipedia.org/wiki/Zachary' target=" _blank"="" rel="noopener" s_karate_club#cite_note-gn-1"="">[1]</a>   </p>
</blockquote>
<ul>
<li><strong>Node Classification</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> KarateClub</span><br><span class="line">dataset = KarateClub()  <span class="comment">#1 graph, number of features: 34, classes:4, which represent the community each node belongs to.</span></span><br><span class="line"><span class="comment">#Data(edge_index=[2, 156], train_mask=[34], x=[34, 34], y=[34])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCN</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(GCN, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">12345</span>)</span><br><span class="line">        self.conv1 = GCNConv(dataset.num_features, <span class="number">4</span>)</span><br><span class="line">        self.conv2 = GCNConv(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        self.conv3 = GCNConv(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">        self.classifier = Linear(<span class="number">2</span>, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, edge_index)</span>:</span></span><br><span class="line">        h = self.conv1(x, edge_index)</span><br><span class="line">        h = h.tanh()</span><br><span class="line">        h = self.conv2(h, edge_index)</span><br><span class="line">        h = h.tanh()</span><br><span class="line">        h = self.conv3(h, edge_index)</span><br><span class="line">        h = h.tanh()  <span class="comment"># Final GNN embedding space.</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Apply a final (linear) classifier.</span></span><br><span class="line">        out = self.classifier(h)</span><br><span class="line">        <span class="keyword">return</span> out, h</span><br><span class="line"></span><br><span class="line">model = GCN()  <span class="comment">#34→4→4→2-&gt;num_classes, 每一个row表示一个节点，对每一个节点进行分类</span></span><br><span class="line">print(model)</span><br><span class="line"></span><br><span class="line">model = GCN()</span><br><span class="line">_, h = model(data.x, data.edge_index)</span><br><span class="line">print(<span class="string">f'Embedding shape: <span class="subst">{list(h.shape)}</span>'</span>)</span><br><span class="line">visualize(h, color=data.y)  <span class="comment">#h:&lt;class 'torch.Tensor'&gt;, grad_fn=&lt;TanhBackward&gt;) torch.Size([34, 2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Javascript  <span class="comment"># Restrict height of output cell.</span></span><br><span class="line">display(Javascript(<span class="string">'''google.colab.output.setIframeHeight(0, true, {maxHeight: 430})'''</span>))</span><br><span class="line"></span><br><span class="line">model = GCN()</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()  <span class="comment"># Define loss criterion.</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>)  <span class="comment"># Define optimizer.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(data)</span>:</span></span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line">    out, h = model(data.x, data.edge_index)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">    loss = criterion(out[data.train_mask], data.y[data.train_mask])  <span class="comment"># Compute the loss solely based on the training nodes.</span></span><br><span class="line">    loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">    optimizer.step()  <span class="comment"># Update parameters based on gradients.</span></span><br><span class="line">    <span class="keyword">return</span> loss, h</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">401</span>):</span><br><span class="line">    loss, h = train(data)</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        visualize(h, color=data.y, epoch=epoch, loss=loss)</span><br><span class="line">        time.sleep(<span class="number">0.3</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-Planetoid"><a href="#5-Planetoid" class="headerlink" title=".5. Planetoid"></a>.5. <a href="https://colab.research.google.com/drive/14OvFnAXggxB8vM4e8vSURUp1TaKnovzX?usp=sharing#scrollTo=9r_VmGMukf5R" target="_blank" rel="noopener">Planetoid</a></h4><ul>
<li><strong>Node Classification</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">from</span> torch_geometric.transforms <span class="keyword">import</span> NormalizeFeatures</span><br><span class="line"></span><br><span class="line">dataset = Planetoid(root=<span class="string">'data/Planetoid'</span>, name=<span class="string">'Cora'</span>, transform=NormalizeFeatures())</span><br><span class="line"><span class="comment">#Data(edge_index=[2, 10556], test_mask=[2708], train_mask=[2708], val_mask=[2708], x=[2708, 1433], y=[2708])</span></span><br><span class="line"><span class="comment">#Number of classes: 7</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>MLP</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hidden_channels)</span>:</span></span><br><span class="line">        super(MLP, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">12345</span>)</span><br><span class="line">        self.lin1 = Linear(dataset.num_features, hidden_channels)</span><br><span class="line">        self.lin2 = Linear(hidden_channels, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.lin1(x)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.lin2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = MLP(hidden_channels=<span class="number">16</span>)</span><br><span class="line">print(model)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Javascript  <span class="comment"># Restrict height of output cell.</span></span><br><span class="line">display(Javascript(<span class="string">'''google.colab.output.setIframeHeight(0, true, {maxHeight: 300})'''</span>))</span><br><span class="line"></span><br><span class="line">model = MLP(hidden_channels=<span class="number">16</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()  <span class="comment"># Define loss criterion.</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)  <span class="comment"># Define optimizer.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">      model.train()</span><br><span class="line">      optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line">      out = model(data.x)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">      loss = criterion(out[data.train_mask], data.y[data.train_mask])  <span class="comment"># Compute the loss solely based on the training nodes.</span></span><br><span class="line">      loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">      optimizer.step()  <span class="comment"># Update parameters based on gradients.</span></span><br><span class="line">      <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">      model.eval()</span><br><span class="line">      out = model(data.x)</span><br><span class="line">      pred = out.argmax(dim=<span class="number">1</span>)  <span class="comment"># Use the class with highest probability.</span></span><br><span class="line">      test_correct = pred[data.test_mask] == data.y[data.test_mask]  <span class="comment"># Check against ground-truth labels.</span></span><br><span class="line">      test_acc = int(test_correct.sum()) / int(data.test_mask.sum())  <span class="comment"># Derive ratio of correct predictions.</span></span><br><span class="line">      <span class="keyword">return</span> test_acc</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    print(<span class="string">f'Epoch: <span class="subst">{epoch:<span class="number">03</span>d}</span>, Loss: <span class="subst">{loss:<span class="number">.4</span>f}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>GCN</strong></li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618121248908.png" alt=""></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCN</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hidden_channels)</span>:</span></span><br><span class="line">        super(GCN, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">12345</span>)</span><br><span class="line">        self.conv1 = GCNConv(dataset.num_features, hidden_channels)</span><br><span class="line">        self.conv2 = GCNConv(hidden_channels, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, edge_index)</span>:</span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.conv2(x, edge_index)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = GCN(hidden_channels=<span class="number">16</span>)</span><br><span class="line">print(model)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Javascript  <span class="comment"># Restrict height of output cell.</span></span><br><span class="line">display(Javascript(<span class="string">'''google.colab.output.setIframeHeight(0, true, {maxHeight: 300})'''</span>))</span><br><span class="line"></span><br><span class="line">model = GCN(hidden_channels=<span class="number">16</span>)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">      model.train()</span><br><span class="line">      optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line">      out = model(data.x, data.edge_index)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">      loss = criterion(out[data.train_mask], data.y[data.train_mask])  <span class="comment"># Compute the loss solely based on the training nodes.</span></span><br><span class="line">      loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">      optimizer.step()  <span class="comment"># Update parameters based on gradients.</span></span><br><span class="line">      <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">      model.eval()</span><br><span class="line">      out = model(data.x, data.edge_index)</span><br><span class="line">      pred = out.argmax(dim=<span class="number">1</span>)  <span class="comment"># Use the class with highest probability.</span></span><br><span class="line">      test_correct = pred[data.test_mask] == data.y[data.test_mask]  <span class="comment"># Check against ground-truth labels.</span></span><br><span class="line">      test_acc = int(test_correct.sum()) / int(data.test_mask.sum())  <span class="comment"># Derive ratio of correct predictions.</span></span><br><span class="line">      <span class="keyword">return</span> test_acc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    print(<span class="string">f'Epoch: <span class="subst">{epoch:<span class="number">03</span>d}</span>, Loss: <span class="subst">{loss:<span class="number">.4</span>f}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="6-TUDdataset"><a href="#6-TUDdataset" class="headerlink" title=".6. TUDdataset"></a>.6. TUDdataset</h4><ul>
<li><strong>Graph classification</strong></li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618131022161.png" alt=""></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> TUDataset</span><br><span class="line"></span><br><span class="line">dataset = TUDataset(root=<span class="string">'data/TUDataset'</span>, name=<span class="string">'MUTAG'</span>)</span><br><span class="line"><span class="comment">#Data(edge_attr=[38, 4], edge_index=[2, 38], x=[17, 7], y=[1])</span></span><br><span class="line"><span class="comment">#Number of graphs: 188</span></span><br><span class="line"><span class="comment">#Number of features: 7</span></span><br><span class="line"><span class="comment">#Number of classes: 2</span></span><br><span class="line">torch.manual_seed(<span class="number">12345</span>)</span><br><span class="line">dataset = dataset.shuffle()</span><br><span class="line"></span><br><span class="line">train_dataset = dataset[:<span class="number">150</span>]</span><br><span class="line">test_dataset = dataset[<span class="number">150</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(train_dataset, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_dataset, batch_size=<span class="number">64</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step, data <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">    print(<span class="string">f'Step <span class="subst">{step + <span class="number">1</span>}</span>:'</span>)</span><br><span class="line">    print(<span class="string">'======='</span>)</span><br><span class="line">    print(<span class="string">f'Number of graphs in the current batch: <span class="subst">{data.num_graphs}</span>'</span>)</span><br><span class="line">    print(data) <span class="comment">#Batch(batch=[1169], edge_attr=[2592, 4], edge_index=[2, 2592], x=[1169, 7], y=[64])</span></span><br><span class="line">    print()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> global_mean_pool</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCN</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hidden_channels)</span>:</span></span><br><span class="line">        super(GCN, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">12345</span>)</span><br><span class="line">        self.conv1 = GCNConv(dataset.num_node_features, hidden_channels)</span><br><span class="line">        self.conv2 = GCNConv(hidden_channels, hidden_channels)</span><br><span class="line">        self.conv3 = GCNConv(hidden_channels, hidden_channels)</span><br><span class="line">        self.lin = Linear(hidden_channels, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, edge_index, batch)</span>:</span></span><br><span class="line">        <span class="comment"># 1. Obtain node embeddings </span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = self.conv2(x, edge_index)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = self.conv3(x, edge_index)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. Readout layer</span></span><br><span class="line">        x = global_mean_pool(x, batch)  <span class="comment"># [batch_size, hidden_channels]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. Apply a final classifier</span></span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.lin(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = GCN(hidden_channels=<span class="number">64</span>)</span><br><span class="line">print(model)</span><br><span class="line"><span class="comment">#GCN(</span></span><br><span class="line"><span class="comment">#  (conv1): GCNConv(7, 64)</span></span><br><span class="line"><span class="comment">#  (conv2): GCNConv(64, 64)</span></span><br><span class="line"><span class="comment">#  (conv3): GCNConv(64, 64)</span></span><br><span class="line"><span class="comment">#  (lin): Linear(in_features=64, out_features=2, bias=True)</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Javascript</span><br><span class="line">display(Javascript(<span class="string">'''google.colab.output.setIframeHeight(0, true, {maxHeight: 300})'''</span>))</span><br><span class="line"></span><br><span class="line">model = GCN(hidden_channels=<span class="number">64</span>)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_loader:  <span class="comment"># Iterate in batches over the training dataset.</span></span><br><span class="line">         out = model(data.x, data.edge_index, data.batch)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">         loss = criterion(out, data.y)  <span class="comment"># Compute the loss.</span></span><br><span class="line">         loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">         optimizer.step()  <span class="comment"># Update parameters based on gradients.</span></span><br><span class="line">         optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(loader)</span>:</span></span><br><span class="line">     model.eval()</span><br><span class="line"></span><br><span class="line">     correct = <span class="number">0</span></span><br><span class="line">     <span class="keyword">for</span> data <span class="keyword">in</span> loader:  <span class="comment"># Iterate in batches over the training/test dataset.</span></span><br><span class="line">         out = model(data.x, data.edge_index, data.batch)  </span><br><span class="line">         pred = out.argmax(dim=<span class="number">1</span>)  <span class="comment"># Use the class with highest probability.</span></span><br><span class="line">         correct += int((pred == data.y).sum())  <span class="comment"># Check against ground-truth labels.</span></span><br><span class="line">     <span class="keyword">return</span> correct / len(loader.dataset)  <span class="comment"># Derive ratio of correct predictions.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    train()</span><br><span class="line">    train_acc = test(train_loader)</span><br><span class="line">    test_acc = test(test_loader)</span><br><span class="line">    print(<span class="string">f'Epoch: <span class="subst">{epoch:<span class="number">03</span>d}</span>, Train Acc: <span class="subst">{train_acc:<span class="number">.4</span>f}</span>, Test Acc: <span class="subst">{test_acc:<span class="number">.4</span>f}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="7-PointCloudClassification"><a href="#7-PointCloudClassification" class="headerlink" title=".7. PointCloudClassification"></a>.7. PointCloudClassification</h4><ul>
<li>GeometricShapes</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install required packages.</span></span><br><span class="line">!pip install -q torch-scatter -f https://pytorch-geometric.com/whl/torch<span class="number">-1.8</span><span class="number">.0</span>+cu101.html</span><br><span class="line">!pip install -q torch-sparse -f https://pytorch-geometric.com/whl/torch<span class="number">-1.8</span><span class="number">.0</span>+cu101.html</span><br><span class="line">!pip install -q torch-cluster -f https://pytorch-geometric.com/whl/torch<span class="number">-1.8</span><span class="number">.0</span>+cu101.html</span><br><span class="line">!pip install -q torch-geometric</span><br><span class="line"></span><br><span class="line"><span class="comment"># Helper functions for visualization.</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_mesh</span><span class="params">(pos, face)</span>:</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.gca(projection=<span class="string">'3d'</span>)</span><br><span class="line">    ax.axes.xaxis.set_ticklabels([])</span><br><span class="line">    ax.axes.yaxis.set_ticklabels([])</span><br><span class="line">    ax.axes.zaxis.set_ticklabels([])</span><br><span class="line">    ax.plot_trisurf(pos[:, <span class="number">0</span>], pos[:, <span class="number">1</span>], pos[:, <span class="number">2</span>], triangles=data.face.t(), antialiased=<span class="literal">False</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_points</span><span class="params">(pos, edge_index=None, index=None)</span>:</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">if</span> edge_index <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> (src, dst) <span class="keyword">in</span> edge_index.t().tolist():</span><br><span class="line">             src = pos[src].tolist()</span><br><span class="line">             dst = pos[dst].tolist()</span><br><span class="line">             plt.plot([src[<span class="number">0</span>], dst[<span class="number">0</span>]], [src[<span class="number">1</span>], dst[<span class="number">1</span>]], linewidth=<span class="number">1</span>, color=<span class="string">'black'</span>)</span><br><span class="line">    <span class="keyword">if</span> index <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        plt.scatter(pos[:, <span class="number">0</span>], pos[:, <span class="number">1</span>], s=<span class="number">50</span>, zorder=<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">       mask = torch.zeros(pos.size(<span class="number">0</span>), dtype=torch.bool)</span><br><span class="line">       mask[index] = <span class="literal">True</span></span><br><span class="line">       plt.scatter(pos[~mask, <span class="number">0</span>], pos[~mask, <span class="number">1</span>], s=<span class="number">50</span>, color=<span class="string">'lightgray'</span>, zorder=<span class="number">1000</span>)</span><br><span class="line">       plt.scatter(pos[mask, <span class="number">0</span>], pos[mask, <span class="number">1</span>], s=<span class="number">50</span>, zorder=<span class="number">1000</span>)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#load dataset</span></span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> GeometricShapes</span><br><span class="line">dataset = GeometricShapes(root=<span class="string">'data/GeometricShapes'</span>)</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>transform our meshes into points via the usage of “transforms”. Here, PyTorch Geometric provides the <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/transforms.html#torch_geometric.transforms.SamplePoints" target="_blank" rel="noopener"><code>torch_geometric.transforms.SamplePoints</code></a> transformation, which will uniformly sample a fixed number of points on the mesh faces according to their face area.</p>
</blockquote>
<ul>
<li><strong>RandomRotate</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.transforms <span class="keyword">import</span> Compose, RandomRotate</span><br><span class="line"></span><br><span class="line">torch.manual_seed(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">random_rotate = Compose([</span><br><span class="line">    RandomRotate(degrees=<span class="number">180</span>, axis=<span class="number">0</span>),</span><br><span class="line">    RandomRotate(degrees=<span class="number">180</span>, axis=<span class="number">1</span>),</span><br><span class="line">    RandomRotate(degrees=<span class="number">180</span>, axis=<span class="number">2</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">dataset = GeometricShapes(root=<span class="string">'data/GeometricShapes'</span>, transform=random_rotate)</span><br><span class="line"></span><br><span class="line">data = dataset[<span class="number">0</span>]</span><br><span class="line">print(data)</span><br><span class="line">visualize_mesh(data.pos, data.face)</span><br><span class="line"></span><br><span class="line">data = dataset[<span class="number">4</span>]</span><br><span class="line">print(data)</span><br><span class="line">visualize_mesh(data.pos, data.face)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>SamplePoints</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.transforms <span class="keyword">import</span> SamplePoints</span><br><span class="line"></span><br><span class="line">torch.manual_seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">dataset.transform = SamplePoints(num=<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">data = dataset[<span class="number">0</span>]</span><br><span class="line">print(data)   <span class="comment">#Data(face=[3, 30], pos=[32, 3], y=[1]) =&gt;Data(pos=[256, 3], y=[1])</span></span><br><span class="line">visualize_points(data.pos, data.edge_index)</span><br><span class="line"></span><br><span class="line">data = dataset[<span class="number">4</span>]</span><br><span class="line">print(data)   <span class="comment">#Data(face=[3, 2], pos=[4, 3], y=[1])=&gt;Data(pos=[256, 3], y=[1])</span></span><br><span class="line">visualize_points(data.pos)</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618133509868.png" alt=""></p>
<blockquote>
<p><code>PointNet++</code> processes <code>point clouds iteratively</code> by following a <code>simple grouping, neighborhood aggregation and downsampling scheme:</code></p>
<ol>
<li>The <strong>grouping phase</strong> constructs a graph in which <code>nearby points are connected</code>. Typically, this is either done via <code>k-nearest neighbor search</code> or via <code>ball queries (which connects all points that are within a radius to the query point).</code></li>
<li>The <strong>neighborhood aggregation phase</strong> executes a Graph Neural Network layer that, for each point,<code>aggregates information from its direct neighbors</code>(given by the graph constructed in the previous phase). This allows PointNet++ to capture local context at different scales.</li>
<li>The <strong>downsampling phase</strong> implements a pooling scheme suitable for point clouds with potentially different sizes. We will ignore this phase for now and will come back later to it.</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618132211963.png" alt=""></p>
<ul>
<li><strong>knn_graph</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_cluster <span class="keyword">import</span> knn_graph</span><br><span class="line"></span><br><span class="line">data = dataset[<span class="number">0</span>]</span><br><span class="line">data.edge_index = knn_graph(data.pos, k=<span class="number">6</span>)</span><br><span class="line">print(data.edge_index.shape)</span><br><span class="line">visualize_points(data.pos, edge_index=data.edge_index)</span><br><span class="line"></span><br><span class="line">data = dataset[<span class="number">4</span>]</span><br><span class="line">data.edge_index = knn_graph(data.pos, k=<span class="number">6</span>)</span><br><span class="line">print(data.edge_index.shape)</span><br><span class="line">visualize_points(data.pos, edge_index=data.edge_index)</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618132356302.png" alt=""></p>
<ul>
<li><strong>Neighborhood Aggregation</strong></li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618132502775.png" alt=""></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Sequential, Linear, ReLU</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> MessagePassing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointNetLayer</span><span class="params">(MessagePassing)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_channels, out_channels)</span>:</span></span><br><span class="line">        <span class="comment"># Message passing with "max" aggregation.</span></span><br><span class="line">        super(PointNetLayer, self).__init__(<span class="string">'max'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Initialization of the MLP:</span></span><br><span class="line">        <span class="comment"># Here, the number of input features correspond to the hidden node</span></span><br><span class="line">        <span class="comment"># dimensionality plus point dimensionality (=3).</span></span><br><span class="line">        self.mlp = Sequential(Linear(in_channels + <span class="number">3</span>, out_channels),</span><br><span class="line">                              ReLU(),</span><br><span class="line">                              Linear(out_channels, out_channels))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, h, pos, edge_index)</span>:</span></span><br><span class="line">        <span class="comment"># Start propagating messages.</span></span><br><span class="line">        <span class="keyword">return</span> self.propagate(edge_index, h=h, pos=pos)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">message</span><span class="params">(self, h_j, pos_j, pos_i)</span>:</span></span><br><span class="line">        <span class="comment"># h_j defines the features of neighboring nodes as shape [num_edges, in_channels]</span></span><br><span class="line">        <span class="comment"># pos_j defines the position of neighboring nodes as shape [num_edges, 3]</span></span><br><span class="line">        <span class="comment"># pos_i defines the position of central nodes as shape [num_edges, 3]</span></span><br><span class="line"></span><br><span class="line">        input = pos_j - pos_i  <span class="comment"># Compute spatial relation.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> h_j <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># In the first layer, we may not have any hidden node features,</span></span><br><span class="line">            <span class="comment"># so we only combine them in case they are present.</span></span><br><span class="line">            input = torch.cat([h_j, input], dim=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.mlp(input)  <span class="comment"># Apply our final MLP.</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_cluster <span class="keyword">import</span> knn_graph</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> global_max_pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointNet</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(PointNet, self).__init__()</span><br><span class="line"></span><br><span class="line">        torch.manual_seed(<span class="number">12345</span>)</span><br><span class="line">        self.conv1 = PointNetLayer(<span class="number">3</span>, <span class="number">32</span>)</span><br><span class="line">        self.conv2 = PointNetLayer(<span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">        self.classifier = Linear(<span class="number">32</span>, dataset.num_classes)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, pos, batch)</span>:</span></span><br><span class="line">        <span class="comment"># Compute the kNN graph:</span></span><br><span class="line">        <span class="comment"># Here, we need to pass the batch vector to the function call in order</span></span><br><span class="line">        <span class="comment"># to prevent creating edges between points of different examples.</span></span><br><span class="line">        <span class="comment"># We also add `loop=True` which will add self-loops to the graph in</span></span><br><span class="line">        <span class="comment"># order to preserve central point information.</span></span><br><span class="line">        edge_index = knn_graph(pos, k=<span class="number">16</span>, batch=batch, loop=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. Start bipartite message passing.</span></span><br><span class="line">        h = self.conv1(h=pos, pos=pos, edge_index=edge_index)</span><br><span class="line">        h = h.relu()</span><br><span class="line">        h = self.conv2(h=h, pos=pos, edge_index=edge_index)</span><br><span class="line">        h = h.relu()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. Global Pooling.</span></span><br><span class="line">        h = global_max_pool(h, batch)  <span class="comment"># [num_examples, hidden_channels]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 5. Classifier.</span></span><br><span class="line">        <span class="keyword">return</span> self.classifier(h)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = PointNet()</span><br><span class="line">print(model)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Javascript  <span class="comment"># Restrict height of output cell.</span></span><br><span class="line">display(Javascript(<span class="string">'''google.colab.output.setIframeHeight(0, true, {maxHeight: 300})'''</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">train_dataset = GeometricShapes(root=<span class="string">'data/GeometricShapes'</span>, train=<span class="literal">True</span>,</span><br><span class="line">                                transform=SamplePoints(<span class="number">128</span>))</span><br><span class="line">test_dataset = GeometricShapes(root=<span class="string">'data/GeometricShapes'</span>, train=<span class="literal">False</span>,</span><br><span class="line">                               transform=SamplePoints(<span class="number">128</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(train_dataset, batch_size=<span class="number">10</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_dataset, batch_size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">model = PointNet()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()  <span class="comment"># Define loss criterion.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(model, optimizer, loader)</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line">    </span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> loader:</span><br><span class="line">        optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line">        <span class="comment">#batch(batch=[1280], pos=[1280, 3], ptr=[11], y=[10])</span></span><br><span class="line">        logits = model(data.pos, data.batch)  <span class="comment"># Forward pass.</span></span><br><span class="line">        loss = criterion(logits, data.y)  <span class="comment"># Loss computation.</span></span><br><span class="line">        loss.backward()  <span class="comment"># Backward pass.</span></span><br><span class="line">        optimizer.step()  <span class="comment"># Update model parameters.</span></span><br><span class="line">        total_loss += loss.item() * data.num_graphs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_loss / len(train_loader.dataset)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(model, loader)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line"></span><br><span class="line">    total_correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> loader:</span><br><span class="line">        logits = model(data.pos, data.batch)</span><br><span class="line">        pred = logits.argmax(dim=<span class="number">-1</span>)</span><br><span class="line">        total_correct += int((pred == data.y).sum())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_correct / len(loader.dataset)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">51</span>):</span><br><span class="line">    loss = train(model, optimizer, train_loader)</span><br><span class="line">    test_acc = test(model, test_loader)</span><br><span class="line">    print(<span class="string">f'Epoch: <span class="subst">{epoch:<span class="number">02</span>d}</span>, Loss: <span class="subst">{loss:<span class="number">.4</span>f}</span>, Test Accuracy: <span class="subst">{test_acc:<span class="number">.4</span>f}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="8-BigGraph"><a href="#8-BigGraph" class="headerlink" title=".8. BigGraph"></a>.8. BigGraph</h4><blockquote>
<p><strong>Cluster-GCN</strong> (<a href="https://arxiv.org/abs/1905.07953" target="_blank" rel="noopener">Chiang et al. (2019)</a>, which is based on<code>pre-partitioning the graph into subgraphs on which one can operate in a mini-batch fashion</code>.</p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210618134507044.png" alt="image-20210618134507044"></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">from</span> torch_geometric.transforms <span class="keyword">import</span> NormalizeFeatures</span><br><span class="line"></span><br><span class="line">dataset = Planetoid(root=<span class="string">'data/Planetoid'</span>, name=<span class="string">'PubMed'</span>, transform=NormalizeFeatures())</span><br><span class="line"><span class="comment">#Data(edge_index=[2, 88648], test_mask=[19717], train_mask=[19717], val_mask=[19717], x=[19717, 500], y=[19717])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> ClusterData, ClusterLoader</span><br><span class="line">torch.manual_seed(<span class="number">12345</span>)</span><br><span class="line">cluster_data = ClusterData(data, num_parts=<span class="number">128</span>)  <span class="comment"># 1. Create subgraphs.</span></span><br><span class="line">train_loader = ClusterLoader(cluster_data, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>)  <span class="comment"># 2. Stochastic partioning scheme.</span></span><br><span class="line">print()</span><br><span class="line">total_num_nodes = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> step, sub_data <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">    print(<span class="string">f'Step <span class="subst">{step + <span class="number">1</span>}</span>:'</span>)</span><br><span class="line">    print(<span class="string">'======='</span>)</span><br><span class="line">    print(<span class="string">f'Number of nodes in the current batch: <span class="subst">{sub_data.num_nodes}</span>'</span>)</span><br><span class="line">    print(sub_data)<span class="comment">#Data(edge_index=[2, 15230], test_mask=[4946], train_mask=[4946], val_mask=[4946], x=[4946, 500], y=[4946])</span></span><br><span class="line">    print()</span><br><span class="line">    total_num_nodes += sub_data.num_nodes</span><br><span class="line">print(<span class="string">f'Iterated over <span class="subst">{total_num_nodes}</span> of <span class="subst">{data.num_nodes}</span> nodes!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCN</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hidden_channels)</span>:</span></span><br><span class="line">        super(GCN, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">12345</span>)</span><br><span class="line">        self.conv1 = GCNConv(dataset.num_node_features, hidden_channels)</span><br><span class="line">        self.conv2 = GCNConv(hidden_channels, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, edge_index)</span>:</span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.conv2(x, edge_index)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = GCN(hidden_channels=<span class="number">16</span>)</span><br><span class="line">print(model)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Javascript</span><br><span class="line">display(Javascript(<span class="string">'''google.colab.output.setIframeHeight(0, true, {maxHeight: 300})'''</span>))</span><br><span class="line">model = GCN(hidden_channels=<span class="number">16</span>)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">      model.train()</span><br><span class="line">      <span class="keyword">for</span> sub_data <span class="keyword">in</span> train_loader:  <span class="comment"># Iterate over each mini-batch.</span></span><br><span class="line">          out = model(sub_data.x, sub_data.edge_index)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">          loss = criterion(out[sub_data.train_mask], sub_data.y[sub_data.train_mask])  <span class="comment"># Compute the loss solely based on the training nodes.</span></span><br><span class="line">          loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">          optimizer.step()  <span class="comment"># Update parameters based on gradients.</span></span><br><span class="line">          optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">      model.eval()</span><br><span class="line">      out = model(data.x, data.edge_index)</span><br><span class="line">      pred = out.argmax(dim=<span class="number">1</span>)  <span class="comment"># Use the class with highest probability.</span></span><br><span class="line">      </span><br><span class="line">      accs = []</span><br><span class="line">      <span class="keyword">for</span> mask <span class="keyword">in</span> [data.train_mask, data.val_mask, data.test_mask]:</span><br><span class="line">          correct = pred[mask] == data.y[mask]  <span class="comment"># Check against ground-truth labels.</span></span><br><span class="line">          accs.append(int(correct.sum()) / int(mask.sum()))  <span class="comment"># Derive ratio of correct predictions.</span></span><br><span class="line">      <span class="keyword">return</span> accs</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">51</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    train_acc, val_acc, test_acc = test()</span><br><span class="line">    print(<span class="string">f'Epoch: <span class="subst">{epoch:<span class="number">03</span>d}</span>, Train: <span class="subst">{train_acc:<span class="number">.4</span>f}</span>, Val Acc: <span class="subst">{val_acc:<span class="number">.4</span>f}</span>, Test Acc: <span class="subst">{test_acc:<span class="number">.4</span>f}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="9-GNNModelExplain"><a href="#9-GNNModelExplain" class="headerlink" title=".9. GNNModelExplain"></a>.9. GNNModelExplain</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> TUDataset</span><br><span class="line">path = <span class="string">'.'</span></span><br><span class="line">dataset = TUDataset(path, name=<span class="string">'Mutagenicity'</span>).shuffle()</span><br><span class="line">test_dataset = dataset[:len(dataset) // <span class="number">10</span>]</span><br><span class="line">train_dataset = dataset[len(dataset) // <span class="number">10</span>:]</span><br><span class="line">test_loader = DataLoader(test_dataset, batch_size=<span class="number">128</span>)</span><br><span class="line">train_loader = DataLoader(train_dataset, batch_size=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#model define</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> global_add_pool, GraphConv</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dim)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line"></span><br><span class="line">        num_features = dataset.num_features</span><br><span class="line">        self.dim = dim</span><br><span class="line"></span><br><span class="line">        self.conv1 = GraphConv(num_features, dim)</span><br><span class="line">        self.conv2 = GraphConv(dim, dim)</span><br><span class="line">        self.conv3 = GraphConv(dim, dim)</span><br><span class="line">        self.conv4 = GraphConv(dim, dim)</span><br><span class="line">        self.conv5 = GraphConv(dim, dim)</span><br><span class="line"></span><br><span class="line">        self.fc1 = Linear(dim, dim)</span><br><span class="line">        self.fc2 = Linear(dim, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, edge_index, batch, edge_weight=None)</span>:</span></span><br><span class="line">        x = F.relu(self.conv1(x, edge_index, edge_weight))</span><br><span class="line">        x = F.relu(self.conv2(x, edge_index, edge_weight))</span><br><span class="line">        x = F.relu(self.conv3(x, edge_index, edge_weight))</span><br><span class="line">        x = F.relu(self.conv4(x, edge_index, edge_weight))</span><br><span class="line">        x = F.relu(self.conv5(x, edge_index, edge_weight))</span><br><span class="line">        x = global_add_pool(x, batch)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># train&amp;test function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(epoch)</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> epoch == <span class="number">51</span>:</span><br><span class="line">        <span class="keyword">for</span> param_group <span class="keyword">in</span> optimizer.param_groups:</span><br><span class="line">            param_group[<span class="string">'lr'</span>] = <span class="number">0.5</span> * param_group[<span class="string">'lr'</span>]</span><br><span class="line"></span><br><span class="line">    loss_all = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_loader:</span><br><span class="line">        data = data.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment">#Batch(batch=[3977], edge_attr=[7906, 3], edge_index=[2, 7906], ptr=[129], x=[3977, 14], y=[128])</span></span><br><span class="line">        output = model(data.x, data.edge_index, data.batch)</span><br><span class="line">        loss = F.nll_loss(output, data.y)</span><br><span class="line">        loss.backward()</span><br><span class="line">        loss_all += loss.item() * data.num_graphs</span><br><span class="line">        optimizer.step()</span><br><span class="line">    <span class="keyword">return</span> loss_all / len(train_dataset)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(loader)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line"></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> loader:</span><br><span class="line">        data = data.to(device)</span><br><span class="line">        output = model(data.x, data.edge_index, data.batch)</span><br><span class="line">        pred = output.max(dim=<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">        correct += pred.eq(data.y).sum().item()</span><br><span class="line">    <span class="keyword">return</span> correct / len(loader.dataset)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">model = Net(dim=<span class="number">32</span>).to(device)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">    train_loss = train(epoch)</span><br><span class="line">    train_acc = test(train_loader)</span><br><span class="line">    test_acc = test(test_loader)</span><br><span class="line">    print(<span class="string">'Epoch: {:03d}, Train Loss: {:.7f}, '</span></span><br><span class="line">          <span class="string">'Train Acc: {:.7f}, Test Acc: {:.7f}'</span>.format(epoch, train_loss,</span><br><span class="line">                                                       train_acc, test_acc))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> captum.attr <span class="keyword">import</span> Saliency, IntegratedGradients</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model_forward</span><span class="params">(edge_mask, data)</span>:</span></span><br><span class="line">    batch = torch.zeros(data.x.shape[<span class="number">0</span>], dtype=int).to(device)</span><br><span class="line">    out = model(data.x, data.edge_index, batch, edge_mask)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">explain</span><span class="params">(method, data, target=<span class="number">0</span>)</span>:</span></span><br><span class="line">    input_mask = torch.ones(data.edge_index.shape[<span class="number">1</span>]).requires_grad_(<span class="literal">True</span>).to(device)</span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">'ig'</span>:</span><br><span class="line">        ig = IntegratedGradients(model_forward)</span><br><span class="line">        mask = ig.attribute(input_mask, target=target,</span><br><span class="line">                            additional_forward_args=(data,),</span><br><span class="line">                            internal_batch_size=data.edge_index.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">'saliency'</span>:</span><br><span class="line">        saliency = Saliency(model_forward)</span><br><span class="line">        mask = saliency.attribute(input_mask, target=target,</span><br><span class="line">                                  additional_forward_args=(data,))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unknown explanation method'</span>)</span><br><span class="line"></span><br><span class="line">    edge_mask = np.abs(mask.cpu().detach().numpy())</span><br><span class="line">    <span class="keyword">if</span> edge_mask.max() &gt; <span class="number">0</span>:  <span class="comment"># avoid division by zero</span></span><br><span class="line">        edge_mask = edge_mask / edge_mask.max()</span><br><span class="line">    <span class="keyword">return</span> edge_mask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate_edge_directions</span><span class="params">(edge_mask, data)</span>:</span></span><br><span class="line">    edge_mask_dict = defaultdict(float)</span><br><span class="line">    <span class="keyword">for</span> val, u, v <span class="keyword">in</span> list(zip(edge_mask, *data.edge_index)):</span><br><span class="line">        u, v = u.item(), v.item()</span><br><span class="line">        <span class="keyword">if</span> u &gt; v:</span><br><span class="line">            u, v = v, u</span><br><span class="line">        edge_mask_dict[(u, v)] += val</span><br><span class="line">    <span class="keyword">return</span> edge_mask_dict</span><br><span class="line">  </span><br><span class="line">data = random.choice([t <span class="keyword">for</span> t <span class="keyword">in</span> test_dataset <span class="keyword">if</span> <span class="keyword">not</span> t.y.item()])</span><br><span class="line">mol = to_molecule(data)</span><br><span class="line"><span class="keyword">for</span> title, method <span class="keyword">in</span> [(<span class="string">'Integrated Gradients'</span>, <span class="string">'ig'</span>), (<span class="string">'Saliency'</span>, <span class="string">'saliency'</span>)]:</span><br><span class="line">    edge_mask = explain(method, data, target=<span class="number">0</span>)</span><br><span class="line">    edge_mask_dict = aggregate_edge_directions(edge_mask, data)</span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">    plt.title(title)</span><br><span class="line">    draw_molecule(mol, edge_mask_dict)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-Visualization"><a href="#5-Visualization" class="headerlink" title="5. Visualization"></a>5. Visualization</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.utils <span class="keyword">import</span> to_networkx</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize</span><span class="params">(h, color, epoch=None, loss=None)</span>:</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">7</span>,<span class="number">7</span>))</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> torch.is_tensor(h):</span><br><span class="line">        h = h.detach().cpu().numpy()</span><br><span class="line">        plt.scatter(h[:, <span class="number">0</span>], h[:, <span class="number">1</span>], s=<span class="number">140</span>, c=color, cmap=<span class="string">"Set2"</span>)</span><br><span class="line">        <span class="keyword">if</span> epoch <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> loss <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            plt.xlabel(<span class="string">f'Epoch: <span class="subst">{epoch}</span>, Loss: <span class="subst">{loss.item():<span class="number">.4</span>f}</span>'</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nx.draw_networkx(G, pos=nx.spring_layout(G, seed=<span class="number">42</span>), with_labels=<span class="literal">False</span>,</span><br><span class="line">                         node_color=color, cmap=<span class="string">"Set2"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#data: Data(edge_index=[2, 156], train_mask=[34], x=[34, 34], y=[34])    </span></span><br><span class="line">G = to_networkx(data, to_undirected=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#G &lt;class 'networkx.classes.graph.Graph'&gt;</span></span><br><span class="line">visualize(G, color=data.y)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch_geometric.utils <span class="keyword">import</span> to_networkx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_molecule</span><span class="params">(g, edge_mask=None, draw_edge_labels=False)</span>:</span></span><br><span class="line">    g = g.copy().to_undirected()</span><br><span class="line">    node_labels = {}</span><br><span class="line">    <span class="keyword">for</span> u, data <span class="keyword">in</span> g.nodes(data=<span class="literal">True</span>):</span><br><span class="line">        node_labels[u] = data[<span class="string">'name'</span>]</span><br><span class="line">    pos = nx.planar_layout(g)</span><br><span class="line">    pos = nx.spring_layout(g, pos=pos)</span><br><span class="line">    <span class="keyword">if</span> edge_mask <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        edge_color = <span class="string">'black'</span></span><br><span class="line">        widths = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        edge_color = [edge_mask[(u, v)] <span class="keyword">for</span> u, v <span class="keyword">in</span> g.edges()]</span><br><span class="line">        widths = [x * <span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> edge_color]</span><br><span class="line">    nx.draw(g, pos=pos, labels=node_labels, width=widths,</span><br><span class="line">            edge_color=edge_color, edge_cmap=plt.cm.Blues,</span><br><span class="line">            node_color=<span class="string">'azure'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> draw_edge_labels <span class="keyword">and</span> edge_mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        edge_labels = {k: (<span class="string">'%.2f'</span> % v) <span class="keyword">for</span> k, v <span class="keyword">in</span> edge_mask.items()}    </span><br><span class="line">        nx.draw_networkx_edge_labels(g, pos, edge_labels=edge_labels,</span><br><span class="line">                                    font_color=<span class="string">'red'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_molecule</span><span class="params">(data)</span>:</span></span><br><span class="line">    ATOM_MAP = [<span class="string">'C'</span>, <span class="string">'O'</span>, <span class="string">'Cl'</span>, <span class="string">'H'</span>, <span class="string">'N'</span>, <span class="string">'F'</span>,</span><br><span class="line">                <span class="string">'Br'</span>, <span class="string">'S'</span>, <span class="string">'P'</span>, <span class="string">'I'</span>, <span class="string">'Na'</span>, <span class="string">'K'</span>, <span class="string">'Li'</span>, <span class="string">'Ca'</span>]</span><br><span class="line">    g = to_networkx(data, node_attrs=[<span class="string">'x'</span>])</span><br><span class="line">    <span class="keyword">for</span> u, data <span class="keyword">in</span> g.nodes(data=<span class="literal">True</span>):</span><br><span class="line">        data[<span class="string">'name'</span>] = ATOM_MAP[data[<span class="string">'x'</span>].index(<span class="number">1.0</span>)]</span><br><span class="line">        <span class="keyword">del</span> data[<span class="string">'x'</span>]</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">data = random.choice([t <span class="keyword">for</span> t <span class="keyword">in</span> train_dataset])</span><br><span class="line">print(type(data),data)</span><br><span class="line">mol = to_molecule(data)</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">print(type(mol))</span><br><span class="line">draw_molecule(mol)</span><br><span class="line"><span class="comment">#&lt;class 'torch_geometric.data.data.Data'&gt; Data(edge_attr=[76, 3], edge_index=[2, 76], x=[34, 14], y=[1])</span></span><br><span class="line"><span class="comment">#&lt;class 'networkx.classes.digraph.DiGraph'&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-Demo"><a href="#6-Demo" class="headerlink" title="6. Demo"></a>6. Demo</h3><h4 id="1-Customed-dataset"><a href="#1-Customed-dataset" class="headerlink" title=".1. Customed dataset"></a>.1. Customed dataset</h4><ul>
<li>dataset generate</li>
</ul>
<blockquote>
<ul>
<li><p>10 graphs and 30 nodes per graph with random edges connections</p>
</li>
<li><p>number of node feature = 3</p>
</li>
<li><p>number of edge feature = 1</p>
</li>
<li><p>node’s classification and graph classification</p>
<p>  Adj [num_graph, num_node, num_node] be the adjacent matrices (sparse)<br>  node_feature [num_graph, num_node, num_node_feature]<br>  edge_feature [num_graph, num_node, num_node] (sparse)</p>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> InMemoryDataset</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data</span><br><span class="line"><span class="keyword">import</span> torch_geometric.utils <span class="keyword">as</span> ut</span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">num_graph = <span class="number">10</span></span><br><span class="line">num_node = <span class="number">50</span></span><br><span class="line">num_node_features = <span class="number">3</span></span><br><span class="line">num_edge_features = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Adj = np.random.rand(num_graph, num_node, num_node)</span><br><span class="line">Adj[Adj &gt;= <span class="number">0.8</span>] = <span class="literal">True</span></span><br><span class="line">Adj[Adj &lt;= <span class="number">0.8</span>] = <span class="literal">False</span></span><br><span class="line">node_feature = np.random.rand(num_graph, num_node, num_node_features)</span><br><span class="line">edge_feature = np.random.rand(num_graph, num_node, num_node) * Adj</span><br><span class="line"></span><br><span class="line">graph_label = np.random.rand(num_graph)</span><br><span class="line">graph_label[graph_label&gt;<span class="number">0.5</span>] = <span class="number">1</span></span><br><span class="line">graph_label[graph_label&lt;<span class="number">0.5</span>] = <span class="number">0</span></span><br><span class="line">graph_label = graph_label.astype(int)</span><br><span class="line"></span><br><span class="line">node_label = np. random.rand(num_graph, num_node)</span><br><span class="line">node_label[node_label&gt;<span class="number">0.5</span>] = <span class="number">1</span></span><br><span class="line">node_label[node_label&lt;<span class="number">0.5</span>] = <span class="number">0</span></span><br><span class="line">node_label = node_label.astype(int)</span><br><span class="line"></span><br><span class="line">print(Adj[<span class="number">0</span>, :,:], edge_feature[<span class="number">0</span>, :, :], node_feature[<span class="number">0</span>, :, :])</span><br></pre></td></tr></tbody></table></figure>

<p><img src="../../../../picture/image-20210621114008066.png" alt="image-20210621114008066"></p>
<h4 id="2-Graph-Classification"><a href="#2-Graph-Classification" class="headerlink" title=".2. Graph Classification"></a>.2. Graph Classification</h4><blockquote>
<p>一个graph数据对应一个Data， 可以将多个graph存储到一个data文件里面，也可以将每个graph存在对应单独的data文件里面。</p>
</blockquote>
<ul>
<li>multi-graph&amp;one data</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphDatasetInMem</span><span class="params">(InMemoryDataset)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Graph classification </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, transform=None, pre_transform=None)</span>:</span></span><br><span class="line">        super(GraphDatasetInMem, self).__init__(root,transform, pre_transform)</span><br><span class="line">        self.data, self.slices = torch.load(self.processed_paths[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">raw_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processed_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">r'.\GraphDatasetInMem.dataset'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self)</span>:</span></span><br><span class="line">        data_list = [] <span class="comment"># graph classification need to define data_list for multiple graph</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_graph):</span><br><span class="line">            source_nodes, target_nodes = np.nonzero(Adj[i, :, :])</span><br><span class="line">            source_nodes = source_nodes.reshape((<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">            target_nodes = target_nodes.reshape((<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">            edge_index = torch.tensor(np.concatenate((source_nodes, target_nodes), axis=<span class="number">0</span>), dtype=torch.long) <span class="comment"># edge_index should be long type</span></span><br><span class="line"></span><br><span class="line">            edge_weight = edge_feature[i, source_nodes, target_nodes]</span><br><span class="line">            edge_weight = torch.tensor(edge_weight.reshape((<span class="number">-1</span>, num_edge_features)), dtype=torch.float) <span class="comment"># edge_index should be float</span></span><br><span class="line">            type</span><br><span class="line"></span><br><span class="line">            x = torch.tensor(node_feature[i, :, :], dtype=torch.float) </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># y should be long type, graph label should not be a 0-dimesion tensor</span></span><br><span class="line">            <span class="comment"># use [graph_label[i]] ranther than graph_label[i]</span></span><br><span class="line">            y = torch.tensor([graph_label[i]], dtype=torch.long) </span><br><span class="line"></span><br><span class="line">            data = Data(x=x, edge_index=edge_index, y=y, edge_attr=edge_weight)</span><br><span class="line">            data_list.append(data)</span><br><span class="line">            </span><br><span class="line">        data, slices = self.collate(data_list) <span class="comment"># Here used to be [data] for one graph</span></span><br><span class="line">        torch.save((data, slices), self.processed_paths[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line"><span class="comment">#usage</span></span><br><span class="line">dataset_graph_InMem = GraphDatasetInMem(root=<span class="string">'./'</span>)</span><br><span class="line">print(dataset_graph_InMem[<span class="number">0</span>])</span><br><span class="line">print(dataset_graph_InMem[<span class="number">1</span>])</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="comment">#Data(edge_attr=[504, 1], edge_index=[2, 504], x=[50, 3], y=[1])</span></span><br><span class="line"><span class="comment">#Data(edge_attr=[495, 1], edge_index=[2, 495], x=[50, 3], y=[1])</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>one graph one pt file</li>
</ul>
<blockquote>
<p>区别在于：没有data, slices = self.collate(data_list) # Here used to be [data] for one graph，但是有以下函数：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        data = torch.load(osp.join(self.processed_dir, <span class="string">'graphDataset1_{}.pt'</span>.format(idx)))</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphDataset_1</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Graph classification </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, transform=None, pre_transform=None)</span>:</span></span><br><span class="line">        super(GraphDataset_1, self).__init__(root,transform, pre_transform)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">raw_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processed_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">r'.\GraphDataset1_0.pt'</span>, <span class="string">r'.\GraphDataset1_1.pt'</span>, <span class="string">r'.\GraphDataset1_2.pt'</span>, <span class="string">r'.\GraphDataset1_3.pt'</span>, <span class="string">r'.\GraphDataset1_4.pt'</span>, <span class="string">r'.\GraphDataset1_5.pt'</span>, <span class="string">r'.\GraphDataset1_6.pt'</span>, <span class="string">r'.\GraphDataset1_7.pt'</span>, <span class="string">r'.\GraphDataset1_8.pt'</span>, <span class="string">r'.\GraphDataset1_9.pt'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#data_list = [] # graph classification need to define data_list for multiple graph</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_graph):</span><br><span class="line">            source_nodes, target_nodes = np.nonzero(Adj[i, :, :])</span><br><span class="line">            source_nodes = source_nodes.reshape((<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">            target_nodes = target_nodes.reshape((<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">            edge_index = torch.tensor(np.concatenate((source_nodes, target_nodes), axis=<span class="number">0</span>), dtype=torch.long) <span class="comment"># edge_index should be long type</span></span><br><span class="line"></span><br><span class="line">            edge_weight = edge_feature[i, source_nodes, target_nodes]</span><br><span class="line">            edge_weight = torch.tensor(edge_weight.reshape((<span class="number">-1</span>, num_edge_features)), dtype=torch.float) <span class="comment"># edge_index should be float</span></span><br><span class="line">            type</span><br><span class="line"></span><br><span class="line">            x = torch.tensor(node_feature[i, :, :], dtype=torch.float) </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># y should be long type, graph label should not be a 0-dimesion tensor</span></span><br><span class="line">            <span class="comment"># use [graph_label[i]] ranther than graph_label[i]</span></span><br><span class="line">            y = torch.tensor([graph_label[i]], dtype=torch.long) </span><br><span class="line"></span><br><span class="line">            data = Data(x=x, edge_index=edge_index, y=y, edge_attr=edge_weight)</span><br><span class="line">            <span class="comment">#data_list.append(data)</span></span><br><span class="line">            <span class="comment"># save one graph per time</span></span><br><span class="line">            torch.save(data, osp.join(self.processed_dir, <span class="string">'graphDataset1_{}.pt'</span>.format(i)))</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">len</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.processed_file_names)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        data = torch.load(osp.join(self.processed_dir, <span class="string">'graphDataset1_{}.pt'</span>.format(idx)))</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># usage</span></span><br><span class="line">dataset_graph_1 = GraphDataset_1(root=<span class="string">'./'</span>)</span><br><span class="line">print(dataset_graph_1[<span class="number">0</span>])</span><br><span class="line">print(dataset_graph_1[<span class="number">1</span>])</span><br><span class="line"><span class="comment">#Data(edge_attr=[504, 1], edge_index=[2, 504], x=[50, 3], y=[1])</span></span><br><span class="line"><span class="comment">#Data(edge_attr=[495, 1], edge_index=[2, 495], x=[50, 3], y=[1])</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-Node-Classification"><a href="#3-Node-Classification" class="headerlink" title=".3. Node Classification"></a>.3. Node Classification</h4><ul>
<li>in on graph</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeDatasetInMem</span><span class="params">(InMemoryDataset)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    node classification in one graph</span></span><br><span class="line"><span class="string">    Should define the mask for training, validation and test</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, num_train_per_class=<span class="number">15</span>, num_val=<span class="number">10</span>, num_test=<span class="number">10</span>, transform=None, pre_transform=None)</span>:</span></span><br><span class="line">        self.num_train_per_class = num_train_per_class</span><br><span class="line">        self.num_val = num_val</span><br><span class="line">        self.num_test = num_test</span><br><span class="line">        super(NodeDatasetInMem, self).__init__(root,transform, pre_transform)</span><br><span class="line">        self.data, self.slices = torch.load(self.processed_paths[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">raw_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processed_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">r'.\NodeDatasetInMem.dataset'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self)</span>:</span></span><br><span class="line">        num_train_per_class = self.num_train_per_class</span><br><span class="line">        num_val = self.num_val</span><br><span class="line">        num_test = self.num_test</span><br><span class="line">        <span class="comment">#data_list = []  # node classification do not neet to define data_list just data (one graph)</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        source_nodes, target_nodes = np.nonzero(Adj[i, :, :])</span><br><span class="line">        source_nodes = source_nodes.reshape((<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">        target_nodes = target_nodes.reshape((<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        edge_index = torch.tensor(np.concatenate((source_nodes, target_nodes), axis=<span class="number">0</span>), dtype=torch.long) <span class="comment"># edge_index should be long type</span></span><br><span class="line"></span><br><span class="line">        edge_weight = edge_feature[i, source_nodes, target_nodes]</span><br><span class="line">        edge_weight = torch.tensor(edge_weight.reshape((<span class="number">-1</span>, num_edge_features)), dtype=torch.float) <span class="comment"># edge_index should be float</span></span><br><span class="line">        type</span><br><span class="line">        train_mask = np.zeros((num_node,), dtype=bool)</span><br><span class="line">        val_mask = np.zeros((num_node,), dtype=bool)</span><br><span class="line">        test_mask = np.zeros((num_node,), dtype=bool)</span><br><span class="line"></span><br><span class="line">        label = node_label[i, :]</span><br><span class="line">        [org_class_0_ind] =  np.nonzero(label == <span class="number">0</span>) </span><br><span class="line">        org_class_0_ind = org_class_0_ind.reshape(<span class="number">-1</span>)</span><br><span class="line">        perm_class_0_ind = org_class_0_ind[np.random.permutation(org_class_0_ind.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">        [org_class_1_ind] =  np.nonzero(label == <span class="number">1</span>) </span><br><span class="line">        org_class_1_ind = org_class_1_ind.reshape(<span class="number">-1</span>)</span><br><span class="line">        perm_class_1_ind = org_class_1_ind[np.random.permutation(org_class_1_ind.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        train_ind = np.concatenate((perm_class_0_ind[:num_train_per_class], perm_class_1_ind[:num_train_per_class]), axis=<span class="number">0</span>)</span><br><span class="line">        train_mask[train_ind] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        [remaining] = np.nonzero(~train_mask)</span><br><span class="line">        remaining = remaining.reshape(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        val_mask[remaining[:num_val]] = <span class="literal">True</span></span><br><span class="line">        test_mask[remaining[num_val:num_val+num_test]] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        train_mask = torch.tensor(train_mask, dtype=torch.bool) <span class="comment"># mask should be long type</span></span><br><span class="line">        val_mask = torch.tensor(val_mask, dtype=torch.bool)</span><br><span class="line">        test_mask = torch.tensor(test_mask, dtype=torch.bool)</span><br><span class="line"></span><br><span class="line">        x = torch.tensor(node_feature[i, :, :], dtype=torch.float) </span><br><span class="line">        y = torch.tensor(node_label[i, :], dtype=torch.long) <span class="comment"># y should be long type</span></span><br><span class="line"></span><br><span class="line">        data = Data(x=x, edge_index=edge_index, y=y, edge_attr=edge_weight, train_mask = train_mask, val_mask = val_mask, test_mask = test_mask)</span><br><span class="line">            </span><br><span class="line">        data, slices = self.collate([data])</span><br><span class="line">        torch.save((data, slices), self.processed_paths[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line"> <span class="comment">#output</span></span><br><span class="line">dataset_node_InMem = NodeDatasetInMem(root=<span class="string">'./'</span>)</span><br><span class="line">print(dataset_node_InMem[<span class="number">0</span>].y)</span><br><span class="line">print(dataset_node_InMem[<span class="number">0</span>].y.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">#tensor([1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1,0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1,1, 1])</span></span><br><span class="line"><span class="comment">#torch.Size([50])</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    node classification in one graph</span></span><br><span class="line"><span class="string">    Should define the mask for training, validation and test</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, num_train_per_class=<span class="number">15</span>, num_val=<span class="number">10</span>, num_test=<span class="number">10</span>, transform=None, pre_transform=None)</span>:</span></span><br><span class="line">        self.num_train_per_class = num_train_per_class</span><br><span class="line">        self.num_val = num_val</span><br><span class="line">        self.num_test = num_test</span><br><span class="line">        super(NodeDataset, self).__init__(root,transform, pre_transform)</span><br><span class="line">        <span class="comment"># Do not load the data and slices here</span></span><br><span class="line">        <span class="comment">#self.data, self.slices = torch.load(self.processed_paths[0])</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">raw_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processed_file_names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">r'./NodeDataset_0.pt'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self)</span>:</span></span><br><span class="line">        num_train_per_class = self.num_train_per_class</span><br><span class="line">        num_val = self.num_val</span><br><span class="line">        num_test = self.num_test</span><br><span class="line">        <span class="comment">#data_list = []  # node classification do not neet to define data_list just data (one graph)</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        source_nodes, target_nodes = np.nonzero(Adj[i, :, :])</span><br><span class="line">        source_nodes = source_nodes.reshape((<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">        target_nodes = target_nodes.reshape((<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        edge_index = torch.tensor(np.concatenate((source_nodes, target_nodes), axis=<span class="number">0</span>), dtype=torch.long) <span class="comment"># edge_index should be long type</span></span><br><span class="line"></span><br><span class="line">        edge_weight = edge_feature[i, source_nodes, target_nodes]</span><br><span class="line">        edge_weight = torch.tensor(edge_weight.reshape((<span class="number">-1</span>, num_edge_features)), dtype=torch.float) <span class="comment"># edge_index should be float</span></span><br><span class="line">        type</span><br><span class="line">        train_mask = np.zeros((num_node,), dtype=bool)</span><br><span class="line">        val_mask = np.zeros((num_node,), dtype=bool)</span><br><span class="line">        test_mask = np.zeros((num_node,), dtype=bool)</span><br><span class="line"></span><br><span class="line">        label = node_label[i, :]</span><br><span class="line">        [org_class_0_ind] =  np.nonzero(label == <span class="number">0</span>) </span><br><span class="line">        org_class_0_ind = org_class_0_ind.reshape(<span class="number">-1</span>)</span><br><span class="line">        perm_class_0_ind = org_class_0_ind[np.random.permutation(org_class_0_ind.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">        [org_class_1_ind] =  np.nonzero(label == <span class="number">1</span>) </span><br><span class="line">        org_class_1_ind = org_class_1_ind.reshape(<span class="number">-1</span>)</span><br><span class="line">        perm_class_1_ind = org_class_1_ind[np.random.permutation(org_class_1_ind.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        train_ind = np.concatenate((perm_class_0_ind[:num_train_per_class], perm_class_1_ind[:num_train_per_class]), axis=<span class="number">0</span>)</span><br><span class="line">        train_mask[train_ind] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        [remaining] = np.nonzero(~train_mask)</span><br><span class="line">        remaining = remaining.reshape(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        val_mask[remaining[:num_val]] = <span class="literal">True</span></span><br><span class="line">        test_mask[remaining[num_val:num_val+num_test]] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        train_mask = torch.tensor(train_mask, dtype=torch.bool) <span class="comment"># mask should be long type</span></span><br><span class="line">        val_mask = torch.tensor(val_mask, dtype=torch.bool)</span><br><span class="line">        test_mask = torch.tensor(test_mask, dtype=torch.bool)</span><br><span class="line"></span><br><span class="line">        x = torch.tensor(node_feature[i, :, :], dtype=torch.float) </span><br><span class="line">        y = torch.tensor(node_label[i, :], dtype=torch.long) <span class="comment"># y should be long type</span></span><br><span class="line"></span><br><span class="line">        data = Data(x=x, edge_index=edge_index, y=y, edge_attr=edge_weight, train_mask = train_mask, val_mask = val_mask, test_mask = test_mask)</span><br><span class="line">        <span class="comment"># Directly save the data in order as .pt form</span></span><br><span class="line">        torch.save(data, osp.join(self.processed_dir, <span class="string">'NodeDataset_{}.pt'</span>.format(i)))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">len</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.processed_file_names)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        data = torch.load(osp.join(self.processed_dir, <span class="string">'NodeDataset_{}.pt'</span>.format(idx)))</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">   <span class="comment">#</span></span><br><span class="line">dataset_node = NodeDataset(root=<span class="string">'./'</span>)</span><br><span class="line">dataset_node[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#Data(edge_attr=[504, 1], edge_index=[2, 504], test_mask=[50], train_mask=[50], val_mask=[50], x=[50, 3], y=[50])</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Resouce"><a href="#Resouce" class="headerlink" title="Resouce"></a>Resouce</h3><ul>
<li><a href="https://github.com/rusty1s/pytorch_geometric" target="_blank" rel="noopener">pytorch_geometric11.3k </a> <a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/colabs.html" target="_blank" rel="noopener">pytorch_geometric11.3k_demo</a></li>
<li><a href="https://github.com/benedekrozemberczki/pytorch_geometric_temporal" target="_blank" rel="noopener">pytorch_geometric_temporal</a>  : A Temporal Extension Library for PyTorch Geometric</li>
<li><a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/introduction.html" target="_blank" rel="noopener">https://pytorch-geometric.readthedocs.io/en/latest/notes/introduction.html</a></li>
<li><a href="https://colab.research.google.com/drive/1h3-vJGRVloF5zStxL5I0rSy4ZUPNsjy8?usp=sharing" target="_blank" rel="noopener">Introduction: Hands-on Graph Neural Networks</a></li>
<li><a href="https://colab.research.google.com/drive/14OvFnAXggxB8vM4e8vSURUp1TaKnovzX?usp=sharing" target="_blank" rel="noopener">Node Classification with Graph Neural Networks</a></li>
<li><a href="https://colab.research.google.com/drive/1I8a0DfQ3fI7Njc62__mVXUlcAleUclnb?usp=sharing" target="_blank" rel="noopener">Graph Classification with Graph Neural Networks</a></li>
<li><a href="https://colab.research.google.com/drive/1XAjcjRHrSR_ypCk_feIWFbcBKyT4Lirs?usp=sharing" target="_blank" rel="noopener">Scaling Graph Neural Networks</a></li>
<li><a href="https://colab.research.google.com/drive/1D45E5bUK3gQ40YpZo65ozs7hg5l-eo_U?usp=sharing" target="_blank" rel="noopener">Point Cloud Classification with Graph Neural Networks</a></li>
<li><a href="https://colab.research.google.com/drive/1fLJbFPz0yMCQg81DdCP5I8jXw9LoggKO?usp=sharing" target="_blank" rel="noopener">Explaining GNN Model Predictions using Captum</a></li>
<li><a href="http://htmlpreview.github.io/?https://github.com/rusty1s/rusty1s.github.io/blob/master/pyg_notebook.html" target="_blank" rel="noopener">Fast Graph Representation</a></li>
<li><a href="https://github.com/GQ93/Pytorch-geometric-notes/blob/master/costumed_graph_datasets.ipynb" target="_blank" rel="noopener">custom dataset</a> </li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://liudongdong1.github.io" rel="external nofollow noreferrer">liudongdong1</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://liudongdong1.github.io/2021/06/14/shi-kong-shu-ju/gnn/pytorchgnn/">https://liudongdong1.github.io/2021/06/14/shi-kong-shu-ju/gnn/pytorchgnn/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="https://liudongdong1.github.io" target="_blank">liudongdong1</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/pytorch/">
                                    <span class="chip bg-color">pytorch</span>
                                </a>
                            
                                <a href="/tags/GNN/">
                                    <span class="chip bg-color">GNN</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2021/06/14/shi-kong-shu-ju/gnn/pytorch3d/">
                    <div class="card-image">
                        
                        <img src="https://cdn.pixabay.com/photo/2021/03/19/04/49/kid-6106557__340.jpg" class="responsive-img" alt="Pytorch3D">
                        
                        <span class="card-title">Pytorch3D</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
Chaton, Thomas, et al. “Torch-Points3D: A Modular Multi-Task Frameworkfor Reproducible Deep Learning on 3D Point Clouds
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-06-14
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%97%B6%E7%A9%BA%E6%95%B0%E6%8D%AE/" class="post-category">
                                    时空数据
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/pytorch/">
                        <span class="chip bg-color">pytorch</span>
                    </a>
                    
                    <a href="/tags/GNN/">
                        <span class="chip bg-color">GNN</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/06/14/yu-yan-kuang-jia/ke-shi-hua/frfntptn/">
                    <div class="card-image">
                        
                        <img src="https://cdn.stocksnap.io/img-thumbs/280h/UELPTNOKP4.jpg" class="responsive-img" alt="FRFNTPTN">
                        
                        <span class="card-title">FRFNTPTN</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            0. python统计函数123456789101112131415161718192021222324import numpy as nplayerData = np.loadtxt(open('./data/layer_test_acc
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-06-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AF%AD%E8%A8%80%E6%A1%86%E6%9E%B6/" class="post-category">
                                    语言框架
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/visual/">
                        <span class="chip bg-color">visual</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <!-- <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="463294659"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://liudongdong1.github.io" target="_blank">liudongdong</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">1206.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/liudongdong1/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:3463264078@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>














    <a href="https://blog.csdn.net/liudongdong19/" class="tooltipped" target="_blank" data-tooltip="关注我的CSDN: https://blog.csdn.net/liudongdong19/" data-position="top" data-delay="50">
        <i class="fab fa-csdn">C</i>
    </a>





</div>
    </div>
</footer>

<div class="progress-bar"></div>
 -->

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script type="text/javascript" src="/js/CFS.Snow.min.js"></script>
    <!-- 点击爆灯效果 -->
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <!--动态线条背景-->
    <script type="text/javascript"
        color="122 103 238" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
    </script>
    <!-- 天气 -->
    <!-- weather -->
    <!-- weather -->
    <script type="text/javascript">
         WIDGET = {FID: 'knAMQaFanP'}
    </script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>
    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
    <!-- {% include '_custom/custom.swig' %} -->

</body>

</html>
