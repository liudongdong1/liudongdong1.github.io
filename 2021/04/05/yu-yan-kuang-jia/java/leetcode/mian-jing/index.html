<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="面经, AIOT,Space&amp;Temporal Sequence Analysis,SpringBoot,liudongdong1,cloud">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>面经 | DaybyDay</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="DaybyDay" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">DaybyDay</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">

      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/about">
          
          <i class="fas fa-user-circle" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>about</span>
        </a>
      </li>
      
      <li>
        <a href="/resume">
          
          <i class="fa fa-user-secret" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>resume</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/gallery" class="waves-effect waves-light">
      
      <i class="fas fa-camera" style="zoom: 0.6;"></i>
      
      <span>Galleries</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">DaybyDay</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-user-circle"></i>
			
			About
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/about " style="margin-left:75px">
				  
				   <i class="fa fas fa-user-circle" style="position: absolute;left:50px" ></i>
			      
		          <span>about</span>
                  </a>
                </li>
              
                <li>

                  <a href="/resume " style="margin-left:75px">
				  
				   <i class="fa fa fa-user-secret" style="position: absolute;left:50px" ></i>
			      
		          <span>resume</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/gallery" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-camera"></i>
			
			Galleries
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/liudongdong1" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/liudongdong1" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.pixabay.com/photo/2022/01/19/08/32/melons-6949139__340.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">面经</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    .toc-fixed .toc-link::before{
        position: fixed!important;/*当toc的位置改为fixed时，.toc-link::before也要改为fixed*/
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/skill/">
                                <span class="chip bg-color">skill</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%94%9F%E6%B4%BB/" class="post-category">
                                生活
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2021-04-05
                </div>
                

                <!-- 
                    <i class="fa fa-pencil"></i> Author: liudongdong1
                  -->

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2022-03-20
                </div>
                

                <!-- 
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    64k
                </div>
                 -->

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    227 Min
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p>面试记得，一定要敏锐察觉出面试官的问题点，知道他想要的答案。而后在讲一些扩展，这些扩展如果他有兴趣，那就对你很有帮助了。不知道的东西也可以猜一下，表现出自己的思考能力，别只说不会。</p>
</blockquote>
<h3 id="0-在投简历"><a href="#0-在投简历" class="headerlink" title="0. 在投简历"></a>0. 在投简历</h3><ul>
<li>特斯拉软件开发工程师（上海）：<a href="https://app.mokahr.com/campus-recruitment/tesla/41460#/job/abba8d88-606e-437a-b56f-e3b130180915" target="_blank" rel="noopener">https://app.mokahr.com/campus-recruitment/tesla/41460#/job/abba8d88-606e-437a-b56f-e3b130180915</a>   <code>2.28；已经投递</code></li>
<li>哔哩哔哩开发工程师：<a href="https://jobs.bilibili.com/campus/positions/3226?token=311ae69f-15ac-4369-b4fd-359f6de3e5f7" target="_blank" rel="noopener">https://jobs.bilibili.com/campus/positions/3226?token=311ae69f-15ac-4369-b4fd-359f6de3e5f7</a>  </li>
<li>华为云核心产品线：</li>
<li><a href="https://www.shixiseng.com/intern/inn_xxjkunw0exh9" target="_blank" rel="noopener">元象唯思</a>： 开发实习生 - 交互式多媒体 SDK，截止日期：2022-05-31</li>
<li>蔚来自动驾驶方向感知组：</li>
<li>微众银行</li>
<li>美团：后端开发，基础平台研发； <a href="https://campus.meituan.com/resume-edit?jobId=4593&amp;jobType=2" target="_blank" rel="noopener">https://campus.meituan.com/resume-edit?jobId=4593&amp;jobType=2</a></li>
<li><a href="https://www.shixiseng.com/intern/inn_x7yqh27zlicr?pcm=pc_SearchList" target="_blank" rel="noopener">美团视觉智能中心视觉算法实习生：</a> 6月1日前投递，300-400 / 天； <a href="https://www.shixiseng.com/intern/inn_kzqqp18kj8nd" target="_blank" rel="noopener">美团Java 开发实习生</a>： 截止时间，3-4日， 250-300/天； <a href="https://www.shixiseng.com/intern/inn_lktuvdejz1en" target="_blank" rel="noopener">Java 实习生（增长工程）</a>，</li>
<li>华为<ul>
<li><a href="https://www.shixiseng.com/intern/inn_imxposunauaw?pcm=pc_SearchList" target="_blank" rel="noopener">软件开发工程师实习</a>，截止日期：2022-08-31； 300-500 / 天</li>
<li>华为是全球领先的ICT基础设施和智能终端提供商： <a href="https://www.shixiseng.com/intern/inn_ubzikttgk4do?pcm=pc_SearchList" target="_blank" rel="noopener">软件开发工程师</a>，2022-03-01， 200-400元   <code>2.28；已经投递</code></li>
<li>华为云核心网产品线: </li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDY1NDU1OA==&amp;mid=2247489439&amp;idx=2&amp;sn=fc51b6d6231619882021769bd68b418b&amp;chksm=cfb5bf2ef8c2363884825ce44deaffd7c2e9093cf397dd351b15406f1b456d1bb2d0bc3a49f1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">华为云 Edge AI 团队</a>： <strong>边缘云 AI 系统研发工程师</strong> 计划投递</li>
<li>华为诺亚方舟实验室:  实习期大于6个月，</li>
</ul>
</li>
<li><strong><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDY1NDU1OA==&amp;mid=2247489818&amp;idx=2&amp;sn=0b7d55615bc676a5d46a2c2afb3678ee&amp;chksm=cfb5b1abf8c238bdef46cbd34b759bd93b6604b11849c2d7d7ceab5eec5e5a8a90a0a2267aa7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">阿里巴巴达摩院 XR 实验室</a></strong>:   计划投递</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDY1NDU1OA==&amp;mid=2247489641&amp;idx=2&amp;sn=0b5c267a2f18fb5c12321b609d7d9468&amp;chksm=cfb5b0d8f8c239ce4f7085375a777b39a21cd452161d49d665f941fcd8b7db9bff1fd5a983e0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">腾讯优图</a>： 计划投递</li>
<li>阿里云洛神云网络：<a href="https://www.nowcoder.com/discuss/846246?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/846246?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</a>  《C++ primer》《STL 源码》</li>
</ul>
<blockquote>
<p>​        尊敬的 HR，您好，在 AI 求职上看到机器人视觉算法实习生的相关介绍，和我研究生所做的工作很相近，不知道是否错过了实习招聘的时间，仍然想试一试。在此，我占用您一点时间，简单介绍下自己：在学习方面，我对知识有一种渴望，会主动的涉猎多方面的知识，复盘总结，研究生在实验室打卡时长基本在前 5 左右；在思维方面，在导师的指导下，注重逻辑思维的培养，自己也阅读麦肯锡系列书籍，侧重问题的发现和解决；在实战方面，能够以最短的时间快速入门所需要技术，在开发的过程中会定期回顾整理代码，了解一些技术细节，辅助后续开发，自己使用过 YOLO5 算法进行自己采集的夹子数据集检测，使用 PyTorch 构建过简单模型，并能够复现调试论文中的模型。</p>
<p>   非常感谢，占用您一些时间啦～</p>
</blockquote>
<p><img src="../../../../../picture2022/image-20220308204923550.png" alt=""></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDY1NDU1OA==&amp;mid=2247489187&amp;idx=2&amp;sn=850a8360938561208cbb5e3c92cb40c0&amp;chksm=cfb5be12f8c23704d368fa1502bbbf5c540ef51ef1c7e85e944bcce3be67d33c771c407647bf&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">商汤科技研究院</a>： 计划投递</li>
<li>微软 <a href="https://careers.microsoft.com/us/en/applythankyou?jobSeqNo=1216734" target="_blank" rel="noopener">Software Engineer-C+AI/CMD/STCA-2020</a> 实习已经投递，3月1日。<a href="https://recruit.microsoft.com/actioncenter/submitted" target="_blank" rel="noopener">状态</a>  google邮箱</li>
<li>第四范式：<ul>
<li>企业级人工智能领域的行业先驱者与领导者。第四范式提供以平台为中心的人工智能解决方案，并运用核心技术开发了端到端的企业级人工智能产</li>
<li><a href="https://www.shixiseng.com/intern/inn_h0bo2uidaiam" target="_blank" rel="noopener">后端研发实习生</a>： 300-400 / 天 北京 本科 5 天／周 实习 3 个月  <a href="https://www.nowcoder.com/jobs/intern/detail?jobId=87829&amp;logid=9b7c14538700ffe22150f0bb7029d004" target="_blank" rel="noopener">已经投递 3月8日</a></li>
</ul>
</li>
<li><a href="https://posts.careerengine.us/p/61a8a3e308f8a11561082367" target="_blank" rel="noopener"><strong>贝壳人工智能技术中心</strong>：</a> <strong>机器人视觉算法实习生</strong>， <code>2.28；简历已经投递</code></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDY1NDU1OA==&amp;mid=2247487860&amp;idx=2&amp;sn=4226465e561d272e7f603d1b6d001a58&amp;chksm=cfb5b9c5f8c230d3b7d3b1c2bcfbe826c146c11331ebec3fc8117bce3d82c809c6e82614140c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">华为诺亚方舟实验室智能工业视觉组</a></li>
<li><a href="https://acm.nowcoder.com/discuss/735528?channel=-1&amp;source_id=discuss_terminal_discuss_sim_nctrack&amp;ncTraceId=35482d2ebd5a49cba12f6ec8d29fca94.185.16340665263575231" target="_blank" rel="noopener">贝壳 NLP 算法实习生</a>: 邮箱: <a href="mailto:49617631@qq.com">49617631@qq.com</a>; 微信: Magic_Nihao</li>
</ul>
<h3 id="1-准备问题"><a href="#1-准备问题" class="headerlink" title="1. 准备问题"></a>1. 准备问题</h3><ul>
<li>需要加强什么技术</li>
<li>技术栈是什么 </li>
<li>后面还有几面</li>
<li>你们为什么喜欢在这工作？</li>
<li>我表现哪些地方不太好？ (面试官说要把项目为什么这样做想清楚 不要只会这个技术 想清楚自己业务的难点在哪里 为什么这么做)</li>
<li>从技术氛围，职业发展，公司潜力等</li>
</ul>
<h3 id="2-项目"><a href="#2-项目" class="headerlink" title="2. 项目"></a>2. 项目</h3><h4 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title=".1. 自我介绍"></a>.1. 自我介绍</h4><blockquote>
<ul>
<li>7 年 Java 开发经验，5 年互联网行业经验，自认达到高级工程师的水平，希望以后能成长为架构师。（<strong>有目标、规划</strong>）</li>
<li>敏建开发的忠实粉丝，单元测试驱动开发的实践者，会主动重构代码，有代码洁癖。（<strong>有良好的编码习惯</strong>）</li>
<li>爱看技术书籍，一年看 10 本书左右，最近在看《领域驱动设计》、《企业应用架构模式》；爱学习，今年已经在极客时间上完成 5 门付费课程。(<strong>爱看书、学习</strong>)</li>
<li>2 年团队管理经验，团队规模 15 人，团队气氛和谐，成员离职率远低于公司平均水平。曾被评选为公司优秀团队。（<strong>团队带的还不错</strong>）</li>
</ul>
</blockquote>
<blockquote>
<p>技能水平：要写出具体的技术或者框架</p>
</blockquote>
<ul>
<li>自我介绍（中英文）：社团活动，比赛经历  （一分钟，三分钟各一个）</li>
</ul>
<blockquote>
<p>  您好，我叫刘冬冬，很荣幸能够参加此次面试。我本科毕业于吉林大学物联网专业，以专业第三的成绩保研至天津大学未来网络实验室，预计2022年12月毕业。目的是想通过暑期实习表现顺利转正。接下来我将从以下四个方面来介绍自己：</p>
<ol>
<li><p>学习能力：比较踏实，积极进去。四级573分，六级551分。大二时进入初剑锋老师所在团队进行室内定位与导航系统开发，发表发明专利一篇，包括课程设计在内软著10篇。确定保研后，于大四上进入天津大学tanklab实验室进行学习，喜欢看技术类文章，例如博客网站和订阅的公众号等，有代码洁癖，写完工程代码后喜欢回顾代码，进行简单优化，平时定期复盘总结，上传GitHub，个人CSDN博客访问量218万＋，后来迁移到基于Hexo框架搭建的个人博客。</p>
</li>
<li><p>规划方面：目标比较明确，本科阶段为了全方面了解物联网技术栈，学习了从操作系统到无线有线网络，从数据处理（数据库存储，消息队列，AI网络）到java web显示，形成自己的知识体系；为了提高科研能力，跟随刚从国外回来的CCF 优博刘秀龙教授进行学习，第一份工作发表在ACM MobiCom21上，第二份工作荣获C4网络技术挑战赛全国一等奖等；为了提高自己的社交、组织能力和服务意识，担任实验室纵向党支部书记。</p>
</li>
<li><p>优势方面：动手能力比较强，本科云计算课程93分，IBMWebshere认证课程97分，研究生大数据综合实验课程96分，了解hadoop,spark基本使用，部署过简单的kafka应用，以及编写过简单的dockerfile文件。自己也购买了树莓派，做了基于flask框架的小车，搭载了一个摄像头，实现基本前进后退拐弯，可以通过网页端进行控制，还利用多余的机械硬盘，利用树莓派搭建了NAS系统，以及哔哩哔哩上前年比较火的自美智能魔镜系统。</p>
</li>
<li><p>生活方面：不怕吃苦，感恩生活，小时候在田里干农活比较多，所以对自己现在的状态很珍惜，喜欢摄影，游泳，网球，羽毛球等体育活动。  </p>
<p>我非常希望能够成为阿里云服务器团队中的一员，如果能够给我这个工作机会，我有信心，也有决心做好这份工作，以上是我的个人基本情况，希望今天自己面试有好的表现，未来有幸与诸位面试官共事。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>Hello, my name is Liu Dongdong. I graduated from the Internet of things major of Jilin University as a bachelor. I am expected to graduate in December 2022 from Tianjin University. The position applied for this time is the internship of C + + R &amp; D Engineer in Alibaba cloud’s native department. The purpose is to smoothly become a regular through internship performance. Next, I will introduce myself from the following three aspects:</p>
<ol>
<li><p>Learning ability: down-to-earth and enterprising. When I was a sophomore, I entered the team of teacher Chu Jianfeng to develop the indoor positioning and navigation system, and published one invention patent and 10 soft copyright including curriculum design. After determining the guarantee research, i entered the tanklab Laboratory of Tianjin University in my senior year to study. I likes to read technical articles, review and summarize regularly, and  record them in the form of blog.</p>
</li>
<li><p>Planning: in order to fully understand the IOT technology stack, I learned  the operating system、 wireless wired network、data processing (database storage, message queue, AI network) and Java Web, forming my own knowledge system; In order to improve scientific research ability, follow Professor Liu xiulong of CCF Youbo who has just returned from abroad to study; In order to improve my social skill, organizational and service awareness, i served as branch secretary.</p>
</li>
<li><p>Life: a wide range of hobbies, like tennis, badminton, swimming, photography.</p>
</li>
</ol>
</blockquote>
<h4 id="2-项目介绍："><a href="#2-项目介绍：" class="headerlink" title="2. 项目介绍："></a>2. 项目介绍：</h4><h5 id="0-项目中相关知识点"><a href="#0-项目中相关知识点" class="headerlink" title=".0. 项目中相关知识点"></a>.0. 项目中相关知识点</h5><h6 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1. 消息队列"></a>1. 消息队列</h6><blockquote>
<ul>
<li>中间件模式：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改。<code>系统的解耦</code></li>
<li><code>异步</code>：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</li>
<li><code>削峰</code>：系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。</li>
<li>系统的可用性降低（如果消息队列出毛病，系统将故障）</li>
<li>系统复杂性增加：一致性问题，如何保证数据不被重复消费，如何保证数据的可靠传输，数据传输的顺序</li>
</ul>
</blockquote>
<ul>
<li><p>kafka部署及相关消息队列：RocketMQ(阿里)，（Producer，Consumer，Topics），RestAPI(request, response), Publish/Subscribe, Netty</p>
<ul>
<li>典型的 Kafka 体系架构包括若干 Producer（消息生产者），若干 broker（作为 Kafka 节点的服务器），若干 Consumer（Group），以及一个 ZooKeeper 集群。Kafka通过 ZooKeeper 管理集群配置、选举 Leader 以及在 consumer group 发生变化时进行 Rebalance（即消费者负载均衡，在下一课介绍）。Producer 使用 push（推）模式将消息发布到 broker，Consumer 使用 pull（拉）模式从 broker 订阅并消费消息。</li>
<li>ZooKeeper是一个<code>分布式的、开放源码的分布式协调服务</code>,<code>配置维护、域名服务、分布式同步、组服务等</code>。</li>
</ul>
</li>
<li><p>进程通信方式</p>
<ul>
<li>基于内存方式：匿名管道，信息量，消息队列，共享内存</li>
<li>基于磁盘的方式：文件，命名管道</li>
<li>基于网络的方式：socket，消息队列，RPC，Netty，HTTP各种协议</li>
</ul>
</li>
<li><p>进程调度算法：先到先服务，短作业优先服务，时间片轮转调度，多级反馈队列调度，优先级调度</p>
</li>
<li><p>设计模式：单例模式（双重校验锁，内部类），适配器模式（filter, 匹配算法），Delegation（委派模式，DispatchServlet），观察者模式（消息队列，消息变化时候通知订阅者进行相关的操作）</p>
</li>
<li><p>Springboot相关知识：</p>
</li>
<li><p>git工作模式：工作区，暂存区，本地仓库，远程仓库及之间数据变化的命令</p>
</li>
<li><p>docker：registries，docker host，docker client</p>
</li>
</ul>
<blockquote>
<p>镜像包含着容器运⾏时所需要的<code>代码以及其它组件</code>，它是⼀种<code>分层结构</code>，<code>每⼀层都是只读的</code>（read-only layers）。构建镜像时，会⼀层⼀层构建，前⼀层是后⼀层的基础。镜像的这种分层存储结构很适合镜像的复⽤以 及定制.</p>
<ul>
<li>所有的Docker镜像都起始于⼀个基础镜像层，当进⾏修改或增加新的内容时，就会在当前镜像层之上，创建新的容 器层。 容器在启动时会在镜像最外层上建⽴⼀层可读写的容器层（R/W），⽽镜像层是只读的（R/O） </li>
<li>为了实现数据持久化，使容器之间可以共享数据。可以<code>将容器内的⽬录，挂载到宿主机上或其他容器内</code>，实现同步 和共享的操作。即使<code>将容器删除，挂载到本地的数据卷也不会丢失</code>。</li>
<li>Docker 是一个<code>容器化平台</code>，它包装你所有开发环境依赖成一个整体，像一个容器。保证项目开发，如开发、测试、发布等各生产环节都可以<code>无缝工作在不同的平台</code><br>Docker 容器：<code>将一个软件包装在一个完整的文件系统中</code>，该文件系统包含运行所需的一切：代码，运行时，系统工具，系统库等。可以安装在服务器上的任何东西。</li>
<li>软件总是运行在相同的运行环境，无需考虑基础环境配置的改变。</li>
<li><strong>COPY</strong> 比 <strong>ADD</strong> 更直观易懂。 <strong>COPY</strong> 只是将本地文件拷入容器这么简单，而 <strong>ADD</strong> 有一些其它特性功能（诸如，本地归档解压和支持远程网址访问等）</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>初始，所有都有赖于 Dockerfile 配置文件。Dockerfile 配置文件就是创建 Docker image (映像) 的源代码。</li>
<li>一旦 Dockerfile 配置好了，就可以创建（build）并生成 ‘image（映像）’ ，’image’ 就是 Dockerfile 配置文件中 「源代码」的「编译」版本。</li>
<li>一旦有了 ‘image’ ，就可以在 registry（注册中心） 发布它。 ‘registry’ 类似 git 的资源库 – 你可以推送你的映像（image），也可取回库中的映像（image）。</li>
<li>之后，你就可以使用 image 去启动运行 ‘containers（容器）’。运行中的容器在许多方面，与虚拟机非常相似，但容器的运行不需要虚拟管理软件的运行。</li>
</ul>
</blockquote>
<blockquote>
<p>hypervisor – 虚拟管理层（程序）– 负责<code>创建客户虚拟机系统运行所需虚拟硬件环境</code>。它<code>监管客户虚拟操作系统的运行</code>，并<code>为客户系统提供必要的运行资源</code>，保证客户虚拟系统的运行。虚拟管理层（程序）驻留在<code>物理主机系统和虚拟客户</code>系统之间，为虚拟客户系统提供必要的虚拟服务。如何理解它，它侦听运行在虚拟机中的客户操作系统的操作并在主机操作系统中模拟客户操作系统所需硬件资源请求。满足客户机的运行需求。</p>
</blockquote>
<blockquote>
<ul>
<li>数据保存在容器中，当容器停止运行时，运行状态数据丢失！</li>
<li>数据保存在主机卷（Host Volume）中，当主机停机时，运行状态数据将无法访问</li>
<li>数据保存在网络文件系统卷中，数据访问不依赖容器的运行与主机的运行</li>
</ul>
</blockquote>
<ul>
<li><p>spark：</p>
<ul>
<li>HDFS: 1个master（NameNode）和N个slaves（DataNode);</li>
<li>RDD操作（创建，转化，行动操作），DataFrames </li>
<li>standalone模式，三个台式机，kaggle提供的音频数据集，包括来自多种物种的声音。其中数据集解压后，数据大小57.32G，pyspark.ml 库</li>
</ul>
</li>
<li><p>数据库：</p>
<ul>
<li>事务操作：原子性，一致性，隔离性（未提交读，提交读，可重复读，串行化），持久性</li>
<li>并发问题：脏读，丢失修改，不可重复读，幻读</li>
<li>JPA操作：JPARepository 简单查询接口，Pageable 分页查询，@Query注解进行自定义查询，Example实体查询</li>
</ul>
</li>
<li><p>linux基本命令：</p>
<ul>
<li>系统变缓慢或者突然变卡：Full GC次数过多， CPU过高，接口耗时、http请求过多，响应慢，死锁，某个线程进入waitting，sleep，wait时间过长</li>
<li>bin, etc, lib, home, dev, boot</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>CPU利用率</strong>显示的是<code>程序在运行期间实时占用的CPU百分比</code>；cpu使用率反映的是当前cpu的繁忙程度，忽高忽低的原因在于<code>占用cpu处理时间的进程可能处于io等待状态但却还未释放进入wait</code>。</p>
<ul>
<li>— <code>load average</code>后面的三个数分别是1分钟、5分钟、15分钟的负载情况。 指的是处于可运行状态和不可中断状态的平均进程数。数字越大，CPU负载越大。</li>
</ul>
<p><strong>CPU负载</strong>是指某段时间内<code>占用cpu时间的进程和等待cpu时间的进程数</code>，这里等待cpu时间的进程是指等待被唤醒的进程，不包括处于wait状态进程。</p>
<ul>
<li>磁盘读写请求过多</li>
<li>MySQL死锁或者查询返回慢</li>
<li>硬盘故障，读写请求获取不到资源</li>
</ul>
</blockquote>
<h5 id="1-3-2021-10-2021-基于Flex传感器的手语控制识别系统"><a href="#1-3-2021-10-2021-基于Flex传感器的手语控制识别系统" class="headerlink" title=".1. 3/2021-10/2021 基于Flex传感器的手语控制识别系统"></a>.1. 3/2021-10/2021 基于Flex传感器的手语控制识别系统</h5><ul>
<li>受疫情影响，大多数人也都带上了防护手套或者工作手套；由于遮挡等影响给交互识别带来了不便；为此设计了基于Flex 传感器的手势识别控制系统，我作为队长，负责了整个技术方案的指定和代码的编写，包括弯曲量化，跨源转化，智能识别三个方面。<ul>
<li>在弯曲量化：利用弯曲传感器电阻随着弯曲程度变化特性，采用python语言通过HC05蓝牙模块获取自主设计的开发板（组员设计的）获取传感器数据，并通过多项式回归得到电压和手指弯曲度之间的关系，并进行uhand开源机械手的控制。</li>
<li>跨源转化：利用medipipe AI模型识别人手图片关节点的3d坐标，计算手指的弯曲度，模拟不同手势的弯曲数据集</li>
<li>智能识别：利用pytorch模型，基于google mixer-MLP 网络模型设计实现了数字和字符手势的识别。</li>
</ul>
</li>
<li>成果：第一个版本：系统采用pyqt框架进行系统页面设计。后来迁移到手机端，进行android开发，学习了RxJava工具，在手机上实现蓝牙数据获取，边缘AI推理，以及时实数据波形显示和识别结果显示。荣获C4网络技术挑战赛华北赛区一等奖，技术A赛道全国一等奖，创业C赛道全国二等奖。</li>
<li>硬件设备问题，AI模型识别问题，代码调试（后来进行功能测试），不同手势有的很相近（电路板问题组员）</li>
</ul>
<h5 id="2-12-2019-6-2021-基于RFID和Kinect交互感知系统"><a href="#2-12-2019-6-2021-基于RFID和Kinect交互感知系统" class="headerlink" title=".2. 12/2019-6/2021 基于RFID和Kinect交互感知系统"></a>.2. 12/2019-6/2021 基于RFID和Kinect交互感知系统</h5><ul>
<li><p>人机交互在元宇宙时代具有重要的地位，本项目问题定义为：在布满感知设备的环境中，如何多人多物的情况下智能的识别用户是谁，他和哪个物品进行了交互，交互行为是什么？采用计算机视觉不能区分相似物品，RFID能识别物品的详细信息，但不能识别哪个用户拿的，为此本系统采用RFID和Kinect技术相结合的方式，采用多线程的方式，对每一个用户处理，并对共享变量进行加锁，防止数据错误。</p>
</li>
<li><p>在这个项目中，我负责整个系统代码开发，针对kinect2，和azure kinect俩个版本的代码，以及多次代码规范方面的重构，系统功能包括数据提取，手势识别，身份匹配，物品识别三个功能。</p>
<ul>
<li>数据采集部分：采用C#编写，WPF框架进行运行界面显示，采用async异步方式接受kinect设备数据，采用委托者模式进行事件的触发处理，设计状态机模型提取有效的行为数据，并截取对应的RFID数据。</li>
<li>手势识别部分：捕获人右手在3D空间中的行为轨迹，通过socket函数上传到由python语言编写的手势识别服务器，使用Ransac算法进行降维处理，输入到使用keras框架编写的卷积网络识别人的行为手势。（这里也用到使用电脑上字体进行生成，针对f，t等练笔设计关键点检测网络，识别关键点并通过二项式函数连接起来模拟数据集）</li>
<li>身份匹配：使用人体双肩和鼻子骨骼点进行3D坐标映射，截取人脸部区域位置，通过socket上传后台服务器进行识别，并返回结果。</li>
<li>物品识别：根据RFID相位传输理论模型，通过人手部到天线之间的距离计算理论相位，并利用DTW算法进行匹配，考虑到人手和标签存在一定的距离，通过空间枚举，利用最大似然法找到最佳匹配的标签。</li>
</ul>
</li>
<li><p>成果：系统代码一份，C4网络技术挑战赛华北赛区二等奖，挑战杯校级二等奖；发表CCF A 类顶级会议 MobiCom21一篇</p>
<blockquote>
<p><em>Xiulong Liu, Dongdong Liu, Jiuwu Zhang, Tao Gu, and Keqiu Li. 2021. RFID and camera fusion for recognition of human-object interactions.</em> <em>Proceedings of the 27th Annual International Conference on Mobile Computing and Networking**. Association for Computing Machinery, New York, NY, USA, 296–308.</em> </p>
</blockquote>
<ul>
<li>纯Aloha协议： <ul>
<li>任何一个站都可以在帧生成后立即发送（可能冲突），并通过信号的反馈检测信道以确定发送是否成功</li>
<li>如发送失败，则经随机延时后再发送</li>
</ul>
</li>
<li>分隙Aloha协议：<ul>
<li>分隙 ALOHA 是把<code>时间分成时隙（时间片）</code>，时隙的长度对应一帧的传输时间</li>
<li>新帧的产生是随机的，但分隙 ALOHA 不允许随机发送，凡帧的发送必须在时隙的起点</li>
<li>冲突只发生在时隙的起点，冲突发生时只浪费一个时隙，一旦某个站占用时隙并发送成功，则在该时隙内不会出现冲突</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-3-2019-8-2019-基于华为NBIoT的健身房管理系统"><a href="#3-3-2019-8-2019-基于华为NBIoT的健身房管理系统" class="headerlink" title=".3. 3/2019-8/2019 基于华为NBIoT的健身房管理系统"></a>.3. 3/2019-8/2019 基于华为NBIoT的健身房管理系统</h5><ul>
<li>使用springboot框架，NBIoT开发板和JY901传感器是实现健身房设备管理，以及训练次数计数管理系统，作为队长，负责任务的分配，以及基于springboot框架的web页面开发，部署在购买的阿里云服务器上，负责基本的设备管理，以及传感器数据的时实显示。数据是通过华为云MQTT消息队列功能pulish到https接受地址那。</li>
<li>荣获全国物联网东北赛区二等奖,  cortex,  arm</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220303112012092.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/fb069b682bb1e5dac99a0f8a4e03f3cf.png" alt=""></p>
<h5 id="4-9-2017-1-2019-吉林大学口腔医院室内实时多维定位与精准导航系统"><a href="#4-9-2017-1-2019-吉林大学口腔医院室内实时多维定位与精准导航系统" class="headerlink" title=".4. 9/2017-1/2019  吉林大学口腔医院室内实时多维定位与精准导航系统"></a>.4. 9/2017-1/2019  吉林大学口腔医院室内实时多维定位与精准导航系统</h5><ul>
<li>定位是一种基本的技术，精准的定位为导航提供了基础，同时也为基于地理位置的服务提供了保障，在本项目中，我主要负责定位这一部分，定位主要思想是采用地理指纹匹配的方法，离线将不同位置的信息存储到sqlite数据库中，包括三种型号特征：<ul>
<li>第一种：视觉图像匹配，学习slam定位与追踪原理，运行通orb-slam2代码，并迁移到android手机端，利用orb提取图像的特征信息，将图像和室内位置相关联，通过图像匹配找出室内对应的位置。</li>
<li>第二种：基于WiFi指纹匹配，离线采集室内不同位置点的WiFi 特征，包括wifi名称，RSSI信息，构建条线图特征进行匹配。</li>
<li>第三种：基于地磁指纹匹配：利用手机采集带定位区域内地磁序列，构建地磁指纹库，进行匹配。</li>
</ul>
</li>
<li>成果：包括课程设计在内软件著作权10项，专利一篇。</li>
</ul>
<h5 id="5-树莓派NAS-系统"><a href="#5-树莓派NAS-系统" class="headerlink" title=".5. 树莓派NAS 系统"></a>.5. 树莓派NAS 系统</h5><blockquote>
<p>网络附加存储（Network Attached Storage，NAS），是一种专门的<code>数据存储技术</code>的名称，它可以直接连接在电脑网络上面，对<code>异质网络</code>用户提供了<code>集中式数据访问服务</code>。</p>
<p>RAID 全称为独立磁盘冗余阵列 (Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。</p>
</blockquote>
<ul>
<li>采用开源项目， OpenMediaVault, mount 命令挂载硬盘</li>
<li><code>NTFS</code>：最早出现在 windowsNT 的日志文件系统，有<code>文件加密</code>（权限管理）、<code>磁盘文件压缩</code>（节省磁盘空间）、<code>目录索引</code>（方便快速查找）、支持长文件名（255 个字符）、<code>磁盘预警、大容量</code>（根据簇的不同最大容量可以达到 16~256TB，但存储文件过多，由于索引增多，文件碎片化可能会导致实际性能下降)、记录操作日志（数据安全）等特性</li>
<li><code>FAT32</code>：较早的文件系统类型，兼容性好，但是<code>最大仅支持 2TB 分区</code>，NT 内核仅限制为 32GB，<code>单个文件最大也仅 4GB</code></li>
<li><code>exFAT</code>：微软为了解决 FAT32 在大文件上表现不佳的问题，专门为闪存盘设计的文件系统类型。但是<code>由于没有 NTFS 的许多特性并不适合作为系统分区使用</code></li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220303112620734.png" alt=""></p>
<h5 id="6-树莓派自美系统"><a href="#6-树莓派自美系统" class="headerlink" title=".6. 树莓派自美系统"></a>.6. 树莓派自美系统</h5><h5 id="7-CompreFace开源项目"><a href="#7-CompreFace开源项目" class="headerlink" title=".7. CompreFace开源项目"></a>.7. CompreFace开源项目</h5><h3 id="4-面试注意"><a href="#4-面试注意" class="headerlink" title="4. 面试注意"></a>4. 面试注意</h3><ul>
<li>主动亮出自己的加分项，但不要说太全，如果面试官没有往下接，说明这个对方不care，说下去也没意义，反而让人觉得你是有备而来</li>
<li>想去更大的公司发展；公司方向调整，和个人的发展方向不符；公司把研发部门迁到其他城市。</li>
<li>公司加班的时长和频率，如果工作需要的合理加班，当然可以接受。如果公司以加班为荣，为了加班而加班，你为啥要接受？</li>
<li>不露痕迹的说面试官爱听的话<ul>
<li>能考虑到<code>拓展性</code>，有<code>参与框架设计</code>的意识</li>
<li>有<code>调优意识</code>，能主动发现问题，并解决</li>
<li><code>动手能力强，肯干活，会的东西多，有团队合作精神</code></li>
<li><code>责任心较强</code>，能使用较大压力</li>
</ul>
</li>
<li>禁忌：<ul>
<li>回答太简单</li>
<li>说的太快太流利</li>
<li>没有逻辑什么都说</li>
<li>过多介绍细节</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/v2-7887b2c90b2b31fb4e3362eb4f891eed_720w.jpg" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/v2-b39fc87a63a0bf18342ea23a4f1e0561_720w.jpg" alt=""></p>
<h3 id="5-面试陷阱"><a href="#5-面试陷阱" class="headerlink" title="5. 面试陷阱"></a>5. 面试陷阱</h3><ul>
<li>套取机密</li>
<li>培训机构招生</li>
<li>为了解决问题</li>
</ul>
<h3 id="6-工资"><a href="#6-工资" class="headerlink" title="6. 工资"></a>6. 工资</h3><ul>
<li>了解一下公司的奖金、分红、福利等等</li>
<li>问清楚月薪是怎么组成的，如果包括了绩效，月薪分为基本工资和绩效工资两部分，比如 8000 是基本工资，2000 是绩效，看起来月薪是 1 万。但是每个月每个人都有一个绩效系数，真正的月薪是 8000 + 2000 * 系数</li>
<li>股票、期权、奖金等等都是一样，不管对方怎么口头承诺，一定要求写到合同里。</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/v2-be3f71987b6b741cc80abcbd7acc2975_720w.jpg" alt=""></p>
<h3 id="7-面试流程"><a href="#7-面试流程" class="headerlink" title="7. 面试流程"></a>7. 面试流程</h3><ul>
<li>一面机试：一般会考选择题和编程题<ul>
<li>选择题：计算机基础知识涉及计算机网络，操作系统，数据库，编程语言等等</li>
<li>编程题：一般是代码量比较大的题目</li>
</ul>
</li>
<li>二面基础算法面：就是基础的算法，用白纸或者电脑写出来，注重思维过程</li>
<li>三面综合技术面：会考察编程语言，计算机基础知识 ，以及了解项目经历等等<ul>
<li>考察技术原理, 做了一个项目，是不是仅仅调一调接口就完事，之后接口背后做了些什么？</li>
<li>考察技术深度，如果是后台开发的话，可以从系统的<code>扩容、缓存、数据存储</code>等多方面进行考察</li>
<li>考察应变能力，如果面试官针对项目问同学们一个场景，<strong>最为忌讳的回答是什么？“我没考虑过这种情况”。</strong></li>
</ul>
</li>
<li>四面技术boss面：会问一些比较范范的内容，考察大家<code>解决问题和快速学习的能力</code><ul>
<li><strong>在项目中遇到的最大的技术挑战是什么，而你是如果解决的</strong></li>
<li><strong>给出一个项目问题来让面试者分析</strong></li>
<li><strong>快速学习的能力 如果快速学习一门新的技术或者语言?</strong></li>
<li><strong>读研之后发现自己和本科毕业有什么差别？ ** ** 体现出自己思维方式和学习方法上的进步</strong></li>
</ul>
</li>
<li>最后HR面：主要了解面试者与企业文化相不相符，面试者的职业发展，Offer的选择以及介绍一下企业提供的薪资待遇等等。<ul>
<li>选择理由：从技术氛围，职业发展，公司潜力等等方面来说自己为什么选择这家公司</li>
<li>职业规划：尽量从技术的角度规划自己</li>
<li>是否接受加班：</li>
<li>最长坚持的一项事情是什么：</li>
</ul>
</li>
</ul>
<h3 id="8-语言基础"><a href="#8-语言基础" class="headerlink" title="8. 语言基础"></a>8. 语言基础</h3><h4 id="1-Java"><a href="#1-Java" class="headerlink" title="1. Java"></a>1. Java</h4><h5 id="0-java与C-区别"><a href="#0-java与C-区别" class="headerlink" title=".0. java与C++区别"></a>.0. java与C++区别</h5><blockquote>
<ul>
<li>都是面向对象的语言，都支持<code>封装、继承和多态</code></li>
<li>Java不提供指针来<code>直接访问内存</code>，程序内存更加安全</li>
<li>Java的类是<code>单继承的</code>，C++支持<code>多重继承</code>；虽然Java的类不可以多继承，但是<code>接口可以多继承</code>。</li>
<li>Java有<code>自动内存管理机制</code>，不需要程序员手动释放无用内存</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong></li>
</ul>
</blockquote>
<h5 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title=".1. 基本数据类型"></a>.1. 基本数据类型</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/1553754196283.png" alt=""></p>
<ul>
<li>Java 只允许单继承</li>
</ul>
<h6 id="1-String-StringBuffer-StringBuilder-的区别"><a href="#1-String-StringBuffer-StringBuilder-的区别" class="headerlink" title="1. String,StringBuffer, StringBuilder 的区别"></a>1. <strong>String,StringBuffer, StringBuilder</strong> <strong>的区别</strong></h6><ul>
<li>String是字符串常量，StringBuffer和StringBuilder都是字符串变量。后两者的字符内容可变，而前者创建后内容不可变。</li>
<li>String不可变是因为在JDK中<code>String类被声明为一个final类</code>。</li>
<li><code>StringBuffer是线程安全</code>（通过Synchronized修饰）的，而<code>StringBuilder是非线程安全</code>的。</li>
<li>String创建方式：<ul>
<li>通过双引号方式，字符串保存在常量池中，字符串变量保存的是指向常量池的地址</li>
<li>通过new 方式创建：字符串仍在常量池中，会在堆中开辟地址，指向常量池的地址，栈中字符是指向堆中的引用地址</li>
</ul>
</li>
</ul>
<h6 id="2-Vector-ArrayList-LinkedList-的区别是什么？"><a href="#2-Vector-ArrayList-LinkedList-的区别是什么？" class="headerlink" title="2. Vector,ArrayList, LinkedList**的区别是什么？**"></a>2. <strong>Vector,ArrayList, LinkedList**</strong>的区别是什么？**</h6><p>1、Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。</p>
<p>2、List中的元素有序、允许有重复的元素，Set中的元素无序、不允许有重复元素。</p>
<p>3、Vector线程同步，ArrayList、LinkedList线程不同步。</p>
<p>4、LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。</p>
<p>5、ArrayList在元素填满容器时会自动扩充容器大小的50%，而Vector则是100%，因此ArrayList更节省空间。</p>
<h6 id="3-HashTable-HashMap-，TreeMap区别？"><a href="#3-HashTable-HashMap-，TreeMap区别？" class="headerlink" title="3. HashTable, HashMap**，TreeMap区别？**"></a>3. <strong>HashTable, HashMap**</strong>，<strong><strong>TreeMap</strong></strong>区别？**</h6><p><img src="../../../../../picture2022/image-20220308190934186.png" alt=""></p>
<ul>
<li>安全性：<ul>
<li>HashMap 是<strong>不安全的线程</strong>，他允许 Key 值出现一次 null  Value 值出现无数次的 Null</li>
<li>Hashtable 是<strong>安全的线程</strong>，他不仅实现了 Map 接口也实现了 Dictionary 接口，他的 key 值与 Value 值都不允许出现 Null</li>
<li>treeMap <strong>非线程安全</strong> 可以进行排序的，默认按照键的自然顺序进行升序排序，若要进行降序排序则需要在构造集合时候传递一个比较器。</li>
</ul>
</li>
</ul>
<h5 id="4-为什么-HashMap-中-String、Integer-这样的包装类适合作为-Key？⭐"><a href="#4-为什么-HashMap-中-String、Integer-这样的包装类适合作为-Key？⭐" class="headerlink" title=".4. 为什么 HashMap 中 String、Integer 这样的包装类适合作为 Key？⭐"></a>.4. 为什么 HashMap 中 String、Integer 这样的包装类适合作为 Key？⭐</h5><p>String、Integer 等包装类的特性能够<code>保证 Hash 值的不可更改性和计算准确性，能够有效的减少 Hash 碰撞的几率</code></p>
<ol>
<li>都是 final 类型，即不可变性，保证 key 的不可更改性，不会存在获取 hash 值不同的情况</li>
<li>内部已重写了 <code>equals()</code>、<code>hashCode()</code> 等方法，遵守了 HashMap 内部的规范，不容易出现 Hash 值计算错误的情况。</li>
</ol>
<blockquote>
<p>poll () 和 remove () 都是从<code>队列中取出一个元素</code>，但是 poll () 在获取元素<code>失败的时候会返回空</code>，但是 <code>remove () 失败的时候会抛出异常。</code></p>
<ul>
<li>ConcurrenthashMap:  jdk1.8后，Node 数组 + 链表 + 红黑树的数据结构来实现，并发控制使用 <code>Synchronized 和 CAS 来操作</code>，整个看起来就像是优化过且线程安全的 HashMap。</li>
</ul>
</blockquote>
<h5 id="4-i-是安全吗"><a href="#4-i-是安全吗" class="headerlink" title=".4. i++ 是安全吗"></a>.4. i++ 是安全吗</h5><blockquote>
<ol>
<li>局部变量肯定是线程安全的（原因：方法内局部变量是线程私有的）</li>
<li>成员变量多个线程共享时，就不是线程安全的（原因：成员变量是线程共享的，因为 i++ 是三步操作。</li>
</ol>
</blockquote>
<h5 id="4-说说-LinkedHashMap"><a href="#4-说说-LinkedHashMap" class="headerlink" title=".4. 说说 LinkedHashMap"></a>.4. 说说 LinkedHashMap</h5><ul>
<li>LinkedHashMap 继承于 HashMap</li>
</ul>
<p><img src="../../../../../picture2022/image-20220308110052165.png" alt=""></p>
<h6 id="4-Tomcat-Apache，JBoss的区别？"><a href="#4-Tomcat-Apache，JBoss的区别？" class="headerlink" title="4. Tomcat, Apache，JBoss的区别？"></a>4. Tomcat, Apache，JBoss的区别？</h6><ol>
<li>Apache是Http服务器，Tomcat是web服务器，JBoss是应用服务器。</li>
<li>Apache解析静态的html文件；Tomcat可解析jsp动态页面、也可充当servlet容器。</li>
</ol>
<h6 id="5-final"><a href="#5-final" class="headerlink" title="5. final"></a>5. final</h6><ul>
<li>当<em>final</em>修饰<strong>变量</strong>时，被修饰的变量必须被初始化(赋值)，且后续不能修改其值，实质上是常量；<ul>
<li>在<a href="https://www.geeksforgeeks.org/g-fact-79/" target="_blank" rel="noopener">静态块</a>内初始化空的<em>final</em>静态变量</li>
<li>在<a href="https://www.geeksforgeeks.org/instance-initialization-block-iib-java/" target="_blank" rel="noopener">instance-initializer块</a> 或内部构造函数中<a href="https://www.geeksforgeeks.org/instance-initialization-block-iib-java/" target="_blank" rel="noopener">初始化</a>空的<em>final</em>变量。如果您的类中有多个构造函数，则必须在所有构造函数中初始化它，否则将抛出编译时错误</li>
<li>声明它时初始化<em>final</em>变量</li>
<li>对于<em>final</em>的引用变量，可以<code>更改该引用变量指向的对象的内部状态</code></li>
<li>当在方法/构造函数/块中创建<em>final</em>变量时，它被称为局部<em>final</em>变量，并且<code>必须在创建它的位置初始化一次</code>。可以稍后赋值</li>
</ul>
</li>
<li>当<em>final</em>修饰<strong>方法</strong>时，被修饰的方法无法被所在类的子类重写（覆写）；<ul>
<li>高效，如果将一个方法指明为final，就是同意编译器将针对该方法的调用都转化为内嵌调用（内联），如果是内嵌调用，虚拟机不再执行正常的方法调用（<code>参数压栈，跳转到方法处执行，再调回，处理栈参数，处理返回值</code>），而是直接将方法展开，以方法体中的实际代码替代原来的方法调用</li>
</ul>
</li>
<li>当<em>final</em>修饰<strong>类</strong>时，被修饰的类不能被继承，并且<em>final</em>类中的所有成员方法都会被隐式地指定为<em>final</em>方法，但成员变量则不会变。<ul>
<li>彻底防止被<a href="https://www.geeksforgeeks.org/inheritance-in-java/" target="_blank" rel="noopener">继承</a>，因为<em>final</em>类不能被扩展</li>
<li><a href="https://www.geeksforgeeks.org/create-immutable-class-java/" target="_blank" rel="noopener">创建一个</a>类似于<a href="https://www.geeksforgeeks.org/string-class-in-java/" target="_blank" rel="noopener">String</a>类的不可变类: <code>private final char value[];</code><ul>
<li>为了实现<code>字符串常量池</code> (只有当字符是不可变的，字符串池才有可能实现)</li>
<li>为了<code>线程安全</code> (字符串自己便是线程安全的)</li>
<li>为了保证<code>同一个对象调用 hashCode () 都产生相同的值</code>，String 设置为不可变可以对这个条件有很好的支持，这也是 Map 类的 key 使用 String 的原因。</li>
</ul>
</li>
</ul>
</li>
<li><em>final</em>变量或对象是只读的，可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li>
</ul>
<h5 id="6-final、finally、finalize-有什么区别？"><a href="#6-final、finally、finalize-有什么区别？" class="headerlink" title="6. final、finally、finalize 有什么区别？"></a>6. <strong>final、finally、finalize 有什么区别？</strong></h5><ul>
<li>final 可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li>finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码方法 finally 代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize 是一个方法，属于<code>Object 类的一个方法</code>，而 Object 类是所有类的父类，该方法<code>一般由垃圾回收器来调用，当我们调用 System 的 gc () 方法的时候，由垃圾回收器调用 finalize (), 回收垃圾</code>。</li>
</ul>
<h6 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h6><ul>
<li>arrays.toString()方法：打印一维数组</li>
<li>arrays.deepToString()方法：打印二维数组</li>
<li>Arrays提供的相关函数</li>
</ul>
<h6 id="7-Object-基本类"><a href="#7-Object-基本类" class="headerlink" title="7. Object 基本类"></a>7. Object 基本类</h6><ul>
<li>equals, hashCode, toString, clone</li>
<li>类之间关系：继承，聚合，依赖</li>
<li>类中成员：<ul>
<li>静态字段：和类相关，只有一份</li>
<li>实例字段：和对象相关，没有对象对应一份</li>
<li>final修饰字段：</li>
</ul>
</li>
<li>hashcode 就类似 门牌号，小区非常大但定位你住哪里告诉门牌号就可以，非常快速定位到（非常像组数下标）</li>
<li>equals 就是找到门牌号后需要比较里面具体的房间，少一个都不可以。</li>
</ul>
<h6 id="8-访问权限"><a href="#8-访问权限" class="headerlink" title="8. 访问权限"></a>8. 访问权限</h6><ul>
<li>private：当前Java类可见；Protected: 子类，包可见； public: 所有地方可见；</li>
</ul>
<h6 id="9-抽象和接口"><a href="#9-抽象和接口" class="headerlink" title="9. 抽象和接口"></a>9. 抽象和接口</h6><ul>
<li>抽象类不能被实例化，只能被继承</li>
<li>java8开始，接口也可以default方法实现，默认字段是public static final</li>
<li>不同点：<ul>
<li>接口类成员只能是public，而抽象类成员有多种访问权限</li>
<li>一个类可以实现多个接口，但至多只能继承一个抽象类</li>
</ul>
</li>
</ul>
<h5 id="2-判等问题"><a href="#2-判等问题" class="headerlink" title=".2. 判等问题"></a>.2. 判等问题</h5><ul>
<li>包装类<ul>
<li>对<strong>基本类型</strong>，比如 <code>int</code>、<code>long</code>，进行判等，<strong>只能使用 <code>==</code>，比较的是字面值</strong>。因为基本类型的值就是其数值。</li>
<li>对<strong>引用类型</strong>，比如 <code>Integer</code>、<code>Long</code> 和 <code>String</code>，进行判等，<strong>需要使用 <code>equals</code> 进行内容判等</strong>。因为<code>引用类型的直接值是指针</code>，使用 <code>==</code> 的话，比较的是指针，也就是两个对象在内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。</li>
</ul>
</li>
<li>String类型<ul>
<li>当代码中出现双引号形式创建字符串对象时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是字符串驻留或池化。</li>
</ul>
</li>
<li>equals</li>
</ul>
<blockquote>
<ul>
<li>考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true；</li>
<li>需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle；</li>
<li>需要判断两个对象的类型，如果类型都不同，那么直接返回 false；</li>
<li>确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    Point that <span class="token operator">=</span> <span class="token punctuation">(</span>Point<span class="token punctuation">)</span> o<span class="token punctuation">;</span>
    <span class="token keyword">return</span> x <span class="token operator">==</span> that<span class="token punctuation">.</span>x <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span> that<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>如果自定义对象没有实现自定义的 hashCode 方法，就会<code>使用 Object 超类的默认实现</code>，得到的两个 hashCode 是不同的，导致无法满足需求。</li>
</ul>
<h5 id="6-链表"><a href="#6-链表" class="headerlink" title=".6. 链表"></a>.6. 链表</h5><ul>
<li>循环单/双链表</li>
<li>双链表</li>
<li>静态链表</li>
</ul>
<h5 id="9-异常"><a href="#9-异常" class="headerlink" title="9. 异常"></a>9. 异常</h5><ul>
<li>抛出异常：throws 方式</li>
<li>捕获异常：try-catch方式</li>
</ul>
<h5 id="10-注解"><a href="#10-注解" class="headerlink" title="10. 注解"></a>10. 注解</h5><ul>
<li>作用：生成文档，跟踪代码依赖，实现替代配置文件功能，在编译时进行格式检查</li>
<li>原理：继承Annotation接口，具体实现类是使用Java运行时生成的动态代理类</li>
<li>元注解：<ul>
<li>@Documented：注解是否包含在JavaDoc中</li>
<li>@Retention：定义该注解的生命周期</li>
<li>@Target：注解用于什么地方</li>
<li>@Inherited: 是否允许子类继承该注解</li>
</ul>
</li>
<li>自定义注解：<ul>
<li>参数成员只能够使用8中基本数据类型和String，Enum，Class，annotations等数据类型以及对应的数组</li>
<li>要获取注解类的方法和注解信息，必须通过Java反射技术来获取Annotation对象</li>
</ul>
</li>
</ul>
<h5 id="11-Java-锁"><a href="#11-Java-锁" class="headerlink" title=".11. Java 锁"></a>.11. Java 锁</h5><h6 id="1-锁分类"><a href="#1-锁分类" class="headerlink" title=".1. 锁分类"></a>.1. 锁分类</h6><ul>
<li><code>乐观锁</code>：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在<code>更新的时候</code>会判断一下在此期间别人有没有去更新这个数据</li>
<li><code>悲观锁</code>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会<code>上锁</code>（Synchronized 和 Lock）</li>
</ul>
<h6 id="2-Synchronized"><a href="#2-Synchronized" class="headerlink" title=".2. Synchronized"></a>.2. Synchronized</h6><blockquote>
<p>synchronized 关键字通过一对字节码指令 monitorenter/monitorexit 实现:</p>
<ul>
<li><p>每一个 Java 对象都有成为<code>Monitor 的潜质</code>，因为在 Java 的设计中 ，每一个 Java 对象自打娘胎里出来就带了一把看不见的锁，它叫做<code>内部锁或者 Monitor 锁</code></p>
</li>
<li><p>ObjectMonitor 中有两个队列，<code>_WaitSet</code> 和 <code>_EntryList</code>，用来保存 <code>ObjectWaiter</code> 对象列表 (每个等待锁的线程都会被封装成 ObjectWaiter 对象)，<code>_owner</code> 指向持有 <code>ObjectMonitor</code> 对象的线程，当多个线程同时访问一段同步代码时，首先会进入 <code>_EntryList</code> 集合，当线程获取到对象的 <code>monitor</code> 后进入 <code>_Owner</code> 区域并把 <code>monitor</code> 中的 <code>owner</code> 变量设置为当前线程同时 monitor 中的<code>计数器count加1</code>.</p>
</li>
<li><p>若线程调用 wait () 方法，将释放当前持有的 monitor，owner 变量恢复为 null，count 自减 1，同时该线程进入 WaitSe t 集合中等待被唤醒。若当前线程执行完毕也将释放 monitor (锁) 并复位变量的值，以便其他线程进入获取 monitor (锁)</p>
</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220301103612862.png" alt=""></p>
<ul>
<li>synchronized:<ul>
<li>修饰普通方法：当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法</li>
<li>修饰静态方法：访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</li>
<li><strong>synchronized(this|object) {}：</strong>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以<strong>每个对象有其独立的对象锁，互不干扰</strong>。</li>
</ul>
</li>
<li>volatile关键字无法保证操作的原子性，对变量的写操作不依赖于当前值（自增自减等操作），<code>多线程访问volatile不会发生阻塞，synchronized会出现阻塞</code>volatile用于解决变量多线程之间的可见性，synchronized是解决多线程之间访问资源的同步性。 volatile是线程同步的轻量级实现，所以性能比synchronized好。但是volatile只能修饰变量，synchronized可以修饰变量、代码块、方法（volatile保证变量可见性，synchronized保证代码块可见性）</li>
</ul>
<h5 id="12-synchronized-与-Lock-区别"><a href="#12-synchronized-与-Lock-区别" class="headerlink" title=".12. synchronized 与 Lock 区别"></a>.12. synchronized 与 Lock 区别</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220303145118344.png" alt=""></p>
<p>多线程：</p>
<ul>
<li>新建状态，就绪状态，执行状态，同步阻塞，等待状态，其他状态</li>
<li>前台线程&amp;后台线程</li>
<li>临界资源访问问题</li>
<li>串行，并行（并发）</li>
<li>Async, await: await操作符等的是一个返回的结果，那么如果是同步的情况，那就直接返回了。那如果是异步的情况呢，异步的情况下，await会阻塞整一个流程，直到结果返回之后，才会继续下面的代码。</li>
</ul>
<h5 id="13-Volatile-原理"><a href="#13-Volatile-原理" class="headerlink" title=".13. Volatile 原理"></a>.13. Volatile 原理</h5><blockquote>
<p>每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，<strong>流水线技术</strong>产生了，它的原理是指令 1 还没有执行完，就可以开始执行指令 2，而不用等到指令 1 执行结束之后再执行指令 2，这样就大大提高了效率。</p>
</blockquote>
<ol>
<li><p><code>防止重排序（有序性）</code>，实例化对象分为：<code>分配内存空间，初始化对象，地址赋值</code>给对应应用三步，将变量设置为volatile类型的变量就不会重排序了。（happen-before关系）</p>
</li>
<li><p>实现<code>可见性</code>，指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。<code>volatile 关键字可以保证共享变量的可见性</code>。（基于内存屏障实现了可见性）</p>
</li>
<li><p><code>原子性：volatile不能保证完全的原子性</code>，<code>只能保证单次的读/写操作具有原子性</code>，注意<code>i++是两次操作</code>。分为三步：</p>
</li>
</ol>
<ul>
<li><p>读i的值</p>
</li>
<li><p>i加1</p>
</li>
<li><p>将i的值写回内存</p>
</li>
</ul>
<p><img src="../../../../../picture2022/1645623395282-02e421e9-62b6-47a0-9168-3f89e9794af3.png" alt="img"></p>
<p>共享的long和double变量的为什么要用volatile,因为long和double两种数据类型的操作可分为<code>高32位和低32位两部</code>分，因此<code>普通的long或double类型读/写可能不是原子的</code>。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下<code>对long和double的单次读/写操作都具有原子性</code>。</p>
<ul>
<li><p>应用场景</p>
<ul>
<li><p>对变量的写操作不依赖于当前值。</p>
</li>
<li><p>该变量没有包含在具有其他变量的不变式中。</p>
</li>
<li><p>只有在状态真正独立于程序内其他内容时才能使用 volatile。</p>
</li>
</ul>
</li>
<li><p>volatile与synchronized的区别</p>
<ul>
<li><p><strong>volatile 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong>volatile性能肯定比synchronized关键字要好</strong> 。但是 <strong>volatile 关键字只能**</strong>用于变量<strong>**而 synchronized 关键字可以修饰方法以及代码块</strong> 。</p>
</li>
<li><p><strong>volatile</strong> <strong>关键字能保证数据的可见性，但不能保证数据的原子性。**</strong>synchronized** <strong>关键字两者都能保证。</strong></p>
</li>
<li><p><strong>volatile关键字主要用于**</strong>解决变量在多个线程之间的可见性<strong><strong>，而 synchronized 关键字解决的是</strong></strong>多个线程之间访问资源的同步性**</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h4><h5 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title=".1. 观察者模式"></a>.1. 观察者模式</h5><ul>
<li>抽象观察者：抽象主题提供增加、删除 观察者对象的接⼝（attach、detach）</li>
<li>抽象被观察者：更新接⼝⽅法（update），使得在得到主题更改通知时更新⾃⼰</li>
<li>具体被观察者：有关状态存⼊具体观察者对象<code>，具体被观察者的内部状态发⽣改变时，给所有加⼊过的观察者发送通知。</code></li>
<li>具体观察组：抽象观察者定义的更新接⼝，以便在得到主题更改通知时更新⾃身的状态</li>
</ul>
<h5 id="2-线程池的设计与相关问题"><a href="#2-线程池的设计与相关问题" class="headerlink" title=".2. 线程池的设计与相关问题"></a>.2. 线程池的设计与相关问题</h5><ul>
<li>多线程的主要是为了提高 CPU 的利用率。</li>
<li>线程的切换有开销，线程数的多少需要结合 CPU 核心数与 I/O 等待占比。</li>
<li>线程数太少无法充分利用 CPU ，太多的话由于上下文切换的消耗又得不偿失, 需要<strong>缓存一批线程</strong>，让它们时刻准备着执行任务</li>
<li>线程池内部会有一个<code>队列来存储我们提交的任务</code>，而内部线程不断地从队列中索取任务来执行，这就是线程池最原始的执行机制。</li>
</ul>
<blockquote>
<ul>
<li>如果此时线程数<strong>小于</strong>核心线程数，那么就会新起一个线程来执行当前的任务。</li>
<li>如果此时线程数<strong>大于</strong>核心线程数，那么就会将任务塞入阻塞队列中，等待被执行。</li>
<li>如果阻塞队列满了，并且此时线程数<strong>小于</strong>最大线程数，那么会创建新线程来执行当前任务。</li>
<li>如果阻塞队列满了，并且此时线程数<strong>大于</strong>最大线程数，那么会采取拒绝策略。</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">YesThreadPool</span> <span class="token punctuation">{</span>

    BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> taskQueue<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//存放任务的阻塞队列</span>
    List<span class="token operator">&lt;</span>YesThread<span class="token operator">></span> threads<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//线程列表</span>

    <span class="token function">YesThreadPool</span><span class="token punctuation">(</span>BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> taskQueue<span class="token punctuation">,</span> <span class="token keyword">int</span> threadSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>taskQueue <span class="token operator">=</span> taskQueue<span class="token punctuation">;</span>
        threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 初始化线程，并定义名称</span>
        IntStream<span class="token punctuation">.</span><span class="token function">rangeClosed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> threadSize<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            YesThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">YesThread</span><span class="token punctuation">(</span><span class="token string">"yes-task-thread-"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            threads<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//提交任务只是往任务队列里面塞任务</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        taskQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">YesThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//自定义一个线程</span>
        <span class="token keyword">public</span> <span class="token function">YesThread</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//死循环</span>
                Runnable task <span class="token operator">=</span> null<span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    task <span class="token operator">=</span> taskQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不断从任务队列获取任务</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"记录点东西....."</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//执行</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h5 id="3-面向对象设计原则"><a href="#3-面向对象设计原则" class="headerlink" title=".3. 面向对象设计原则"></a>.3. 面向对象设计原则</h5><ul>
<li>OCP 原则（也叫<code>开闭原则</code>）: 开闭原则就是说对<code>扩展开放，对修改关闭</code>。</li>
<li>SRP 原则（<code>职责单一原则</code>）: 一个类只负责一项职责，可以降低类的复杂度，提高类的可读性，提高系统的可维护性，当修改一个功能时，可以显著降低对其他功能的影响。</li>
<li>OCP 原则 (<code>里氏替换原则</code>)：任何基类可以出现的地方，子类一定可以出现。通俗的理解即为子类可以扩展父类的功能，但不能改变父类原有的功能。</li>
<li>DIP 原则（<code>依赖倒置原则</code>）：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。通俗点说：要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</li>
<li>LoD 法则（<code>迪米特法则</code>）：一个对象应该对其他对象保持最少的了解。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。</li>
</ul>
<h5 id="4-事件委托"><a href="#4-事件委托" class="headerlink" title=".4. 事件委托"></a>.4. 事件委托</h5><ul>
<li>委托： 把委托看成是用来执行方法的一个指针，方法当成参数传递</li>
<li>事件绑定：首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。table, button, onclickhandle</li>
<li>事件监听：可以绑定多个事件。常规的事件绑定只执行最后绑定的事件。两个事件都执行了， addEventListener</li>
<li>事件委托：事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果</li>
</ul>
<blockquote>
<p><code>委托就是第三方</code>，<code>调用者告诉第三方要做什么</code>，然后<code>调用者就不用管了 这个委托 (第三方) 就会去调用方法去帮你实现</code><br>委托的好处: </p>
<ol>
<li>相当于<code>用方法作为另一方法参数</code>(类似于 C 的函数指针)</li>
<li>在两个不能直接调用的方法中作为桥梁，如：<code>在多线程中的跨线程的方法调用就得用委托</code></li>
<li>当<code>不知道方法具体实现什么时使用委托</code>，如：事件中使用委托</li>
</ol>
</blockquote>
<ul>
<li>枚举类型是线程安全的，并且只会装载一次</li>
</ul>
<h5 id="5-装饰器和适配器区别"><a href="#5-装饰器和适配器区别" class="headerlink" title=".5. 装饰器和适配器区别"></a>.5. 装饰器和适配器区别</h5><ul>
<li>装饰器的目的是动态地给一个对象添加一些额外的职责，这个对象的类型不会发生变化，但是行为却发生了改变。</li>
<li>适配器的目的是将一个类的接口变换成客户端所期待的另一种接口，就是可以将一个对象包装成另外的一个接口。</li>
</ul>
<h4 id="3-计算机系统"><a href="#3-计算机系统" class="headerlink" title="3. 计算机系统"></a>3. 计算机系统</h4><h5 id="1-冯诺依曼模型"><a href="#1-冯诺依曼模型" class="headerlink" title=".1. 冯诺依曼模型"></a>.1. 冯诺依曼模型</h5><ul>
<li>冯诺依曼模型分为 5 ⼤部件：<code>内存、CPU、总线、输⼊设备、输出设备</code></li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220228111809789.png" alt=""></p>
<h4 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3. 操作系统"></a>3. <a href="https://www.eet-china.com/mp/a112834.html" target="_blank" rel="noopener">操作系统</a></h4><h5 id="1-进程切换的流程"><a href="#1-进程切换的流程" class="headerlink" title=".1. 进程切换的流程"></a>.1. 进程切换的流程</h5><ul>
<li>从A进程切换到B进程：先从<code>用户态切换到内核态</code>，操作系统需要<code>先挂起正在占用 CPU 的 A 进程，才能切换到 B 进程</code></li>
<li>从用户态切换到内核态: 通过硬中断来实现, 从用户态切换到内核态之<code>前需要保存用户进程的上下文</code>，以便下一次执行时可以继续之前的工作</li>
<li>上下文就是<code>进程执行的环境</code>，包括所有的<code>寄存器变量</code>，进程打开的<code>文件</code>、<code>内存信息</code>等。一个进程的上下文可以分为<code>用户级上下文，寄存器上下文，系统级上下文</code>。用户级上下文存储的是用户进程的内存数据以及堆栈数据等；寄存器上下文是一些通用寄存器；系统级上下文是内核栈、PCB (进程控制块) 等。</li>
</ul>
<h5 id="2-用户态切换至内核态三种方式"><a href="#2-用户态切换至内核态三种方式" class="headerlink" title=".2. 用户态切换至内核态三种方式"></a>.2. 用户态切换至内核态三种方式</h5><blockquote>
<p>CPU 的指令中，有一些是非常危险的，比如<code>清理内存、设置时钟等</code>，如果所有的程序都能使用，就可能造成系统的崩溃;<code>CPU 将指令分为特权指令和非特权指令</code></p>
</blockquote>
<ul>
<li>系统调用（系统调用是通过软中断实现的）</li>
<li>中断（硬）</li>
<li>异常</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220228130558051.png" alt=""></p>
<ul>
<li>首先用户程序会调用 <code>glibc</code> 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li>
<li>glibc 库知道针对不同体系结构调用<code>系统调用</code>的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li>
<li>然后，glibc 库调用<code>软件中断指令(SWI)</code> ，这个指令通过更新 <code>CPSR</code> 寄存器将模式改为超级用户模式，然后跳转到地址 <code>0x08</code> 处。</li>
<li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li>
<li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 <code>vector_swi()</code>。</li>
<li>在 vector_swi () 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 <code>sys_call_table</code> 的索引，调转到系统调用函数。</li>
<li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li>
</ul>
<h5 id="3-堆和栈区别"><a href="#3-堆和栈区别" class="headerlink" title=".3. 堆和栈区别"></a>.3. 堆和栈区别</h5><ul>
<li>堆是由<code>用户来控制</code>的，我们可以使用 malloc 这种命令来在堆中申请内存, 分配方法包括: <code>空闲链表, 位图, 对象池</code></li>
<li>栈是由<code>操作系统控制</code>的，在栈中存储的是这个<code>进程的局部变量等</code>，用于维护函数调用的上下文, 比如我们用 malloc 来申请一块内存，内存本身是在堆中开辟的，而指向这块内存的指针存储在栈中</li>
<li>可执行文件映像：<code>存储着可执行文件在内存中的映像</code>，由装载器装载是<code>将可执行文件的内存读取或映射到这里</code></li>
<li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</li>
</ul>
<blockquote>
<p>如何快速把栈用完:</p>
<ul>
<li>对函数进行递归调用</li>
<li>在函数中定义大对象</li>
</ul>
</blockquote>
<h5 id="4-malloc-实现机制"><a href="#4-malloc-实现机制" class="headerlink" title=".4. malloc 实现机制"></a>.4. malloc 实现机制</h5><ul>
<li><p>malloc 本质上是维护了一个<code>内存空闲链表</code>，每次我们调用 malloc 申请空间的时候，链表就会<code>从头开始遍历，来寻找一个合适的空闲内存空间</code>，然后把<code>这个空间给分割开，一部分分配给用户</code>，另一部分继续标注为空闲，而当没有足够大的空闲块时，malloc 就会通过系统调用来申请更多的内存块。而我们调用<code>free 来释放内存块的时候，该内存块就会回到链表中，并且相邻的内存块会被合并</code>。</p>
</li>
<li><p>搜索空闲块的算法主要有<code>首次适配、下一次适配、最佳适配</code>，首次适配即第一次找到足够大的内存块就分配，但这样会产生<code>很多的内存碎片</code>，也因此第二次适配被提出来缓解这个问题。另一个极端则是<code>最佳适配</code>，即找到一块<code>刚好大于我们所需内存大小的内存块</code>，这种做法一方面耗时长，另一方面也会产生一些极小的内存碎片。</p>
</li>
<li><p>最先适应算法：尽量往低地址空闲区域放，放不下的话在更加地址慢慢升高。</p>
<ul>
<li>低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。</li>
</ul>
</li>
<li><p>下次适配算法：NF 算法每次存储都是<code>接着上次分配区域的下一个地址</code>；</p>
<ul>
<li>NF 算法每次存储都是接着上次分配区域的下一个地址；</li>
</ul>
</li>
<li><p>最佳适应算法：从头部开始查找; 空闲区域是从小到大记录的，每次查找都从最小的开始，直到查找的满足要求的最小空闲区域。</p>
</li>
<li><p>最坏适应算法： BF 是用<strong>最小</strong>的空闲区域来存储东西，而 WF 是用<strong>最大</strong>的空闲区域来存储。</p>
</li>
</ul>
<h5 id="5-虚拟地址怎么映射物理地址"><a href="#5-虚拟地址怎么映射物理地址" class="headerlink" title=".5. 虚拟地址怎么映射物理地址"></a>.5. 虚拟地址怎么映射物理地址</h5><ul>
<li>虚拟地址的<code>构成</code>为<code>页目录索引 (10 位) + 页表索引 (10 位) + 表内偏移 (12 位)</code></li>
</ul>
<ul>
<li>以 win32 系统为例，页目录和页表都为 1024 个，页表大小为 4KB，一共是 4G 的虚拟内存空间</li>
</ul>
<ul>
<li>而从虚拟地址映射到物理地址实际上就是<code>通过页目录和页表的索引找到内存页</code>。</li>
</ul>
<ul>
<li>在页表项中有一位标志位，<code>用来标识包含此数据的页是否在物理内存中</code>，<code>如果在的话，就直接做地址映射</code>，否则，<code>抛出缺页中断，操作系统会把次数据页调入内存</code>。复用</li>
</ul>
<blockquote>
<p>对于段页式系统来说，首先是查找段号，在对应段内找到页号，在页内找到页内偏移，从而<br>程序地址：段号 + 页号 + 页内偏移</p>
</blockquote>
<h5 id="5-多级缓存"><a href="#5-多级缓存" class="headerlink" title=".5. 多级缓存"></a>.5. 多级缓存</h5><ul>
<li>每一级缓存中储存的是下一级缓存的一部分</li>
<li>读取速度按级别依次递减，成本也依次递减，容量依次递增</li>
<li>当前级别未命中时，才会去下一级寻找</li>
</ul>
<h5 id="5-高速缓存-主存-虚拟外存关系"><a href="#5-高速缓存-主存-虚拟外存关系" class="headerlink" title=".5. 高速缓存,主存,虚拟外存关系"></a>.5. 高速缓存,主存,虚拟外存关系</h5><ul>
<li>缓存： 在 CPU 同时处理很多数据，而又不可能同时进行所有数据的传输的情况，把优先级低的数据暂时放入缓存中，等优先级高的数据处理完毕后再把它们从缓存中拿出来进行处理</li>
<li>主存：主存就是内存，是直接与 CPU 交换信息的存储器，指 CPU 能够通过指令中的地址码直接访问的存储器，常用于存放处于活动状态的程序和数据</li>
<li>虚拟内存：当运行数据超过内存限度，部分数据自动 “溢出”，这时系统会将硬盘上的部分空间模拟成内存 —— 虚拟内存，并且将暂时不运行的程序或不使用的数据存放到虚拟内存中等待需要时调用</li>
<li>辅存就是外存： 硬盘与磁盘、光盘、软盘、U 盘等</li>
</ul>
<h5 id="6-进程和线程-amp-协程"><a href="#6-进程和线程-amp-协程" class="headerlink" title=".6. 进程和线程&amp;协程"></a>.6. 进程和线程&amp;协程</h5><ul>
<li>线程是资源调度的独立单位</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220228131353875.png" alt=""></p>
<ul>
<li><p><code>同一进程的线程共享本进程的地址空间</code>，而<code>进程之间则是独立的地址空间</code>；</p>
</li>
<li><p>同一进程内的线程共享本<code>进程的资源</code>，但是进程之间的资源是独立的；</p>
</li>
<li><p>一个进程<code>崩溃</code>后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程崩溃，所以多进程比多线程健壮；</p>
</li>
<li><p><code>进程切换，消耗的资源大</code>。所以涉及到频繁的切换，使用线程要好于进程；<br>两者均可并发执行；</p>
</li>
<li><p>每<code>个独立的进程有一个程序的入口、程序出口</code>。但是<code>线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</code></p>
</li>
<li><p><code>进程</code>之间私有和共享的资源</p>
<ul>
<li><p>私有：<code>地址空间、堆、全局变量、栈、寄存器</code></p>
</li>
<li><p>共享：<code>代码段，公共数据，进程目录，进程 ID</code></p>
</li>
</ul>
</li>
<li><p><code>线程</code>之间私有和共享的资源</p>
<ul>
<li><p>私有：<code>线程栈</code>，<code>寄存器，``程序计数器</code></p>
</li>
<li><p>共享：堆，地址空间，全局变量，静态变量</p>
</li>
</ul>
</li>
<li><p><code>协程</code>: 英文 Coroutines，是一种<code>基于线程之上</code>，但<code>又比线程更加轻量级的存在</code>，这种由程序员<code>自己写程序来管理的轻量级线程叫做『用户空间线程』</code>，具有对内核来说不可见的特性。</p>
<ul>
<li>线程的切换由操作系统负责调度，<code>协程由用户自己进行调度，因此减少了上下文切换</code>，提高了效率。</li>
<li>线程的默认 Stack 大小是 1M，而<code>协程更轻量，接近 1K</code>。因此可以在相同的内存中开启更多的协程。</li>
<li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li>
<li>适用于<code>被阻塞的，且需要大量并发的场景</code>。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</li>
</ul>
</li>
</ul>
<p><img src="../../../../../picture2022/6765e36cc4604fba897976638af03524.jpeg" alt=""></p>
<h5 id="7-多线程-amp-多进程"><a href="#7-多线程-amp-多进程" class="headerlink" title=".7. 多线程&amp;多进程"></a>.7. 多线程&amp;多进程</h5><p><img src="../../../../../picture2022/v2-6ac616676015f6f76d5067845614c2be_720w.jpg" alt=""></p>
<h5 id="7-中断"><a href="#7-中断" class="headerlink" title=".7. 中断"></a>.7. 中断</h5><ul>
<li>指当出现需要时，CPU 暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。</li>
<li><code>硬件中断是由外设</code>引发的，<code>软中断是执行中断指令</code>产生的。</li>
<li>硬件中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。</li>
<li><code>硬件中断是可屏蔽的，软中断不可屏蔽。</code></li>
</ul>
<h5 id="7-进程退出"><a href="#7-进程退出" class="headerlink" title=".7. 进程退出"></a>.7. 进程退出</h5><ul>
<li><code>正常退出(自愿的)</code></li>
<li><code>错误退出(自愿的)</code></li>
<li><code>严重错误(非自愿的)</code></li>
<li><code>被其他进程杀死(非自愿的)</code></li>
</ul>
<h5 id="7-进程通信"><a href="#7-进程通信" class="headerlink" title=".7. 进程通信"></a>.7. 进程通信</h5><ul>
<li><p><strong>管道</strong>：包括无名管道和命名管道，无名管道半双工，只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件；命名管道可以允许无亲缘关系进程间的通信。</p>
</li>
<li><p><strong>系统 IPC</strong></p>
<p><strong>消息队列</strong>：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。</p>
<p><strong>信号量 semaphore</strong>：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。</p>
<p><strong>信号</strong>：用于通知接收进程某个事件的发生。</p>
<p><strong>内存共享</strong>：使多个进程访问同一块内存空间。</p>
</li>
<li><p><strong>套接字 socket</strong>：用于不同主机直接的通信。</p>
</li>
</ul>
<h5 id="7-BIO、NIO-有什么区别"><a href="#7-BIO、NIO-有什么区别" class="headerlink" title=".7. BIO、NIO 有什么区别"></a>.7. BIO、NIO 有什么区别</h5><p><strong>BIO（Blocking I/O）</strong>：<strong>阻塞 IO</strong>。调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。</p>
<p><strong>NIO（New I/O）</strong>：<strong>同时支持阻塞与非阻塞模式</strong>，NIO 的做法是<code>叫一个线程不断的轮询每个 IO 的状态，看看是否有 IO 的状态发生了改变</code>，从而进行下一步的操作。</p>
<h5 id="7-线程通信方式"><a href="#7-线程通信方式" class="headerlink" title=".7. 线程通信方式"></a>.7. 线程通信方式</h5><p>线程间的通信方式包括<strong>临界区、互斥量、信号量、条件变量、读写锁</strong>：</p>
<ol>
<li><code>临界区</code>：每个线程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个线程使用的共享资源）。每次只准许一个线程进入临界区，进入后不允许其他线程进入。不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问。</li>
<li><code>互斥量</code>：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>
<li><code>信号量</code>：计数器，允许多个线程同时访问同一个资源。</li>
<li><code>条件变量</code>：通过条件变量通知操作的方式来保持多线程同步。</li>
<li><code>读写锁</code>：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。</li>
</ol>
<h5 id="7-并发编程三要素"><a href="#7-并发编程三要素" class="headerlink" title=".7. 并发编程三要素"></a>.7. 并发编程三要素</h5><ul>
<li><code>原子性</code>：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</li>
<li><code>可见性</code>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li><code>有序性</code>：即程序执行的顺序按照代码的先后顺序执行</li>
</ul>
<h5 id="7-线程通信方式-1"><a href="#7-线程通信方式-1" class="headerlink" title=".7. 线程通信方式"></a>.7. 线程通信方式</h5><ul>
<li><code>锁机制</code>：包括互斥锁 / 量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）</li>
<li><code>互斥锁 / 量（mutex）</code>：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li><code>读写锁（reader-writer lock）</code>：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li><code>条件变量（condition）</code>：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
<li>信号量机制 (Semaphore)</li>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
<li><code>信号机制 (Signal)</code>：类似进程间的信号处理</li>
<li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<h5 id="8-进程互斥与同步"><a href="#8-进程互斥与同步" class="headerlink" title=".8. 进程互斥与同步"></a>.8. 进程互斥与同步</h5><ul>
<li><code>进程是占有资源的最小单位</code>，对于那种只能同时被一个进程持有的资源我们称为<code>临界资源</code>，对于临界资源的访问，必须是互斥的</li>
<li><code>同步</code>即两个进程的资源访问必须是先后关系，比如经典的生产者消费者问题，读者写着问题。而<code>互斥</code>则是两种在进行资源抢到，比如购票问题。</li>
</ul>
<h5 id="8-信号量与mutex和自旋锁区别"><a href="#8-信号量与mutex和自旋锁区别" class="headerlink" title=".8. 信号量与mutex和自旋锁区别"></a>.8. 信号量与mutex和自旋锁区别</h5><blockquote>
<ul>
<li>信号量（semaphore）用在<code>多线程多任务同步的</code>，一个线程完成了某一个动作就<code>通过信号量告诉别的线程</code>，别的线程再进行某些动作。</li>
<li><code>互斥锁</code>（Mutual exclusion，缩写 Mutex）是用在多线程多任务互斥的，<code>一个线程占用了某一个资源，那么别的线程就无法访问</code>，直到这个线程 unlock，其他的线程才开始可以利用这个资源</li>
<li>自旋锁与前两者的区别是<code>自旋锁不会引起调用者睡眠</code>，如果自旋锁已经被别的执行单元保持，<code>调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁</code></li>
</ul>
</blockquote>
<h5 id="9-死锁"><a href="#9-死锁" class="headerlink" title=".9. 死锁"></a>.9. 死锁</h5><blockquote>
<p>死锁的产生是在这样一种环境中：比如我们有两个进程 AB，他们都需要<code>资源 1 和资源 2</code>，当进程<code>A 持有资源 1，进线程 B 持有资源 2</code> 的时候，他们<code>都需要对方手上的进程，而一般操作系统又不允许抢占</code>，这个时候就发生了死锁。</p>
</blockquote>
<ul>
<li>死锁条件：<ul>
<li><code>互斥条件</code>：每个资源都被分配给了一个进程或者资源是可用的</li>
<li><code>保持和等待条件</code>：已经获取资源的进程被认为能够获取新的资源</li>
<li><code>不可抢占条件</code>：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li>
<li><code>循环等待</code>：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li>
</ul>
</li>
<li>避免死锁方法：<ul>
<li><code>静态分配资源</code>，一开始就把一个进程所需的全部资源都分配给它，但这样会降低资源的使用效率</li>
</ul>
<ol start="2">
<li><code>允许抢占</code>，需要设置进程的<code>不同优先级，高优先级的进程可以抢占低优先级的进程的资源</code></li>
<li>把<code>资源进行编号</code>，申请资源必须按照资源的编号顺序来申请</li>
<li>安全状态检查，银行家算法</li>
</ol>
</li>
<li>死锁已经发生：<ul>
<li>可以<code>运行抢占</code>，从一个或多个进程中抢出资源来给其他进程</li>
<li>也可以<code>终止一些进程</code>，来达到释放资源的目的</li>
<li>回滚恢复</li>
</ul>
</li>
</ul>
<h5 id="10-进程调度算法"><a href="#10-进程调度算法" class="headerlink" title=".10. 进程调度算法"></a>.10. 进程调度算法</h5><ul>
<li><code>先来先服务调度</code>算法<ul>
<li>对长作业比较有利，但对短作业不利</li>
</ul>
</li>
<li><code>时间片轮转调度法</code><ul>
<li>每个进程只能运行一个时间片</li>
<li>时间片的大小对系统性能的影响很大，时间片过大就和先来先服务算法一样，时间片过小会导致进行切换开销大</li>
</ul>
</li>
<li><code>短作业优先调度算法</code><ul>
<li>对长作业不利，不能保证紧迫性作业（进程）被及时处理</li>
</ul>
</li>
<li><code>最短剩余时间优先</code><ul>
<li>允许抢占，总是选择预期剩余时间最短的进程</li>
</ul>
</li>
<li><code>高响应比优先调度算法</code><ul>
<li>R=(w+s)/s （R 为响应比，w 为等待处理的时间，s 为预计的服务时间），选择 R 最大的进行执行</li>
</ul>
</li>
<li><code>优先级调度算法</code><ul>
<li>进程优先级可以分为静态优先级和动态优先级</li>
</ul>
</li>
<li><code>多级反馈队列调度算法</code><ul>
<li>分为多个队列，每个队列中按时间片轮转调度算法来进行进程调度，每一级的队列时间片大小也不一样，如果进行在第一个队列的时间片内没有完成，就会进入第二个队列，以此类推，只有当第一个队列为空才执行第二个队列的进行</li>
<li>短作业有限且长作业不会太长时间不被处理</li>
</ul>
</li>
</ul>
<h5 id="11-磁盘调度算法"><a href="#11-磁盘调度算法" class="headerlink" title=".11. 磁盘调度算法"></a>.11. 磁盘调度算法</h5><ul>
<li><code>先来先服务算法（FCFS）</code><ul>
<li>根据进程请求访问磁盘的先后次序进行调度</li>
<li>优点是公平、简单</li>
<li>缺点是吞吐量低，寻道时间长</li>
</ul>
</li>
<li><code>最短寻道时间优先算法（SSTF）</code><ul>
<li>访问与当前磁头所在的磁道距离最近的磁道</li>
<li>优点是可以得到比较好的吞吐量</li>
<li>缺点是对内外边缘磁道的请求将会被无限延迟</li>
</ul>
</li>
<li><code>扫描算法（SCAN）电梯调度算法</code><ul>
<li>优先考虑磁头当前的移动方向，再考虑欲访问的磁道与当前磁道的距离</li>
<li>优点是避免了饥饿现象的出现</li>
<li>缺点是两侧磁道被访问的频率仍低于中间磁道</li>
</ul>
</li>
<li><code>循环扫描算法（CSCAN）</code><ul>
<li>在 SCAN 算法的基础上，磁头只单向移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道</li>
<li>优点是访问请求均匀分布</li>
</ul>
</li>
</ul>
<h5 id="12-页面调度算法"><a href="#12-页面调度算法" class="headerlink" title=".12. 页面调度算法"></a>.12. 页面调度算法</h5><ul>
<li><code>先进先出调度算法</code>（FIFO，First In First Out）</li>
<li><code>最近最少使用算法</code>(LFU, Least Frequently Used)</li>
<li><code>最近最久未使用算法</code>（LRU，Least Recently Used）</li>
<li><code>时钟置换算法</code>—— 为每一页设置访问位和修改位，将内存中所有页面通过连接指针接成循环队列，当页面被访问时访问位置 1，被修改则修改位置 1，每次淘汰时，从指针当前位置开始循环遍历，第一次寻找访问位和修改位都为 0 的页面，如果没有则将扫描过的节点访问位为 1 的置为 0，找到第一个访问位为 0 的将其淘汰。这个算法的原则就的在 LRU 的基础上偏向于淘汰未被修改的页面。</li>
<li><code>最佳置换算法</code> —— 理想算法，找一个未来最长时间才会被访问的页面进行淘汰。</li>
</ul>
<h5 id="13-IO多路复用"><a href="#13-IO多路复用" class="headerlink" title=".13. IO多路复用"></a>.13. IO多路复用</h5><blockquote>
<p>Linux 的 IO 访问通常是<code>先将数据拷贝到操作系统的内核缓冲区</code>，然后再从内核缓冲区拷贝到<code>应用程序的地址空间</code>。在这两个阶段中，有不同的 IO 方式，主要分<code>为阻塞 IO、非阻塞 IO、异步 IO 以及 IO 多路复用</code>。</p>
</blockquote>
<ul>
<li>阻塞 IO : 即当数据还未准备好，也就是<code>数据还在操作系统的内核缓存区</code>时，用户进程就会一直阻塞，等待数据从操作系统内核缓冲区拷贝到应用程序的地址空间。阻塞 IO 在这两个阶段都是阻塞的。</li>
</ul>
<ul>
<li>非阻塞 IO:  则是如果数据还没准备好，操作系统会给应用程序返回一个 error，并<code>不阻塞应用程序</code>，而一般应用程序会持续询问内核数据是否准备好，所以从另一个角度来说也是阻塞的。</li>
</ul>
<ul>
<li>异步 IO: 才是真正的不阻塞，当用户程序发起 read 后，<code>操作系统会立即进行回复，这样用户程序就可以去做其他事情</code>，当数据被拷贝到用户程序的地中空间后，操作系统会给用户程序发一个信号，而用户程序可以采用<code>回调函数</code>的方式对这个信号进行响应。</li>
</ul>
<ul>
<li>IO 多路复用: 则是<code>允许一个程序同时等待多个文件描述符</code>，当任意一个文件描述符就绪，select 函数就会返回，当然 IO 多路复用在本质上还术语阻塞 IO，只不过可以同时进行多个 IO 操作。</li>
</ul>
<h5 id="13-Linux-的-IO-多路复用机制中有-select、poll、epoll-三种，"><a href="#13-Linux-的-IO-多路复用机制中有-select、poll、epoll-三种，" class="headerlink" title=".13. Linux 的 IO 多路复用机制中有 select、poll、epoll 三种，"></a>.13. Linux 的 IO 多路复用机制中有 select、poll、epoll 三种，</h5><ul>
<li>select 和 poll 的时间复杂度都是 O (n), 因为他们都是在对<code>IO 列表进行轮询</code>，不同点在于 <code>select 能监视的文件描述符</code>有上限，一般为 1024，当然这个是在 Linux 内核中进行的宏定义，是可以修改的，而<code>poll 是基于链表来存储的</code>，所以没有这个上限。</li>
<li><code>epoll 是基于事件驱动</code>的，所以不需要轮询，epoll 会把事件和每一个 IO 流对应起来。并且 epoll 是通过一块<code>共享内存来实现内核空间和用户空间的通信</code>的，比起 select 和 poll 的大量数据拷贝效率更高。</li>
<li>不过 lect 的优点在于兼容不同的操作系统，而 poll 和 epoll 都只能在 linux 上使用。</li>
</ul>
<h5 id="14-操作系统作用"><a href="#14-操作系统作用" class="headerlink" title=".14.  操作系统作用"></a>.14.  操作系统作用</h5><ul>
<li><code>进程管理</code>: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在<code>多核</code>处理器下，操作系统除了要为进程<code>分配任务</code>外，还要解决<code>处理器的调度</code>、<code>分配和回收</code>等问题</li>
<li><code>内存管理</code>：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成时回收内存，协调内存资源，通过合理的页面置换算法进行页面的换入换出</li>
<li><code>设备管理</code>：根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</li>
<li><code>文件管理</code>：有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</li>
<li><code>提供用户接口</code>：操作系统提供了访问应用程序和硬件的接口，使用户能够通过应用程序发起系统调用从而操纵硬件，实现想要的功能。</li>
</ul>
<h5 id="15-IO-访问方式"><a href="#15-IO-访问方式" class="headerlink" title="15. IO 访问方式"></a>15. IO 访问方式</h5><ul>
<li><code>直接访问</code>：直接访问由用户进程直接控制主存或 CPU 和外围设备之间的信息传送。直接程序控制方式又称为忙 / 等待方式。</li>
<li><code>中断驱动</code>：为了减少程序直接控制方式下 CPU 的等待时间以及提高系统的并行程度，系统引入了中断机制。中断机制引入后，<code>外围设备仅当操作正常结束或异常结束时才向 CPU 发出中断请求</code>。在 I/O 设备输入每个数据的过程中，由于无需 CPU 的干预，一定程度上实现了 CPU 与 I/O 设备的并行工作。</li>
</ul>
<p>上述两种方法的特点都是以 <code>CPU</code> 为中心，数据传送通过一段程序来实现，软件的传送手段限制了数据传送的速度。接下来介绍的这两种 I/O 控制方式采用硬件的方法来显示 I/O 的控制</p>
<ul>
<li><code>DMA 直接内存访问</code>：为了进一步减少 CPU 对 I/O 操作的干预，防止因并行操作设备过多使 CPU 来不及处理或因速度不匹配而造成的数据丢失现象，引入了 DMA 控制方式。</li>
<li><code>通道控制方式</code>：通道，独立于 CPU 的专门负责输入输出控制的处理机，它控制设备与内存直接进行数据交换。有自己的通道指令，这些指令由 CPU 启动，并在操作结束时向 CPU 发出中断信号。</li>
</ul>
<h5 id="16-存储方面管理"><a href="#16-存储方面管理" class="headerlink" title="16. 存储方面管理"></a>16. 存储方面管理</h5><ul>
<li><code>主存空间的分配和去配</code>，以主存空间分配表为依据作主存分配，并在作业撤离后回收主存空间。</li>
<li>实现<code>逻辑地址到绝对地址的转换</code>，这种转换需要与硬件配合完成。</li>
<li>主存空间的<code>共享与保护</code>。</li>
<li><code>主存空间的扩充</code>，采用某些技术，为用户提供一个虚拟存储器。</li>
</ul>
<blockquote>
<p>(1) 程序执行时访问属于自己主存区域中的信息，允许它既可读，又可写。</p>
<p>(2) 对共享区域中的信息只可读，不可修改。</p>
<p>(3) 对非共享区或非自己的主存区域中的信息既不可读，也不可写</p>
</blockquote>
<h5 id="17-文件系统结构"><a href="#17-文件系统结构" class="headerlink" title="17. 文件系统结构"></a>17. 文件系统结构</h5><ul>
<li><code>目录管理</code>。利用目录结构检索文件，并能保证文件的安全。</li>
<li><code>文件的组织</code>。文件组织分两类：<code>逻祖结构和物理结构</code>，前者是从<code>用户使用</code>的角度织织文件，后者是<code>存储介质</code>上的文件构造方式。当用户请求读写文件时，文件系统必须实现文件逻辑结构与物理结构之间的转换。</li>
<li>文件<code>存储空间的管理</code>。主要是对磁盘空闲区的管理，执行分配和回收工作。</li>
<li><code>文件操作</code>，为用户提供文件操作功能。主要有建立文件、打开文件、读文件、写文件、关闭文件和删除文件等。</li>
<li><code>文件共享、保护和保密</code>。对共亭文件进行同步控制，防止文件被破坏，被剽窃。</li>
</ul>
<h5 id="18-多用户同时共享文件"><a href="#18-多用户同时共享文件" class="headerlink" title="18. 多用户同时共享文件"></a>18. 多用户同时共享文件</h5><ul>
<li>允许多个用户<code>同时打开共享文件，执行读操作</code>；</li>
<li><code>不允许</code>读者和写者同时使用共享文件；</li>
<li><code>不允许多个写者</code>同时对共享文件执行写操作。</li>
<li>存储设备： 块； 输入输出设备信息传输单位：字符；</li>
<li>独占设备； 共享设备</li>
</ul>
<h4 id="4-Linux-系统"><a href="#4-Linux-系统" class="headerlink" title="4. Linux 系统"></a>4. Linux 系统</h4><h5 id="1-linux操作系统启动过程"><a href="#1-linux操作系统启动过程" class="headerlink" title=".1. linux操作系统启动过程"></a>.1. linux操作系统启动过程</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220228130812455.png" alt=""></p>
<ul>
<li><p><code>内核引导</code>当计算机打开电源后，首先是<code>BIOS开机自检</code>，按照BIOS中设置的启动设备（通常是硬盘）来启动。<code>操作系统接管硬件</code>以后，首先<code>读入 /boot 目录下的内核文件</code>。</p>
</li>
<li><p><code>运行init</code>：init 进程是系统所有进程的起点，init 程序首先是需要读取配置文件 <code>/etc/inittab</code>。</p>
</li>
<li><p><code>运行级别</code>：ctrl+alt+F1–F6  切换到相应的终端</p>
<p>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</p>
<p>运行级别1：<code>单用户工作状态</code>，<code>root权限</code>，用于系统维护，禁止远程登陆`</p>
<p>运行级别2：<code>多用户状态(没有NFS)</code></p>
<p>运行级别3：<code>完全的多用户状态(有NFS)</code>，登陆后进入<code>控制台命令行模式</code></p>
<p>运行级别4：系统未使用，保留</p>
<p>运行级别5：<code>X11控制台</code>，登陆后进入<code>图形GUI模式</code></p>
<p>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</p>
</li>
</ul>
<h5 id="2-软连接和硬链接"><a href="#2-软连接和硬链接" class="headerlink" title=".2. 软连接和硬链接"></a>.2. 软连接和硬链接</h5><ul>
<li>硬链接：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即<code>一个 inode 节点对应两个不同的文件名</code>，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。如果<code>删除了其中一个，对另外一个没有影响</code>。<code>每增加一个文件名，inode 节点上的链接数增加一</code>，每删除一个对应的文件名，inode 节点上的链接数减一，直到为 0，inode 节点和对应的数据块被回收</li>
<li>软连接：没有任何文件系统的限制，任何用户可以创建指向目录的符号链接; 看作是<code>Windows 中的快捷方式</code>，可以让你快速链接到目标档案或目录。</li>
</ul>
<blockquote>
<ul>
<li>硬链接不可以<code>跨分区</code>，软件链可以跨分区。</li>
<li>不能对目录创建硬链接；不能对不同的文件系统创建硬链接；不能对不存在的文件创建硬链接</li>
<li>可以对目录创建软连接；可以跨文件系统；可以对不存在的文件创建软连接</li>
</ul>
</blockquote>
<blockquote>
<p><code>RAID 全称为独立磁盘冗余阵列</code> (Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。</p>
</blockquote>
<h5 id="3-Linux-一切皆文件"><a href="#3-Linux-一切皆文件" class="headerlink" title=".3. Linux 一切皆文件"></a>.3. Linux 一切皆文件</h5><blockquote>
<p><strong>Linux 中所有内容都是以文件的形式保存和管理，包括一切软硬件。</strong> 这样做最明显的好处是，开发者仅需要一套 API 和开发工具即可调取 Linux 系统中绝大部分的资源。同时也带来不利之处，如使用任何硬件设备都必须与根目录下某一目录执行挂载操作，否则无法使用。</p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220228133441585.png" alt=""></p>
<h5 id="4-Linux-负载过高"><a href="#4-Linux-负载过高" class="headerlink" title=".4. Linux 负载过高"></a>.4. Linux 负载过高</h5><blockquote>
<p><strong>系统平均负载</strong>被定义为在特定时间间隔内运行队列中（在 CPU 上运行或者等待运行多少进程）的平均进程数。如果一个进程满足以下条件则其就会位于运行队列中：</p>
<ul>
<li>它没有在等待 I/O 操作的结果</li>
<li>它没有主动进入等待状态（没有调用 <code>wait</code>）</li>
<li>没有被停止 (如等待终止)</li>
</ul>
<p>在 Linux 中，进程分为三种状态，一种是<code>阻塞的进程</code>（blocked process），一种是<code>可运行的进程</code>（runnable process），另外就是<code>正在运行的进程</code>（running process）</p>
</blockquote>
<ul>
<li>通过命令 <code>ps ux</code> 排查哪些进程 cpu 占用率高；</li>
<li>查看对应 java 进程的<code>每个线程的 CPU 占用率</code>。通过命令 <code>ps -Lp 15047 cu</code>；</li>
<li><code>追踪线程内部</code>，查看 load 过高原因。通过命令 <code>jstack 15047</code>,查找到对应的 threadid，再反查代码。</li>
</ul>
<h5 id="5-inode-节点表"><a href="#5-inode-节点表" class="headerlink" title=".5. inode 节点表"></a>.5. inode 节点表</h5><p>Linux 通过 inode 节点表将文件的<code>逻辑结构和物理结构</code>进行转换。</p>
<ul>
<li>inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有<code>文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息</code>。在 inode 节点表中最重要的内容是<code>磁盘地址表</code>。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。</li>
<li>Linux 文件系统通过把<code>inode 节点和文件名进行连接</code>，当需要读取该文件时，文件系统在当<code>前目录表中查找该文件名对应的项</code>，由此得到<code>该文件相对应的 inode 节点号</code>，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。</li>
</ul>
<h5 id="6-网站访问过慢"><a href="#6-网站访问过慢" class="headerlink" title=".6. 网站访问过慢"></a>.6. 网站访问过慢</h5><ul>
<li>服务器出口带宽不够用<ul>
<li><code>本身服务器购买的出口带宽比较小</code>。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。</li>
<li><code>跨运营商网络导致带宽缩减</code>。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。</li>
</ul>
</li>
<li>服务器负载过大，导致响应不过来<ul>
<li>分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果<code>负载很高，则使用 top 命令查看 CPU</code> ，<code>MEM 等占用情况</code>，要么是 <code>CPU 繁忙，要么是内存不够</code></li>
<li>如果这二者都正常，再去使用 sar 命令分析<code>网卡流量，分析是不是遭到了攻击</code>。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。</li>
</ul>
</li>
<li>数据库瓶颈<ul>
<li>如果<code>慢查询比较多</code>。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li>
<li>如果<code>数据库响应慢，考虑可以加一个数据库缓存</code>，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li>
</ul>
</li>
<li>网站开发代码没有优化好<ul>
<li>SQL 语句没有优化，导致数据库读写相当耗时。</li>
</ul>
</li>
</ul>
<h5 id="7-网站访问慢，排查思路"><a href="#7-网站访问慢，排查思路" class="headerlink" title=".7. 网站访问慢，排查思路"></a>.7. 网站访问慢，排查思路</h5><p>1、首先要确定是<code>用户端还是服务端</code>的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。</p>
<blockquote>
<p>不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。</p>
</blockquote>
<p>2、如果访问也慢，那么可以利用浏览器的调试功能，看看<code>加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。</code></p>
<p>3、针对<code>服务器负载</code>情况。查看<code>服务器硬件 (网络、CPU、内存) 的消耗情况</code>。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。</p>
<p>4、如果发现<code>硬件资源消耗都不</code>高，那么就需要通过查<code>日志，比如看看 MySQL 慢查询的日志</code>，看看是不是某条 SQL 语句查询慢，导致网站访问慢。</p>
<h5 id="8-Linux-内核分类"><a href="#8-Linux-内核分类" class="headerlink" title=".8. Linux 内核分类"></a>.8. Linux 内核分类</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20201117203235695.png" alt=""></p>
<blockquote>
<pre class=" language-shell"><code class="language-shell">tail +99 file1 | head -1  # tail 和head的用法， watch 命令监视，或者tail -f</code></pre>
</blockquote>
<h5 id="9-top-命令"><a href="#9-top-命令" class="headerlink" title=".9. top 命令"></a>.9. top 命令</h5><p>PID：进程的 ID<br>　　USER：进程所有者<br>　　PR：进程的优先级别，越小越优先被执行<br>　　NInice：值<br>　　VIRT：进程占用的虚拟内存<br>　　RES：进程占用的物理内存<br>　　SHR：进程使用的共享内存<br>　　S：进程的状态。S 表示休眠，R 表示正在运行，Z 表示僵死状态，N 表示该进程优先值为负数<br>　　<code>% CPU：进程占用 CPU 的使用率</code><br>　　<code>% MEM：进程使用的物理内存和总内存的百分比</code><br>　　TIME+：该进程启动后占用的总的 CPU 时间，即占用 CPU 使用时间的累加值。<br>　　COMMAND：进程启动命令名称</p>
<h5 id="10-通信手段"><a href="#10-通信手段" class="headerlink" title=".10. 通信手段"></a>.10. 通信手段</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220303150029243.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220303150040804.png" alt=""></p>
<h5 id="11-编译链接"><a href="#11-编译链接" class="headerlink" title=".11. 编译链接"></a>.11. 编译链接</h5><p><img src="../../../../../picture2022/image-20220304125924326.png" alt=""></p>
<h5 id="12-编译过程"><a href="#12-编译过程" class="headerlink" title=".12. 编译过程"></a>.12. 编译过程</h5><ul>
<li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）</li>
<li>编译（编译器进行<code>词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化</code>，生成 <code>.s</code> 文件）</li>
<li>汇编（汇编器把<code>汇编码翻译成机器码</code>，生成 <code>.o</code> 文件）</li>
<li>链接（<code>连接器进行地址和空间分配、符号决议、重定位</code>，生成 <code>.out</code> 文件）</li>
</ul>
<h5 id="13-Linux-共享库"><a href="#13-Linux-共享库" class="headerlink" title=".13. Linux 共享库"></a>.13. Linux 共享库</h5><ul>
<li>路径:<ul>
<li><code>/lib</code>：存放<code>系统最关键和最基础的共享库</code>，如动态链接器、C 语言运行库、数学库等</li>
<li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是<code>开发库</code></li>
<li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些<code>第三方应用程序的库</code></li>
<li>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</li>
</ul>
</li>
<li>环境变量<ul>
<li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li>
<li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li>
<li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li>
</ul>
</li>
</ul>
<h5 id="14-find-package-原理"><a href="#14-find-package-原理" class="headerlink" title=".14. find_package 原理"></a>.14. find_package 原理</h5><blockquote>
<p>find_package 采用两种模式搜索库：</p>
<ul>
<li><strong>Module 模式</strong>：搜索 <strong>CMAKE_MODULE_PATH</strong> 指定路径下的 <strong>FindXXX.cmake</strong> 文件，执行该文件从而找到 XXX 库。其中，具体查找库并给 <strong>XXX_INCLUDE_DIRS</strong> 和 <strong>XXX_LIBRARIES</strong> 两个变量赋值的操作由 FindXXX.cmake 模块完成。</li>
<li><strong>Config 模式</strong>：搜索 <strong>XXX_DIR</strong> 指定路径下的 <strong>XXXConfig.cmake</strong> 文件，执行该文件从而找到 XXX 库。其中具体查找库并给 <strong>XXX_INCLUDE_DIRS</strong> 和 <strong>XXX_LIBRARIES</strong> 两个变量赋值的操作由 XXXConfig.cmake 模块完成。</li>
</ul>
</blockquote>
<pre class=" language-makefile"><code class="language-makefile">set<span class="token punctuation">(</span>Caffe_DIR /home/wjg/projects/caffe/build<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#添加CaffeConfig.cmake的搜索路径</span>
find_package<span class="token punctuation">(</span>Caffe REQUIRED<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 这个命令</span>
if <span class="token punctuation">(</span>NOT Caffe_FOUND<span class="token punctuation">)</span>
    message<span class="token punctuation">(</span>FATAL_ERROR <span class="token string">"Caffe Not Found!"</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span> <span class="token punctuation">(</span>NOT Caffe_FOUND<span class="token punctuation">)</span>
include_directories<span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">{</span>Caffe_INCLUDE_DIRS<span class="token punctuation">}</span><span class="token punctuation">)</span>
add_executable<span class="token punctuation">(</span>useSSD ssd_detect.cpp<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 添加可执行文件</span>
target_link_libraries<span class="token punctuation">(</span>useSSD <span class="token variable">$</span><span class="token punctuation">{</span>Caffe_LIBRARIES<span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 连接所需要的库文件</span>

<span class="token comment" spellcheck="true"># 创建共享库（把工程内的cpp文件都创建成共享库文件，方便通过头文件来调用）</span>
add_library<span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">{</span>PROJECT_NAME<span class="token punctuation">}</span> SHARED
src/cpp文件名
……
）
<span class="token comment" spellcheck="true"># 头文件</span>
include_directories<span class="token punctuation">(</span><span class="token string">"路径"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># 把刚刚生成的${PROJECT_NAME}库和所需的其它库链接起来</span>
target_link_libraries<span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">{</span>PROJECT_NAME<span class="token punctuation">}</span>
/usr/lib/i386-linux-gnu/libboost_system.so</code></pre>
<h5 id="15-Linux-管道命令"><a href="#15-Linux-管道命令" class="headerlink" title="15. Linux 管道命令"></a>15. Linux 管道命令</h5><blockquote>
<p>管道是一种通信机制，通常用于进程间的通信（也可通过 socket 进行网络通信），它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）</p>
</blockquote>
<h5 id="16-Linux-常用命令"><a href="#16-Linux-常用命令" class="headerlink" title="16. Linux 常用命令"></a>16. Linux 常用命令</h5><ul>
<li>which, find, whereis, cat</li>
<li>sed, awk, head, tail 查看大文件</li>
<li>free 查看内存</li>
</ul>
<h6 id="1-top"><a href="#1-top" class="headerlink" title=".1. top"></a>.1. top</h6><p><img src="../../../../../picture2022/image-20220317193155375.png" alt=""></p>
<ol>
<li><p>第一行，<code>任务队列信息</code>，同 uptime 命令的执行结果，具体参数说明情况如下：</p>
<p>00:12:54 — 当前系统时间</p>
<p>up ？days, 4:49 — 系统<code>已经运行了？天 4 小时 49 分钟</code>（在这期间系统没有重启过）</p>
<p>21users — <code>当前有 1 个用户登录系统</code></p>
<p>load average: 0.06, 0.02, 0.00 — load average 后面的三个数分别是<code>1 分钟、5 分钟、15 分钟</code>的负载情况。load average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。</p>
</li>
<li><p>第二行，<code>Tasks — 任务（进程）</code>，具体信息说明如下：</p>
<p>系统现在共有 <code>256 个进程</code>，其中处于运行中的有 1 个，177 个在休眠（sleep），stoped 状态的有 0 个，zombie 状态（僵尸）的有 0 个。</p>
</li>
<li><p>第三行，<code>cpu 状态信息</code>，具体属性说明如下：</p>
<p>0.2% us — <code>用户空间</code>占用 CPU 的百分比。</p>
<p>0.2% sy — <code>内核空间</code>占用 CPU 的百分比。</p>
<p>0.0% ni — 改变过优先级的进程占用 CPU 的百分比</p>
<p>99.5% id — 空闲 CPU 百分比</p>
<p>0.0% wa —<code>IO 等待</code>占用 CPU 的百分比</p>
<p>0.0% hi —<code>硬中断（Hardware IRQ）</code>占用 CPU 的百分比</p>
<p>0.0% si —<code>软中断（Software Interrupts）</code>占用 CPU 的百分比</p>
</li>
<li><p>第四行，<code>内存状态</code>，具体信息如下：</p>
<p>2017552 total — 物理内存总量</p>
<p>720188 used — 使用中的内存总量</p>
<p>197916 free — 空闲内存总量</p>
<p>1099448 cached — <code>缓存的总量</code></p>
</li>
<li><p>第五行，<code>swap 交换分区信息</code>，具体信息说明如下：</p>
<p>998396 total — 交换区总量</p>
<p>989936 free — 空闲交换区总量</p>
<p>8460 used — 使用的交换区总量</p>
<p>1044136 cached — 缓冲的交换区总量</p>
</li>
</ol>
<h6 id="2-查看端口和进程"><a href="#2-查看端口和进程" class="headerlink" title=".2. 查看端口和进程"></a>.2. 查看端口和进程</h6><ul>
<li>先查看进程 <code>pid: ps -ef | grep 进程名</code></li>
<li>通过 pid 查看占用端口: <code>netstat -nap | grep 进程pid</code></li>
<li>直接通过端口查进程： <code>netstat -nap | grep 端口号</code></li>
</ul>
<h5 id="17-查看已经打开的文件"><a href="#17-查看已经打开的文件" class="headerlink" title="17. 查看已经打开的文件"></a>17. 查看已经打开的文件</h5><blockquote>
<p>lsof (list open files) 是一个<code>列出当前系统打开文件的工具</code>。在 linux 环境下，任何事物都以文件的形式存在，通过<code>文件不仅仅可以访问常规数据，还可以访问网络连接和硬件</code>。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该<code>文件描述符fd为应用程序与基础操作系统之间的交互提供了通用接口</code>。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过 lsof 工具能够查看这个列表对系统监测以及排错将是很有帮助的。</p>
</blockquote>
<h5 id="18-文件系统"><a href="#18-文件系统" class="headerlink" title="18. 文件系统"></a>18. 文件系统</h5><ul>
<li>Windows：FCB 表 + FAT + 位图</li>
<li>Unix：<code>inode + 混合索引 + 成组链接</code></li>
</ul>
<p><img src="../../../../../picture2022/image-20220305184924346.png" alt=""></p>
<h5 id="19-大端地址-amp-小端地址"><a href="#19-大端地址-amp-小端地址" class="headerlink" title="19. 大端地址&amp;小端地址"></a>19. 大端地址&amp;小端地址</h5><p>主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 <code>CPU 指令集架构</code>决定的。主机字节序分为两种：</p>
<ul>
<li><code>大端字节序</code>（Big Endian）：<code>高序字节存储在低位地址</code>，低序字节存储在高位地址</li>
<li><code>小端字节序（</code>Little Endian）：高序字节存储在<code>高位</code>地址，低序字节存储在低位地址</li>
</ul>
<p><img src="../../../../../picture2022/v2-39ce3e66f9db750881e668e1159780e6_720w.jpg" alt=""></p>
<ul>
<li>x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；</li>
<li>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；</li>
<li>ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。</li>
</ul>
<h5 id="20-通道"><a href="#20-通道" class="headerlink" title="20. 通道"></a>20. 通道</h5><ul>
<li><code>单向通道（单工通道）</code>：只有一个方向通信，没有反方向交互，如广播</li>
<li>双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li>
<li><code>双向同时通信（全双工通信）</code>：通信双方可以同时发送和接收信息</li>
</ul>
<h5 id="20-通道复用计数"><a href="#20-通道复用计数" class="headerlink" title="20. 通道复用计数"></a>20. 通道复用计数</h5><ul>
<li><code>频分复用</code>（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li>
<li><code>时分复用（</code>TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li>
<li><code>波分复用</code>（WDM，Wavelength Division Multiplexing）：光的频分复用</li>
<li><code>码分复用</code>（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li>
</ul>
<h5 id="21-操作系统malloc的实现原理"><a href="#21-操作系统malloc的实现原理" class="headerlink" title="21. 操作系统malloc的实现原理"></a>21. 操作系统malloc的实现原理</h5><blockquote>
<p>当开辟的空间小于 128K 时，调用 brk（）函数；当<code>开辟的空间大于 128K 时，调用 mmap（）</code>。malloc 采用的是<code>内存池的管理方式，以减少内存碎片</code>。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用<code>隐式链表将所有空闲块</code>，每一个空闲块记录了一个未分配的、连续的内存地址。</p>
</blockquote>
<h5 id="22-Zore-Copy-实现机制"><a href="#22-Zore-Copy-实现机制" class="headerlink" title="22. Zore Copy 实现机制"></a>22. Zore Copy 实现机制</h5><blockquote>
<p>“零拷贝”：在整个发送数据过程中，数据的复制是必不可少的，这里数据复制分两种类型，一种是 <code>CPU 参与的一个字节一个字节处理的数据复制</code>，一个是<code>CPU 不用参与，通过专有硬件 DMA 参与的，批量数据复制。</code></p>
</blockquote>
<h5 id="23-mmap-实现的零拷贝-I-O"><a href="#23-mmap-实现的零拷贝-I-O" class="headerlink" title="23. mmap 实现的零拷贝 I/O"></a>23. mmap 实现的零拷贝 I/O</h5><blockquote>
<p><strong>原理</strong>：<strong>mmap 是一种内存映射文件的方法</strong>，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read, write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
</blockquote>
<p><img src="../../../../../picture2022/image-20220309213639693.png" alt=""></p>
<p><img src="../../../../../picture2022/image-20220309214141726.png" alt=""></p>
<ul>
<li>mmap 系统调用，导致<code>用户空间到内核空间的上下文切换</code> (第一次上下文切换)。通过 DMA 引擎将<code>磁盘文件</code>中的内容拷贝到<code>内核空间缓冲区</code>中 (第一次拷贝: hard drive ——&gt; kernel buffer)。</li>
<li>mmap 系统<code>调用返回</code>，导致<code>内核空间到用户空间的上下文切换</code> (第二次上下文切换)。接着<code>用户空间和内核空间共享这个缓冲区</code>，而不需要将数据从内核空间拷贝到用户空间。因为用户空间和内核空间<code>共享</code>了这个缓冲区数据，所以用户空间就可以像在操作自己缓冲区中数据一般操作这个由内核空间共享的缓冲区数据</li>
<li>发出 write 系统调用，<code>导致用户空间到内核空间的上下文切换</code> (第三次上下文切换)。将<code>数据从内核空间缓冲区拷贝到内核空间 socket 相关联的缓冲区</code> (第二次拷贝: kernel buffer ——&gt; socket buffer)。</li>
<li>write 系统调用返回，导致<code>内核空间到用户空间的上下文切换</code> (第四次上下文切换)。通过 <code>DMA 引擎将内核空间 socket 缓冲区中的数据传递到协议引擎</code> (第三次拷贝: socket buffer ——&gt; protocol engine</li>
<li>通过 mmap 实现的零拷贝 I/O 进行了 4 次用户空间与内核空间的上下文切换，以及 3 次数据拷贝。其中 3 次数据拷贝中包括了 2 次 DMA 拷贝和 1 次 CPU 拷贝</li>
</ul>
<h5 id="23-Linux-IO-流程-todo"><a href="#23-Linux-IO-流程-todo" class="headerlink" title="23. Linux IO 流程  todo"></a>23. Linux IO 流程  todo</h5><blockquote>
<p>应用程序代码运行在<code>用户模式</code>下，当应用程序需要实现<code>内核模式下的指令</code>时，先向<code>操作系统发送调用请``求</code>。操作系统收到请求后，执行系<code>统调用接口</code>，使处理器进入<code>内核模式</code>。当处理器处理完系统调用操作后，操作系统会让处理器返回用户模式，继续执行用户代码。</p>
<p><code>进程的虚拟地址空间</code>可分为两部分，<code>内核空间和用户空间</code>。内核空间中存放的是<code>内核代码和数据</code>，而进程的用户空间中存放的是<code>用户程序的代码和数据</code>。不管是内核空间还是用户空间，它们都处于<code>虚拟空间中，都是对物理地址的映射</code>。</p>
</blockquote>
<h5 id="23-Linux-虚拟文件系统"><a href="#23-Linux-虚拟文件系统" class="headerlink" title="23. Linux 虚拟文件系统"></a>23. Linux 虚拟文件系统</h5><blockquote>
<p>一个操作系统可以支持多种底层不同的文件系统（比如<code>NTFS, FAT, ext3, ext4</code>），为了给内核和用户进程提供统一的<code>文件系统视图</code>，Linux 在<code>用户进程和底层文件系统之间加入了一个抽象层</code>，即虚拟文件系统 (Virtual File System, VFS)，进程所有的文件操作都通过 VFS，<code>由 VFS 来适配各种底层不同的文件系统，完成实际的文件操作。</code></p>
</blockquote>
<p><img src="../../../../../picture2022/image-20220306213605105.png" alt=""></p>
<h5 id="24-虚拟文件系统主要模块"><a href="#24-虚拟文件系统主要模块" class="headerlink" title="24. 虚拟文件系统主要模块"></a>24. 虚拟文件系统主要模块</h5><ul>
<li><code>超级块（super_block）</code>，用于保存<code>一个文件系统的所有元数据</code>，相当于这个文件系统的信息库，为其他的模块提供信息。因此一个超级块可代表一个文件系统。文件系统的任意元数据修改都要修改超级块。超级块对象是常驻内存并被缓存的。</li>
<li><code>目录项模块</code>，管<code>理路径的目录项</code>。比如一个路径 /home/foo/hello.txt，那么目录项有 home, foo, hello.txt。目录项的块，存储的是<code>这个目录下的所有的文件的 inode 号和文件名等信息</code>。其内部是树形结构，操作系统检索一个文件，都是从根目录开始，按层次解析路径中的所有目录，直到定位到文件。</li>
<li><code>inode 模块</code>，管理一个<code>具体的文件</code>，是<code>文件的唯一标识</code>，<code>一个文件对应一个 inode</code>。通过 inode 可以方便的找到文件在磁盘扇区的位置。同时 <code>inode 模块可链接到 address_space 模块</code>，方便查找自身文件数据是否已经缓存。</li>
<li><code>打开文件列表模块</code>，包含所有内核已经打开的文件。已经打开的文件对象由<code>open 系统调用在内核中创建，也叫文件句柄</code>。打开文件列表模块中包含一个列表，每个列表表项是一个结构体 struct file，结构体中的信息用来表示打开的一个文件的各种状态参数。</li>
<li>file_operations 模块。这个模块中维护一个数据结构，是一系列函数指针的集合，其中包含所有可以使用的系统调用函数，例如 open、read、write、mmap 等。每个打开文件（打开文件列表模块的一个表项）都可以连接到 file_operations 模块，从而对任何已打开的文件，通过系统调用函数，实现各种操作。</li>
<li>address_space 模块，它表示一个文件在页缓存中已经缓存了的物理页。它是页缓存和外部设备中文件系统的桥梁。如果将文件系统可以理解成数据源，那么 address_space 可以说关联了内存系统和文件系统。</li>
</ul>
<p><img src="../../../../../picture2022/image-20220306213734398.png" alt=""></p>
<h5 id="23-新建空文件"><a href="#23-新建空文件" class="headerlink" title="23. 新建空文件"></a>23. 新建空文件</h5><ul>
<li><p>新建一个空文件需要消耗掉一个<code>inode</code>，用来保存<code>用户、创建时间等元数据</code>。</p>
</li>
<li><p>新建一个空文件还需要消耗掉其所在<code>目录的 block 中一定的空间</code>，这些空间用来保存文件名，inode 号等信息。</p>
</li>
</ul>
<h5 id="24-一个字节消耗多少"><a href="#24-一个字节消耗多少" class="headerlink" title="24. 一个字节消耗多少"></a>24. 一个字节消耗多少</h5><blockquote>
<p>文件系统是按照<code>inode+block 来组织</code>的，所以不管你的文件多小，哪怕只有一个字节，在数据上都会消耗掉整整一个块 (当然还得算上 inode 等开销)。这个块大小可以通过<code>dumpe2fs</code>等命令来查看。如果想改变这个块大小怎么办？对不起，只能<code>重新格式化</code>。</p>
</blockquote>
<h5 id="24-文件很多时ls变慢"><a href="#24-文件很多时ls变慢" class="headerlink" title="24. 文件很多时ls变慢"></a>24. 文件很多时ls变慢</h5><blockquote>
<p>这就是当你的文件夹下面文件特别多，尤其是文件名也比较长的时候，它会消耗掉非常多的 block。当你遍历文件夹的时候，如果<code>Page Cache 中没有命中你要访问的 block</code>，就会穿透到磁盘上进行实际的 IO。在你的角度来看，就是你执行完<code>ls</code>后，卡住了。</p>
</blockquote>
<h5 id="24-rm-操作原理"><a href="#24-rm-操作原理" class="headerlink" title="24. rm 操作原理"></a>24. rm 操作原理</h5><blockquote>
<p>硬盘就是一个扇区组成的大数组，是无法被我们使用的，需要经过<code>分区、格式化和挂载</code>三个步骤。分区是把所有的扇区按照柱面分割成不同的大块，格式化就把原始的扇区数组变成了可被 Linux 文件系统使用的inode、block 等基本元素了。mkfs: 把我们的连续的磁盘空间进行划分和管理</p>
</blockquote>
<p><img src="../../../../../picture2022/image-20220306215537491.png" alt=""></p>
<p><img src="../../../../../picture2022/image-20220306215837425.png" alt=""></p>
<h5 id="23-什么是Linux-内核"><a href="#23-什么是Linux-内核" class="headerlink" title="23. 什么是Linux 内核"></a>23. 什么是Linux 内核</h5><ul>
<li>系统内存管理</li>
<li>应用程序管理</li>
<li>硬件设备管理</li>
<li>文件系统管理</li>
</ul>
<h5 id="24-交换空间"><a href="#24-交换空间" class="headerlink" title="24. 交换空间"></a>24. 交换空间</h5><ul>
<li>交换空间是 Linux 使用的一定空间，用于临时保存一些并发运行的程序。<code>当 RAM 没有足够的内存来容纳正在执行的所有程序时</code>，就会发生这种情况。</li>
</ul>
<h5 id="23-大文件为什么-cp-比mv-慢"><a href="#23-大文件为什么-cp-比mv-慢" class="headerlink" title="23. 大文件为什么 cp 比mv 慢"></a>23. 大文件为什么 cp 比mv 慢</h5><ul>
<li>cp 命令要把<code>所有的文件地址变量都找到，然后读取内容</code>，然后再<code>另外的文件夹地址下开辟一块内存去储存文件内容</code>。</li>
</ul>
<h5 id="26-给你一个包含-100-亿个-url-的文件，请你找出使用频率最高的-10-个-url，应该怎么做？"><a href="#26-给你一个包含-100-亿个-url-的文件，请你找出使用频率最高的-10-个-url，应该怎么做？" class="headerlink" title="26. 给你一个包含 100 亿个 url 的文件，请你找出使用频率最高的 10 个 url，应该怎么做？"></a>26. 给你一个包含 100 亿个 url 的文件，请你找出使用频率最高的 10 个 url，应该怎么做？</h5><ul>
<li>用<code>哈希分成多个文件</code>，再把这些小文件一次性加到内存用 map，取前 10。最后从每个文件的前 10; MapReduce 工作</li>
</ul>
<h5 id="27-网络中有上亿个-url，每个-url-都有一个-id-唯一标识，现在给你-100-台机器，你会怎么去设计他们的缓存系统？"><a href="#27-网络中有上亿个-url，每个-url-都有一个-id-唯一标识，现在给你-100-台机器，你会怎么去设计他们的缓存系统？" class="headerlink" title="27. 网络中有上亿个 url，每个 url 都有一个 id 唯一标识，现在给你 100 台机器，你会怎么去设计他们的缓存系统？"></a>27. <strong>网络中有上亿个 url，每个 url 都有一个 id 唯一标识，现在给你 100 台机器，你会怎么去设计他们的缓存系统？</strong></h5><ul>
<li>用哈希对流量分组，每台机器承接一定的流量，再搞点负载均衡的策略</li>
</ul>
<h5 id="28-本地机器只有-2-5G，但我想申请-4G-的内存空间，可以做到吗？"><a href="#28-本地机器只有-2-5G，但我想申请-4G-的内存空间，可以做到吗？" class="headerlink" title="28. 本地机器只有 2.5G，但我想申请 4G 的内存空间，可以做到吗？"></a>28. <strong>本地机器只有 2.5G，但我想申请 4G 的内存空间，可以做到吗？</strong></h5><ul>
<li>取决于你的系统总线数量，如果是 <code>32 位的，则最大的可寻址内存空间为 4G</code>，而如 <code>linux 系统还要保留 1G</code>，则不能申请，如果是 64 位的则可以申请</li>
</ul>
<h5 id="29-Kill-某个进程不能被杀死"><a href="#29-Kill-某个进程不能被杀死" class="headerlink" title="29. Kill 某个进程不能被杀死"></a>29. Kill 某个进程不能被杀死</h5><ul>
<li>SIGNKILL（9） 的效果是立即杀死进程。该信号不能被阻塞，处理和忽略。</li>
<li>SIGNTERM（15） 的效果是正常退出进程，退出前可以被阻塞或回调处理。并且它是 Linux 缺省的程序中断信号 (默认是 15)。</li>
<li><code>kill - 9 表示强制杀死该进程</code>；与 SIGTERM 相比，这个信号不能被捕获或忽略，同时接收这个信号的进程在收到这个信号时不能执行任何清理</li>
<li>处于<code>内核态的进程会屏蔽所有信号</code></li>
<li><code>僵死进程也不能被 kill</code></li>
</ul>
<h5 id="30-Debug-原理"><a href="#30-Debug-原理" class="headerlink" title="30. Debug 原理"></a>30. Debug 原理</h5><ul>
<li>JPDA (Java Platform Debugger Architecture),  Debuggge。<code>被调试者</code>。<code>传输纽带</code>  <code>调试者</code></li>
</ul>
<p><img src="../../../../../picture2022/jdwp.jpg" alt=""></p>
<h5 id="31-malloc-出-100M，1G-的内存还剩多少"><a href="#31-malloc-出-100M，1G-的内存还剩多少" class="headerlink" title="31. malloc 出 100M，1G 的内存还剩多少"></a>31. malloc 出 100M，1G 的内存还剩多少</h5><ul>
<li>malloc 100M 内存成功时，其实并没有真实拿到。只有当 100M 内存中的任何一页，被写一次的时候，才成功。</li>
<li>malloc 100M 内存成功时，Linux 把 100M 内存全部以只读的形式，映射到一个全部清 0 的页面</li>
</ul>
<h5 id="32-简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？"><a href="#32-简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？" class="headerlink" title=".32. 简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？"></a>.32. 简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？</h5><ol>
<li><p><strong>物理内存</strong>：物理内存有四个层次，分别是寄存器、高速缓存、主存、磁盘。</p>
<p>寄存器：速度最快、量少、价格贵。</p>
<p>高速缓存：次之。</p>
<p>主存：再次之。</p>
<p>磁盘：速度最慢、量多、价格便宜。</p>
<p>操作系统会对物理内存进行管理，有一个部分称为<strong>内存管理器 (memory manager)</strong>，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。</p>
</li>
<li><p><strong>虚拟内存</strong>：操作系统<code>为每一个进程分配一个独立的地址空间</code>，虚拟内存。虚拟内存与物理内存存在映射关系，通过页表寻址完成虚拟地址和物理地址的转换。</p>
</li>
<li><p><strong>为什么要用虚拟内存</strong>：因为早期的内存分配方法存在以下问题：</p>
<p>（1）<code>进程地址空间不隔离</code>。会导致数据被随意修改。</p>
<p>（2）<code>内存使用效率低</code>。</p>
<p>（3）<code>程序运行的地址不确定</code>。操作系统随机为进程分配内存空间，所以程序运行的地址是不确定的。</p>
</li>
<li><p><strong>使用虚拟内存的好处</strong>：</p>
<p>（1）<code>扩大地址空间</code>。<code>每个进程独占一个 4G 空间，虽然真实物理内存没那么多</code>。</p>
<p>（2）<code>内存保护</code>：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。</p>
<p>（3）可以实现<code>内存共享</code>，方便进程通信。</p>
<p>（4）可以<code>避免内存碎片</code>，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。</p>
</li>
<li><p><strong>使用虚拟内存的缺点</strong>：</p>
<p>（1）虚拟内存需要<code>额外构建数据结构，占用空间</code>。</p>
<p>（2）虚拟地址到物理地址的转换，<code>增加了执行时间</code>。</p>
<p>（3）<code>页面换入换出耗时</code>。</p>
<p>（4）<code>一页如果只有一部分数据，浪费内存</code>。</p>
</li>
</ol>
<h5 id="33-缺页中断"><a href="#33-缺页中断" class="headerlink" title=".33. 缺页中断"></a>.33. 缺页中断</h5><ol>
<li><strong>缺页异常</strong>：malloc 和 mmap 函数在分配内存时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些<code>没有建立映射关系的虚拟内存时</code>，处理器自动触发一个<strong>缺页异常，引发缺页中断</strong>。</li>
<li><strong>缺页中断</strong>：<code>缺页异常后将产生一个缺页中断</code>，此时操作系统会根据页表中的<strong>外存地址</strong>在外存中找到所缺的一页，将其调入<strong>内存</strong>。</li>
</ol>
<h5 id="34-孤儿进程，什么是僵尸进程，如何解决僵尸进程"><a href="#34-孤儿进程，什么是僵尸进程，如何解决僵尸进程" class="headerlink" title=".34. 孤儿进程，什么是僵尸进程，如何解决僵尸进程"></a>.34. 孤儿进程，什么是僵尸进程，如何解决僵尸进程</h5><ol>
<li><strong>孤儿进程</strong>：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。<code>孤儿进程将被 init 进程（进程号为 1）所收养</code>，并且由 init 进程对它们完整状态收集工作。</li>
<li><strong>僵尸进程</strong>：是指<code>一个进程使用 fork 函数创建子进程</code>，如果子进程退出，而<code>父进程并没有调用 wait () 或者 waitpid () 系统调用取得子进程的终止状态</code>，那么<code>子进程的进程描述符仍然保存在系统中</code>，占用系统资源，这种进程称为僵尸进程。<ol>
<li>fork 子进程之后我们都要及时使用 <strong>wait 系统调用</strong></li>
<li><strong>使用 kill 命令</strong>。</li>
</ol>
</li>
</ol>
<h4 id="5-计算机网络"><a href="#5-计算机网络" class="headerlink" title="5. 计算机网络"></a>5. <a href="https://www.eet-china.com/mp/a68780.html" target="_blank" rel="noopener">计算机网络</a></h4><h5 id="1-网络分层结构"><a href="#1-网络分层结构" class="headerlink" title=".1. 网络分层结构"></a>.1. 网络分层结构</h5><blockquote>
<ul>
<li>易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。</li>
<li>有利于标准化的制定</li>
</ul>
</blockquote>
<ul>
<li><code>OSI七层网络</code>，物理层（比特流），数据链路层（相邻节点），网络层(路由交换机），传输层（主机进程），会话层，表示层，应用层</li>
<li><code>TCP/IP五层网络</code>；</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/MBXY-CR-7943d7dc8a2afb50c58f3467d45fa768.png" alt=""></p>
<p><img src="../../../../../picture2022/MBXY-CR-ba1e2d8a01c7492d49d39cb93378550f.png" alt=""></p>
<h5 id="1-IP-地址分类"><a href="#1-IP-地址分类" class="headerlink" title=".1. IP 地址分类"></a>.1. IP 地址分类</h5><ul>
<li>A,B,C,D,E 五类</li>
<li>IP 地址 = 网络号 + 主机号。</li>
</ul>
<h5 id="2-三次握手"><a href="#2-三次握手" class="headerlink" title=".2. 三次握手"></a>.2. 三次握手</h5><blockquote>
<ul>
<li>序号：seq，占 32 位，用来标识从发送端到接收端发送的字节流。</li>
<li>确认号：ack，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1。</li>
<li>标志位：<ul>
<li>SYN：发起一个新连接。</li>
<li>FIN：释放一个连接。</li>
<li>ACK：确认序号有效。</li>
</ul>
</li>
</ul>
</blockquote>
<p>假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是 <code>CLOSED</code>。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220227224749976.png" alt=""></p>
<ol>
<li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个<code>起始序列号 x</code>，客户端向服务端发送的字段中包含<code>标志位</code> <code>SYN=1</code>，<code>序列号</code> <code>seq=x</code>。第一次握手前客户端的状态为 <code>CLOSE</code>，第一次握手后客户端的状态为 <code>SYN-SENT</code>。此时服务端的状态为 <code>LISTEN</code>。</li>
<li>第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号 y，然后给客户端回复一段报文，其中包括标志位 <code>SYN=1</code>，<code>ACK=1</code>，序列号 <code>seq=y</code>，确认号 <code>ack=x+1</code>。第二次握手前服务端的状态为 <code>LISTEN</code>，第二次握手后服务端的状态为 <code>SYN-RCVD</code>，此时客户端的状态为 <code>SYN-SENT</code>。（其中 <code>SYN=1</code> 表示要和客户端建立一个连接，<code>ACK=1</code> 表示确认序号有效）</li>
<li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位 <code>ACK=1</code>，序列号 <code>seq=x+1</code>，确认号 <code>ack=y+1</code>。第三次握手前客户端的状态为 <code>SYN-SENT</code>，第三次握手后客户端和服务端的状态都为 <code>ESTABLISHED</code>。此时连接建立完成。</li>
</ol>
<h5 id="3-如果三次握手对方都没收到回怎么样"><a href="#3-如果三次握手对方都没收到回怎么样" class="headerlink" title=".3. 如果三次握手对方都没收到回怎么样"></a>.3. 如果三次握手对方都没收到回怎么样</h5><ol>
<li><p>如果第一次握手消息丢失，那么请求方不会得到 ack 消息，<code>超时后进行重传</code></p>
</li>
<li><p>如果第二次握手消息丢失，那么请求方不会得到 ack 消息，<code>超时后进行重传</code></p>
</li>
<li><p>如果第三次握手消息丢失，那么 <code>Server 端该 TCP 连接的状态为 SYN_RECV, 并且会根据 TCP 的超时重传机制，会等待 3 秒、6 秒、12 秒后重新发送 SYN+ACK 包</code>，以便 Client 重新发送 ACK 包。而 Server 重发 SYN+ACK 包的次数，可以设置 /proc/sys/net/ipv4/tcp_synack_retries 修改，默认值为 5. 如果<code>重发指定次数</code>之后，仍然未收到 client 的 ACK 应答，那么一段时间后，Server 自动关闭这个连接。</p>
<p>client 一般是通过 connect () 函数来连接服务器的，而<code>connect () 是在 TCP 的三次握手的第二次握手完成后就成功返回值</code>。也就是说 client 在接收到 SYN+ACK 包，它的 TCP 连接状态就为 established （已连接），表示该连接已经建立。那么如果 第三次握手中的 ACK 包丢失的情况下，Client 向 server 端发送数据，Server 端将以 RST 包响应，方能感知到 Server 的错误。</p>
</li>
</ol>
<h5 id="3-俩次握手可以吗"><a href="#3-俩次握手可以吗" class="headerlink" title=".3. 俩次握手可以吗"></a>.3. 俩次握手可以吗</h5><ul>
<li>为了防止<code>已失效的连接请求报文段突然又传送到了服务端</code>，因而产生错误, 浪费资源</li>
<li>双方都需要<code>确认对方收到了自己发送的序列号</code>，确认过程最少要进行三次通信。</li>
<li>信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值</li>
</ul>
<p><code>防止已失效的连接请求报文段突然又传输到了服务端</code>，导致产生问题<code>(资源浪费）</code>。</p>
<ul>
<li>比如客户端 A 发出连接请求，可能因为网络阻塞原因，A 没有收到确认报文，于是 A 再重传一次连接请求。</li>
<li>连接成功，等待数据传输完毕后，就释放了连接。</li>
<li>然后 A 发出的第一个连接请求等到连接释放以后的某个时间才到达服务端 B，此时 B 误认为 A 又发出一次新的连接请求，于是就向 A 发出确认报文段。</li>
<li>如果不采用三次握手，只要 B 发出确认，就建立新的连接了，<strong>此时 A 不会响应 B 的确认且不发送数据，则 B 一直等待 A 发送数据，浪费资源。</strong></li>
</ul>
<h5 id="3-什么是MSL，-为什么需要等待连接2MSL的时间才能完全关闭"><a href="#3-什么是MSL，-为什么需要等待连接2MSL的时间才能完全关闭" class="headerlink" title=".3. 什么是MSL， 为什么需要等待连接2MSL的时间才能完全关闭"></a>.3. 什么是MSL， 为什么需要等待连接2MSL的时间才能完全关闭</h5><ol>
<li>MSL 是 Maximum Segment Lifetime 的英文缩写，可译为<code>“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</code></li>
<li>为了保证客户端发送的最后一个 ACK 报文段能够到达服务器。因为这个 ACK 有可能丢失，从而导致处在 LAST-ACK 状态的服务器收不到对 FIN-ACK 的确认报文。服务器会超时重传这个 FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待 2MSL，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就无法正常的进入关闭连接状态。</li>
</ol>
<ul>
<li><p>两个理由：</p>
<ul>
<li><p>保证客户端发送的最后一个 ACK 报文段能够到达服务端。</p>
<p>这个 ACK 报文段有可能丢失，使得处于 LAST-ACK 状态的 B 收不到对已发送的 FIN+ACK 报文段的确认，服务端超时重传 FIN+ACK 报文段，而客户端能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段，接着客户端重传一次确认，重新启动 2MSL 计时器，最后客户端和服务端都进入到 CLOSED 状态，若客户端在 TIME-WAIT 状态不等待一段时间，而是发送完 ACK 报文段后立即释放连接，则无法收到服务端重传的 FIN+ACK 报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到 CLOSED 状态。</p>
</li>
<li><p>防止 “已失效的连接请求报文段” 出现在本连接中。</p>
<p>客户端在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
</li>
</ul>
</li>
</ul>
<h5 id="4-四次挥手"><a href="#4-四次挥手" class="headerlink" title=".4. 四次挥手"></a>.4. 四次挥手</h5><p><img src="../../../../../picture2022/MBXY-CR-44ee0cb73ea8397feb1977d138f8f995.png" alt=""></p>
<ol>
<li>A 的应用进程先向其 TCP 发出连接释放报文段（<code>FIN=1，seq=u</code>），并停止再发送数据，主动关闭 TCP 连接，进入 <code>FIN-WAIT-1</code>（终止等待 1）状态，等待 B 的确认。</li>
<li>B 收到连接释放报文段后即发出确认报文段（<code>ACK=1，ack=u+1，seq=v</code>），B 进入 <code>CLOSE-WAIT</code>（关闭等待）状态，此时的 TCP 处于半关闭状态，A 到 B 的连接释放。</li>
<li>A 收到 B 的确认后，进入 <code>FIN-WAIT-2</code>（终止等待 2）状态，等待 B 发出的连接释放报文段。</li>
<li>B 发送完数据，就会发出连接释放报文段（<code>FIN=1，ACK=1，seq=w，ack=u+1</code>），B 进入 <code>LAST-ACK</code>（最后确认）状态，等待 A 的确认。</li>
<li>A 收到 B 的连接释放报文段后，对此发出确认报文段（<code>ACK=1，seq=u+1，ack=w+1</code>），A 进入 <code>TIME-WAIT</code>（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 <code>2MSL</code>（最大报文段生存时间）后，A 才进入 <code>CLOSED</code> 状态。B 收到 A 发出的确认报文段后关闭连接，若没收到 A 发出的确认报文段，B 就会重传连接释放报文段。</li>
</ol>
<h5 id="5-第四次挥手为什么要等待-2MSL？"><a href="#5-第四次挥手为什么要等待-2MSL？" class="headerlink" title=".5. 第四次挥手为什么要等待 2MSL？"></a>.5. 第四次挥手为什么要等待 2MSL？</h5><ul>
<li><strong>保证 A 发送的最后一个 ACK 报文段能够到达 B</strong>。这个 <code>ACK</code> 报文段有可能丢失，B 收不到这个确认报文，就会<code>超时重传</code>连接释放报文段，然后 A 可以在 <code>2MSL</code> 时间内收到这个重传的连接释放报文段，接着 A 重传一次确认，重新启动 2MSL 计时器，最后 A 和 B 都进入到 <code>CLOSED</code> 状态，若 A 在 <code>TIME-WAIT</code> 状态不等待一段时间，而是发送完 ACK 报文段后立即释放连接，则无法收到 B 重传的连接释放报文段，所以不会再发送一次确认报文段，B 就无法正常进入到 <code>CLOSED</code> 状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。A 在发送完最后一个 <code>ACK</code> 报文段后，再经过 2MSL，就可以使这个<code>连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段</code>。</li>
</ul>
<h5 id="6-为什么是四次挥手？"><a href="#6-为什么是四次挥手？" class="headerlink" title=".6. 为什么是四次挥手？"></a>.6. 为什么是四次挥手？</h5><ul>
<li>因为 TCP 是<code>全双工模式</code>，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前<code>没传完</code>的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以<code>TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的</code>（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</li>
<li>客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而<code>连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送</code>。</li>
</ul>
<p>因为当 Server 端收到 Client 端的 <code>SYN</code> 连接请求报文后，可以直接发送 <code>SYN+ACK</code> 报文。<strong>但是在关闭连接时，当 Server 端收到 Client 端发出的连接释放报文时，很可能并不会立即关闭 SOCKET</strong>，所以 Server 端先回复一个 <code>ACK</code> 报文，告诉 Client 端我收到你的连接释放报文了。只有等到 Server 端所有的报文都发送完了，这时 Server 端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。</p>
<h5 id="6-服务器出现大量Close-wait-状态"><a href="#6-服务器出现大量Close-wait-状态" class="headerlink" title=".6. 服务器出现大量Close_wait 状态"></a>.6. 服务器出现大量Close_wait 状态</h5><ul>
<li>服务器端收到客户端发送的 <code>FIN</code> 后，TCP 协议栈就会自动发送 ACK，接着进入 <strong>CLOSE_WAIT</strong> 状态。</li>
<li>但是如果服务器端不执行 socket 的 close () 操作，那么就没法进入 LAST_ACK, 导致大量连接处于 CLOSE_WAIT 状态</li>
<li>所以，如果服务器出现了大量 <strong>CLOSE_WAIT</strong> 状态，一般是<code>程序 Bug，或者关闭 socket 不及时</code>。</li>
</ul>
<h5 id="6-客户端突然故障断开链接"><a href="#6-客户端突然故障断开链接" class="headerlink" title=".6. 客户端突然故障断开链接"></a>.6. 客户端突然故障断开链接</h5><blockquote>
<p><code>保活机制原理</code>：设置 TCP 保活机制的<code>保活时间 keepIdle</code>，即在 TCP 链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间<code>间隔 keepInterval</code>；设置保活探测报文的<code>总发送次数</code> keepCount。如果在 keepCount 次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的 TCP 链接。</p>
</blockquote>
<h5 id="7-TCP-有哪些特点？"><a href="#7-TCP-有哪些特点？" class="headerlink" title=".7. TCP 有哪些特点？"></a>.7. TCP 有哪些特点？</h5><ul>
<li>TCP 是<strong>面向连接</strong>的运输层协议。</li>
<li><strong>点对点</strong>，每一条 TCP 连接只能有两个端点。</li>
<li>TCP 提供<strong>可靠交付</strong>的服务。</li>
<li>TCP 提供<strong>全双工通信</strong>。</li>
<li><strong>面向字节流</strong>。</li>
</ul>
<h5 id="7-TCP-粘包"><a href="#7-TCP-粘包" class="headerlink" title=".7. TCP 粘包"></a>.7. TCP 粘包</h5><p><strong>为什么会产生粘包和拆包呢？</strong></p>
<ul>
<li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li>
<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>发送端将每个数据包封装为固定长度</li>
<li>在数据尾部增加特殊字符进行分割</li>
<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li>
</ul>
<h5 id="7-端口及对应服务"><a href="#7-端口及对应服务" class="headerlink" title=".7. 端口及对应服务"></a>.7. 端口及对应服务</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/MBXY-CR-b651e46b88d855f852c6a8f0d93fcc08.png" alt=""></p>
<h5 id="7-TCP-如何保证可靠传输"><a href="#7-TCP-如何保证可靠传输" class="headerlink" title=".7. TCP 如何保证可靠传输"></a>.7. TCP 如何保证可靠传输</h5><ul>
<li>校验和</li>
<li>序列号：TCP 会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答 (ACK 报文)，并且这个 ACK 报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。</li>
<li>超时重传</li>
<li>流量控制： TCP 协议利用了<code>滑动窗口进行了流量控制</code>。在 TCP 首部有一个 16 位字段大小的窗口，<code>窗口的大小就是接收端接收数据缓冲区的剩余大小</code>。接收端会在收到数据包后发送 ACK 报文时，将自己的窗口大小填入 ACK 中，发送方会根据 ACK 报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。</li>
<li>拥塞避免: 如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。拥塞控制主要有四部分组成：<code>慢开始、拥塞避免、快重传、快恢复</code>，如下图 (图片来源于网络)。<ul>
<li>慢开始：为了避免一开始发送大量的数据而产生网络阻塞，会先初始化 <code>cwnd 为 1</code>，当收到 ACK 后到下一个传输轮次，cwnd 为 2，以此类推成指数形式增长。</li>
<li>拥塞避免：因为 cwnd 的数量在慢开始是指数增长的，为了防止 cwnd 数量过大而导致网络阻塞，会设置一个慢开始的<code>门限值 ssthresh</code>，当 cwnd&gt;=ssthresh 时，进入到拥塞避免阶段，cwnd 每个传输轮次加 1。但网络出现超时，会将门限值 ssthresh 变为出现超时 cwnd 数值的一半，cwnd 重新设置为 1，如上图，在第 12 轮出现超时后，cwnd 变为 1，ssthresh 变为 12。</li>
<li>快重传：在网络中如果出现超时或者阻塞，则按慢开始和拥塞避免算法进行调整。但如果只是丢失某一个报文段，如下图 (图片来源于网络)，则使用快重传算法。</li>
<li>快恢复：快恢复是指将<code>ssthresh 设置为发生快重传时的 cwnd 数量的一半</code>，而<code>cwnd 不是设置为 1 而是设置为为门限值 ssthresh</code>，并开始拥塞避免阶段。</li>
</ul>
</li>
</ul>
<blockquote>
<p>拥塞控制是<strong>作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况</strong>。它的目标主要是最大化利用网络上瓶颈链路的带宽</p>
<p>流量控制是作用于接收者的，根据<strong>接收端的实际接收能力控制发送速度</strong>，防止<code>分组丢失</code>的。</p>
</blockquote>
<h5 id="8-TCP-和-UDP-的区别？"><a href="#8-TCP-和-UDP-的区别？" class="headerlink" title=".8. TCP 和 UDP 的区别？"></a>.8. TCP 和 UDP 的区别？</h5><ol>
<li>TCP <strong>面向连接</strong>；UDP 是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP 提供<strong>可靠的服务</strong>；UDP 不保证可靠交付。</li>
<li>TCP <strong>面向字节流</strong>，把数据看成一连串无结构的字节流；UDP 是面向<code>报文</code>的。</li>
<li>TCP 有<strong>拥塞控制</strong>；UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。</li>
<li>每一条 TCP 连接只能是<strong>点到点</strong>的；UDP 支持<code>一对一、一对多、多对一和多对多</code>的通信方式。</li>
<li>TCP 首部开销 20 字节；UDP 的<code>首部开销</code>小，只有 8 个字节。</li>
<li>TCP: HTTP, HTTPS, SSH, Telnet, SMTP;  UDP: DNS, SNMP</li>
</ol>
<h5 id="9-从系统层面上，UDP-如何保证尽量可靠"><a href="#9-从系统层面上，UDP-如何保证尽量可靠" class="headerlink" title=".9. 从系统层面上，UDP 如何保证尽量可靠"></a>.9. 从系统层面上，UDP 如何保证尽量可靠</h5><ol>
<li>UDP 仅提供了最基本的数据传输功能，至于<code>传输时连接的建立和断开、传输可靠性的保证</code>这些 UDP 统统不关心，而是把这些问题抛给了 UDP 上层的应用层程序去处理，自己仅提供传输层协议的最基本功能。</li>
<li>最简单的方式是在<code>应用层模仿传输层 TCP 的可靠性传输</code>。下面不考虑拥塞处理，可靠 UDP 的简单设计。<ul>
<li><code>添加 seq/ack 机制</code>，确保数据发送到对端</li>
<li>添加<code>发送和接收缓冲区</code>，主要是用户超时重传。</li>
<li>添加<code>超时重传机制</code>。</li>
</ul>
</li>
</ol>
<h5 id="9-简述-TCP-协议的延迟-ACK-和累计应答"><a href="#9-简述-TCP-协议的延迟-ACK-和累计应答" class="headerlink" title=".9. 简述 TCP 协议的延迟 ACK 和累计应答"></a>.9. 简述 TCP 协议的延迟 ACK 和累计应答</h5><ol>
<li><code>延迟应答</code>指的是：TCP 在接收到对端的报文后，并不会立即发送 ack，而是<code>等待一段时间发送 ack</code>，以便<code>将 ack 和要发送的数据一块发送</code>。当然 ack 不能无限延长，否则对端会认为包超时而造成报文重传。linux 采用动态调节算法来确定延时的时间。</li>
<li><code>累计应答</code>指的是：为了保证<strong>顺序性</strong>，每一个包都有一个 <strong>ID</strong>（序号），在建立连接的时候，会商定起始的 ID 是多少，然后按照 ID 一个个发送。而为了保证不丢包，对应发送的包都要进行应答，但不是一个个应答，而是会<strong>应答某个之前的 ID</strong>，该模式称为<strong>累计应答</strong></li>
</ol>
<h5 id="9-TCP-如何加速一个大文件的传输"><a href="#9-TCP-如何加速一个大文件的传输" class="headerlink" title=".9. TCP 如何加速一个大文件的传输"></a>.9. TCP 如何加速一个大文件的传输</h5><ol>
<li>建连优化：TCP 在建立连接时，如果丢包，会进入重试，重试时间是 1s、2s、4s、8s 的指数递增间隔，缩短定时器可以让 TCP 在丢包环境建连时间更快，非常适用于高并发短连接的业务场景。</li>
<li>平滑发包：在 RTT 内均匀发包，规避微分时间内的流量突发，尽量避免瞬间拥塞</li>
<li>丢包预判：有些网络的丢包是有规律性的，例如每隔一段时间出现一次丢包，例如每次丢包都连续丢几个等，如果程序能自动发现这个规律（有些不明显），就可以针对性提前多发数据，减少重传时间、提高有效发包率。</li>
<li>RTO 探测：若始终收不到 ACK 报文，则需要触发 RTO 定时器。RTO 定时器一般都时间非常长，会浪费很多等待时间，而且一旦 RTO，CWND 就会骤降（标准 TCP），因此利用 Probe 提前与 RTO 去试探，可以规避由于 ACK 报文丢失而导致的速度下降问题。</li>
<li><code>带宽评估</code>：通过单位时间内收到的 ACK 或 SACK 信息可以得知客户端有效接收速率，通过这个速率可以更<code>合理的控制发包速度</code>。</li>
<li>带宽争抢：有些场景（例如合租）是大家互相挤占带宽的，假如你和室友各 1Mbps 的速度看电影，会把 2Mbps 出口占满，而如果一共有 3 个人看，则每人只能分到 1/3。若此时你的流量流量达到 2Mbps，而他俩还都是 1Mbps，则你至少仍可以分到 2/(2+1+1) * 2Mbps = 1Mbps 的 50% 的带宽，甚至更多，代价就是服务器侧的出口流量加大，增加成本。（TCP 优化的本质就是用带宽换用户体验感）</li>
</ol>
<h5 id="9-HTTP-协议的特点"><a href="#9-HTTP-协议的特点" class="headerlink" title=".9. HTTP 协议的特点"></a>.9. HTTP 协议的特点</h5><ol>
<li>HTTP 允许传输<strong>任意类型</strong>的数据。传输的类型由 Content-Type 加以标记。</li>
<li><strong>无状态</strong>。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。</li>
<li>支持<strong>客户端 / 服务器模式</strong>。</li>
</ol>
<h5 id="10-HTTP-报文格式"><a href="#10-HTTP-报文格式" class="headerlink" title=".10. HTTP 报文格式"></a>.10. HTTP 报文格式</h5><p>HTTP 请求由<strong>请求行、请求头部、空行和请求体</strong>四个部分组成。</p>
<ul>
<li><strong>请求行</strong>：包括请求方法，访问的资源 URL，使用的 HTTP 版本。<code>GET</code> 和 <code>POST</code> 是最常见的 HTTP 方法，除此以外还包括 <code>DELETE、HEAD、OPTIONS、PUT、TRACE</code>。</li>
<li><strong>请求头</strong>：格式为 “属性名：属性值”，服务端根据请求头获取客户端的信息，主要有 <code>cookie、host、connection、accept-language、accept-encoding、user-agent</code>。</li>
<li><strong>请求体</strong>：用户的请求数据如用户名，密码等。</li>
</ul>
<p><strong>请求报文示例</strong>：</p>
<pre><code>POST /xxx HTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=dabin 请求体</code></pre><p>HTTP 响应也由四个部分组成，分别是：<strong>状态行、响应头、空行和响应体</strong>。</p>
<ul>
<li><strong>状态行</strong>：协议版本，状态码及状态描述。</li>
<li><strong>响应头</strong>：响应头字段主要有 <code>connection、content-type、content-encoding、content-length、set-cookie、Last-Modified，、Cache-Control、Expires</code>。</li>
<li><strong>响应体</strong>：服务器返回给客户端的内容。</li>
</ul>
<p><strong>响应报文示例</strong>：</p>
<pre><code>HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

&lt;html&gt;
    &lt;body&gt;响应体&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id="11-HTTP-状态码有哪些？"><a href="#11-HTTP-状态码有哪些？" class="headerlink" title=".11.  HTTP 状态码有哪些？"></a>.11.  HTTP 状态码有哪些？</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828804.png" alt="图片"></p>
<h5 id="12-HTTP1-0-和-HTTP1-1-的区别？"><a href="#12-HTTP1-0-和-HTTP1-1-的区别？" class="headerlink" title=".12. HTTP1.0 和 HTTP1.1 的区别？"></a>.12. HTTP1.0 和 HTTP1.1 的区别？</h5><ul>
<li><strong>长连接</strong>：HTTP1.0 默认使用短连接，<code>每次请求都需要建立新的 TCP 连接，连接不能复用</code>。<strong>HTTP1.1 支持长连接，复用 TCP 连接，允许客户端通过同一连接发送多个请求</strong>。不过，这个优化策略也存在问题，当一个队头的请求不能收到响应的资源时，它将会阻塞后面的请求。这就是 “<strong>队头阻塞</strong>” 问题。</li>
<li><strong>断点续传</strong>：HTTP1.0 <strong>不支持断点续传</strong>。HTTP1.1 新增了 <strong>range</strong> 字段，用来指定数据字节位置，<strong>支持断点续传</strong>。</li>
<li><strong>错误状态响应码</strong>：在 HTTP1.1 中新增了 24 个错误状态响应码，如 <code>409（Conflict）</code>表示请求的资源与资源的当前状态发生冲突、<code>410（Gone）</code>表示服务器上的某个资源被永久性的删除。</li>
<li><strong>Host 头处理</strong>：在 HTTP1.0 中认为<code>每台服务器都绑定一个唯一的 IP 地址</code>，因此，请求消息中的 URL 并没有传递主机名。到了 HTTP1.1 时代，虚拟主机技术发展迅速，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址，故 <code>HTTP1.1 增加了 HOST 信息</code>。</li>
</ul>
<h5 id="13-get-和post-区别"><a href="#13-get-和post-区别" class="headerlink" title=".13. get 和post 区别"></a>.13. get 和post 区别</h5><p><img src="../../../../../picture2022/image-20220304105225789.png" alt=""></p>
<h5 id="13-HTTP1-1-和-HTTP2-0-的区别？"><a href="#13-HTTP1-1-和-HTTP2-0-的区别？" class="headerlink" title=".13. HTTP1.1 和 HTTP2.0 的区别？"></a>.13. HTTP1.1 和 HTTP2.0 的区别？</h5><p>HTTP2.0 相比 HTTP1.1 支持的特性：</p>
<ul>
<li><strong>新的二进制格式</strong>：HTTP1.1 基于文本格式传输数据；HTTP2.0 采用二进制格式传输数据，解析更高效。</li>
<li><strong>多路复用</strong>：在一个连接里，允许同时发送多个请求或响应，<strong>并且这些请求或响应能够并行的传输而不被阻塞</strong>，避免 HTTP1.1 出现的” 队头堵塞” 问题。</li>
<li><strong>头部压缩</strong>，HTTP1.1 的 header 带有大量信息，而且每次都要重复发送；HTTP2.0 把 header 从数据中分离，并封装成头帧和数据帧，<strong>使用特定算法压缩头帧</strong>，有效减少头信息大小。并且 HTTP2.0 <strong>在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。\</strong>比如请求 a 发送了所有的头信息字段，请求 b 则*<em>只需要发送差异数据*</em>，这样可以减少冗余数据，降低开销。</li>
<li><strong>服务端推送</strong>：HTTP2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。</li>
</ul>
<h5 id="14-HTTPS-与-HTTP-的区别"><a href="#14-HTTPS-与-HTTP-的区别" class="headerlink" title=".14. HTTPS 与 HTTP 的区别"></a>.14. HTTPS 与 HTTP 的区别</h5><ol>
<li>HTTP 是超文本传输协议，信息是<strong>明文传输</strong>；HTTPS 则是具有<strong>安全性</strong>的 ssl 加密传输协议。</li>
<li>HTTP 和 HTTPS 用的端口不一样，<code>HTTP 端口是 80，HTTPS 是 443</code>。</li>
<li>HTTPS 协议<strong>需要到 CA 机构申请证书</strong>，一般需要一定的费用。</li>
<li>HTTP 运行在 TCP 协议之上；HTTPS 运行在 SSL 协议之上，<code>SSL 运行在 TCP 协议</code>之上。</li>
</ol>
<h5 id="15-什么是数字证书"><a href="#15-什么是数字证书" class="headerlink" title=".15.  什么是数字证书"></a>.15.  什么是数字证书</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/1460000038526733.png" alt=""></p>
<p>服务端可以向证书<code>颁发机构 CA</code>申请证书，以<code>避免中间人攻击</code>（防止证书被篡改）。证书包含三部分内容：<strong>证书内容、证书签名算法和签名</strong>，签名是为了验证身份。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828805.png" alt="图片"></p>
<p>服务端把证书传输给浏览器，<code>浏览器从证书里取公钥</code>。<code>证书可以证明该公钥对应本网站</code>。</p>
<p><strong>数字签名的制作过程</strong>：</p>
<ol>
<li>CA 使用证书签名算法对证书内容进行 <strong>hash 运算</strong>。</li>
<li>对 hash 后的值<strong>用 CA 的私钥加密</strong>，得到数字签名。</li>
</ol>
<p><strong>浏览器验证过程</strong>：</p>
<ol>
<li>获取证书，得到<code>证书内容、证书签名算法和数字签名</code>。</li>
<li>用 CA 机构的公钥<strong>对数字签名解密</strong>（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。</li>
<li>用证书里的签名算法<strong>对证书内容进行 hash 运算</strong>。</li>
<li>比较解密后的数字签名和对证书内容做 hash 运算后得到的哈希值，相等则表明证书可信。</li>
</ol>
<h5 id="16-HTTPS-原理"><a href="#16-HTTPS-原理" class="headerlink" title=".16. HTTPS 原理"></a>.16. HTTPS 原理</h5><p>首先是 <code>TCP 三次握手</code>，然后<code>客户端发起一个 HTTPS 连接建立请求</code>，客户端先发一个 <code>Client Hello</code> 的包，然后服务端响应 <code>Server Hello</code>，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。</p>
<ol>
<li><p><strong>协商加密算法</strong> 。在 <code>Client Hello</code> 里面客户端会告知服务端自己当前的一些<code>信息</code>，包括客户端要使用的 TLS 版本，支持的加密算法，要访问的域名，给服务端生成的一个随机数（Nonce）等。需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828806.png" alt="图片"></p>
</li>
<li><p>服务端响应 <code>Server Hello</code>，告诉客户端服务端<strong>选中的加密算法</strong>。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828807.png" alt=""></p>
</li>
<li><p>接着服务端给客户端发来了 <code>2 个证书。第二个证书是第一个证书的签发机构（CA）的证书</code>。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828808.png" alt=""></p>
</li>
<li><p>客户端使用证书的认证机构 CA 公开发布的 RSA 公钥<strong>对该证书进行验证</strong>，下图表明证书认证成功。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828809.png" alt="图片"></p>
</li>
<li><p>验证通过之后，浏览器和服务器通过<strong>密钥交换算法</strong>产生共享的<strong>对称密钥</strong>。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-164597358288010.png" alt="图片"></p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-164597358288111.png" alt="图片"></p>
</li>
<li><p>开始传输数据，使用同一个对称密钥来加解密。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-164597358288112.png" alt="图片"></p>
</li>
</ol>
<h5 id="17-DNS-的解析过程"><a href="#17-DNS-的解析过程" class="headerlink" title=".17. DNS 的解析过程"></a>.17. DNS 的解析过程</h5><ol>
<li>浏览器搜索<strong>自己的 DNS 缓存</strong></li>
<li>若没有，则搜索<strong>操作系统中的 DNS 缓存和 hosts 文件</strong></li>
<li>若没有，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果，否则依次向<strong>根域名服务器、顶级域名服务器、权限域名服务器</strong>发起查询请求，最终返回 IP 地址给本地域名服务器</li>
<li>本地域名服务器将得到的 IP 地址返回给<strong>操作系统</strong>，同时自己也<strong>将 IP 地址缓存起来</strong></li>
<li><code>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</code></li>
<li>浏览器得到域名对应的 IP 地址</li>
</ol>
<h5 id="18-浏览器中输入-URL-返回页面过程"><a href="#18-浏览器中输入-URL-返回页面过程" class="headerlink" title=".18. 浏览器中输入 URL 返回页面过程"></a>.18. 浏览器中输入 URL 返回页面过程</h5><ol>
<li><strong>解析域名</strong>，找到主机 IP。</li>
<li><code>浏览器</code>利用 IP 直接与<code>网站主机</code>通信，<strong>三次握手</strong>，建立 TCP 连接。浏览器会以一个随机端口向服务端的 web 程序 <code>80</code>端口发起 TCP 的连接。</li>
<li>建立 TCP 连接后，浏览器向主机发起一个 <code>HTTP 请求</code>。</li>
<li>服务器<strong>响应请求</strong>，返回<code>响应数据</code>。</li>
<li>浏览器<strong>解析响应内容，进行渲染</strong>，呈现给用户。</li>
</ol>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-164597358288113.png" alt="图片"></p>
<h5 id="19-Cookie-和-Session-的区别"><a href="#19-Cookie-和-Session-的区别" class="headerlink" title=".19. Cookie 和 Session 的区别"></a>.19. Cookie 和 Session 的区别</h5><ul>
<li><strong>作用范围不同</strong>，Cookie 保存在<code>客户端</code>，Session 保存在<code>服务器端</code>。</li>
<li><strong>有效期不同</strong>，Cookie 可设置为<code>长时间保持</code>，比如我们经常使用的默认登录功能，Session 一般失效时间较短，<code>客户端关闭或者 Session 超时</code>都会失效。</li>
<li><strong>隐私策略不同</strong>，Cookie 存储在客户端，容易被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li><strong>存储大小不同</strong>， 单个<code>Cookie 保存的数据不能超过 4K</code>；对于 Session 来说存储没有上限，但出于对服务器的性能考虑，Session 内不要存放过多的数据，并且需要设置 Session 删除机制。</li>
</ul>
<blockquote>
<p>Session 的作用是在服务端来保持状态，<code>通过 sessionid 来进行确认身份</code>，但 sessionid 一般是通过 Cookie 来进行传递的。如果 Cooike 被禁用了，可以通过在<code>URL 中传递 sessionid</code></p>
</blockquote>
<blockquote>
<p><code>Servlet 不是线程安全的，多线程的读写会导致数据不同步的问题</code>。</p>
</blockquote>
<h5 id="20-什么是对称加密和非对称加密？"><a href="#20-什么是对称加密和非对称加密？" class="headerlink" title=".20. 什么是对称加密和非对称加密？"></a>.20. 什么是对称加密和非对称加密？</h5><p><strong>对称加密</strong>：通信双方使用<strong>相同的密钥</strong>进行加密。特点是加密速度快，但是缺点是密钥泄露会导致密文数据被破解。常见的对称加密有 <code>AES</code> 和 <code>DES</code> 算法。</p>
<p><strong>非对称加密</strong>：它需要生成两个密钥，<strong>公钥和私钥</strong>。公钥是公开的，任何人都可以获得，而私钥是私人保管的。公钥负责加密，私钥负责解密；或者私钥负责加密，公钥负责解密。这种加密算法<strong>安全性更高</strong>，但是<strong>计算量相比对称加密大很多</strong>，加密和解密都很慢。常见的非对称算法有 <code>RSA</code> 和 <code>DSA</code>。</p>
<h5 id="21-URI-和URL"><a href="#21-URI-和URL" class="headerlink" title=".21. URI 和URL"></a>.21. URI 和URL</h5><blockquote>
<ul>
<li>URI (Uniform Resource Identifier)：中文全称为统一资源标志符，主要作用是唯一标识一个资源。</li>
<li>URL (Uniform Resource Location)：中文全称为统一资源定位符，主要作用是提供资源的路径。</li>
</ul>
</blockquote>
<h5 id="22-ARP-协议"><a href="#22-ARP-协议" class="headerlink" title=".22. ARP 协议"></a>.22. ARP 协议</h5><blockquote>
<p>ARP 协议属于<code>网络层的协议</code>，主要作用是实现从<code>IP 地址转换为 MAC 地址</code>。在每个<code>主机或者路由器</code>中都建有一个 <code>ARP 缓存表</code>，表中有 IP 地址及 IP 地址对应的 MAC 地址。</p>
<ul>
<li>IP 地址：IP 地址是指互联网协议地址,它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异</li>
<li>MAC 地址：MAC 地址又称物理地址，由网络设备制造商生产时写在硬件内部，不可更改，并且每个以太网设备的 MAC 地址都是唯一的。</li>
</ul>
<p>计算机的 IP 地址可由用户<code>自行更改</code>，管理起来相对困难，而 MAC 地址不可更改</p>
<p>路由器通过 IP 地址的前缀就知道设备在在哪个子网上了，而只用 MAC 地址的话，路由器则需要记住每个 MAC 地址在哪个子网，这需要路由器有极大的存储空间</p>
</blockquote>
<h5 id="23-路由器和交换机"><a href="#23-路由器和交换机" class="headerlink" title=".23. 路由器和交换机"></a>.23. 路由器和交换机</h5><table>
<thead>
<tr>
<th align="center">所属网络模型的层级</th>
<th align="center">功能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">路由器</td>
<td align="center">网络层</td>
<td>识别 IP 地址并根据 IP 地址转发数据包，维护数据表并基于数据表进行最佳路径选择</td>
</tr>
<tr>
<td align="center">交换机</td>
<td align="center"><code>数据链库层</code></td>
<td>识别<code>MAC 地址并根据 MAC 地址转发数据帧</code></td>
</tr>
</tbody></table>
<h5 id="24-Ping-过程"><a href="#24-Ping-过程" class="headerlink" title=".24. Ping 过程"></a>.24. Ping 过程</h5><blockquote>
<ol>
<li>向目的主机发送多个<code>ICMP 回送请求报文</code></li>
<li>根据目的主机返回的回送报文的<code>时间</code>和<code>成功响应的次数</code>估算出数据包<code>往返时间及丢包率</code>。</li>
</ol>
</blockquote>
<h5 id="25-WebSocket-和-socket-区别"><a href="#25-WebSocket-和-socket-区别" class="headerlink" title=".25. WebSocket 和 socket 区别"></a>.25. WebSocket 和 socket 区别</h5><ul>
<li>Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。 <strong>IP 地址 + 端口 + 协议</strong></li>
<li>Socket 一个是<strong>网编编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</li>
<li>WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决 <strong>http 不支持持久化连接</strong>的问题。</li>
</ul>
<p><img src="../../../../../picture2022/v2-72ef367f52a4512d44e7811c52d5ad90_720w.jpg" alt=""></p>
<h5 id="26-ARP-协议工作流程"><a href="#26-ARP-协议工作流程" class="headerlink" title=".26. ARP 协议工作流程"></a>.26. ARP 协议工作流程</h5><ul>
<li>每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系.</li>
<li>源主机需要将一个<code>数据包要发送</code>到目的主机时，会首先检查自己的 <code>ARP 列表，是否存在该 IP 地址对应的 MAC 地址</code>；如果有, 就直接将数据包发送到这个 MAC 地址；如果没有，就向<code>本地网段</code>发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求的数据包里，包括<code>源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址</code>。</li>
<li>网络中<code>所有的主机收到这个 ARP 请求</code>后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。</li>
<li><code>源主机收到这个 ARP 响应数据包</code>后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</li>
</ul>
<blockquote>
<ul>
<li>Mac 不可修改</li>
<li>子网概念, 网络地址+主机号, 节省存储空间</li>
</ul>
</blockquote>
<h5 id="27-TCP-流量控制"><a href="#27-TCP-流量控制" class="headerlink" title=".27. TCP 流量控制"></a>.27. TCP 流量控制</h5><blockquote>
<p>TCP 三次握手，发送端和接收端进入到 ESTABLISHED 状态，它们即可以愉快地传输数据啦。但是发送端不能疯狂地向接收端发送数据，因为<code>接收端接收不过来的话</code>，接收方<code>只能把处理不过来的数据存在缓存区里</code>。如果<code>缓存区都满了</code>，发送方还在疯狂发送数据的话，接收方只能把收到的数据包<code>丢掉</code>，这就浪费了网络资源啦。</p>
<ul>
<li><strong>流量控制</strong>: 让发送端根据接收端的实际接收能力控制发送的数据量, 通过win来控制大小</li>
</ul>
</blockquote>
<p><img src="../../../../../picture2022/image-20220304124334918.png" alt=""></p>
<p><img src="../../../../../picture2022/MBXY-CR-8f6389c120734508b1e3367a8a8c4d9f.png" alt=""></p>
<ul>
<li>首先双方三次握手，<code>初始化各自的窗口大小</code>，均为 400 个字节。</li>
<li>假如当前发送方给接收方发送了 200 个字节，那么，发送方的 <code>SND.NXT</code> 会<code>右移 200 个字节</code>，也就是说当前的可用窗口减少了 200 个字节。</li>
<li>接受方收到后，放到<code>缓冲队列</code>里面，REV.WND =400-200=200 字节，所以 win=200 字节返回给发送方。<code>接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节</code></li>
<li>发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100 字节，即 win=100 返回发送方。</li>
<li>发送方继续干活，发送 100 字节过来，这时候，接受窗口 win 变为 0。</li>
<li>发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送。</li>
</ul>
<h5 id="28-VPN-和NAT"><a href="#28-VPN-和NAT" class="headerlink" title=".28. VPN 和NAT"></a>.28. VPN 和NAT</h5><ul>
<li>VPN（Virtual Private Network，虚拟专用网）</li>
<li>NAT（Network Address Translation，网络地址转换）</li>
</ul>
<h4 id="6-java序列化操作"><a href="#6-java序列化操作" class="headerlink" title="6. java序列化操作"></a>6. java序列化操作</h4><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/Java%E5%BA%8F%E5%88%97%E5%8C%96.svg" alt=""></p>
<blockquote>
<p>序列化机制允许将实现序列化的 Java 对象转换位字节序列，这些字节序列可以<code>保存在磁盘上，或通过网络传输</code>，以达到以后恢复成原来的对象。序列化机制<code>使得对象可以脱离程序的运行而独立存在</code>。</p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/e92c3783d1cbe253897c8b4c1bf12345.png" alt=""></p>
<blockquote>
<ul>
<li>序列化时，只对对象的<code>状态进行保存</code>，而不管对象的方法；</li>
<li>当一个<code>父类实现序列化</code>，子类自动实现序列化，不需要显式实现 Serializable 接口；</li>
<li>当一个对象的<code>实例变量引用其他对象，序列化该对象时也把引用对象进行序列化</code>；</li>
<li>并非所有的对象都可以序列化: <ul>
<li><code>对象的 private 等域是不受保护的</code>;</li>
<li>资源分配方面的原因，比如<code>socket，thread 类</code></li>
<li><code>static 和 transient 类型的成员数据不能被序列化</code>。因为 static 代表类的状态，transient 代表对象的临时数据。</li>
</ul>
</li>
<li>列化运行时使用一个称为<code>serialVersionUID 的版本号与每个可序列化类相关联</code>，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类</li>
</ul>
</blockquote>
<h4 id="7-JVM-相关"><a href="#7-JVM-相关" class="headerlink" title="7. JVM 相关"></a>7. JVM 相关</h4><h5 id="1-简述垃圾回收机制"><a href="#1-简述垃圾回收机制" class="headerlink" title=".1. 简述垃圾回收机制"></a>.1. 简述垃圾回收机制</h5><blockquote>
<p>在 JVM 中，有一个垃圾回收线程，它是<code>低优先级的</code>，在正常情况下是不会执行的，只有<code>在虚拟机空闲或者当前堆内存不足时</code>，才会触发执行，<code>扫描那些没有被任何引用的对象</code>，并将它们添加到要<code>回收的集合</code>中，进行回收。</p>
<p>若 GC 一次之后仍不能满足内存分配的要求,JVM 会再进行两次 GC 作进一步的尝试,若仍无法满足要求,则 JVM 将报“out of memory”的错误,Java 应用将停止。</p>
</blockquote>
<h5 id="2-内存模型"><a href="#2-内存模型" class="headerlink" title=".2. 内存模型"></a>.2. 内存模型</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/20170711171225280" alt=""></p>
<ul>
<li><code>Java 堆</code>是被<code>所有线程共享的一块内存区域</code>，在<code>虚拟机启动时创建</code>。此内存区域的唯一目的就是<code>存放对象实例</code>，几乎所有的对象实例都在这里分配内存。</li>
<li>方法区（Method Area）是<code>各个线程共享的内存区域</code>，它用于<code>存储已被虚拟机加载</code>的<code>类信息、常量、静态变量、即时编译器编译后的代码</code>等数据。</li>
<li>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是<code>当前线程所执行的字节码的行号指示器</code>。</li>
<li>Java 虚拟机栈（Java Virtual Machine Stacks）也是<code>线程私有的</code>，它的<code>生命周期与线程相同</code>。虚拟机栈描述的是 Java 方法执行的内存模型：<code>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等</code>信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而<code>本地方法栈则是为虚拟机使用到的 Native 方法</code>服务。</li>
</ul>
<h5 id="3-如何判断对象死完："><a href="#3-如何判断对象死完：" class="headerlink" title=".3. 如何判断对象死完："></a>.3. 如何判断对象死完：</h5><blockquote>
<p>堆中⼏乎放着所有的对象实例，对堆垃圾回收前的第⼀步就是要判断哪些对象已经死亡（即不能再被任何途径使⽤ 的对象）</p>
<ol>
<li><code>引⽤计数法</code>：给对象中添加⼀个引⽤计数器 每当有⼀个地⽅引⽤它，计数器就加1 当引⽤失效，计数器就减1 任何时候计数器为0的对象就是不可能再被使⽤的。 很难解决<code>对象的相互循环引用</code>问题</li>
<li>可达性分析算法：是通过⼀系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所⾛过 的路径称为<code>引⽤链</code>，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不可⽤的。 <ol>
<li><code>虚拟机栈(栈中的本地变量列表)/</code>方法区<code>静态属性</code>/<code>方法区常量引用</code>/<code>本地方法栈中 JNI 所引用的对象</code>都是可以作为 gc roots 的</li>
</ol>
</li>
</ol>
</blockquote>
<h5 id="4-GC-回收机制"><a href="#4-GC-回收机制" class="headerlink" title=".4. GC 回收机制"></a>.4. GC 回收机制</h5><h6 id="1-标记清除法："><a href="#1-标记清除法：" class="headerlink" title="1.  标记清除法："></a>1.  标记清除法：</h6><blockquote>
<p><code>标记阶段</code>对所有存活的对象进行标记,标记完成后,再扫描整个空间未标记对象,直接<code>回收不存活的对象</code>.</p>
<p>缺点是会造成内存碎片, 对<code>大内存的分配无足够空间</code>时而提前猝发一次垃圾回收动作;</p>
</blockquote>
<h6 id="2-复制算法："><a href="#2-复制算法：" class="headerlink" title="2. 复制算法："></a>2. 复制算法：</h6><blockquote>
<p>将可用内存将容量划分成<code>大小相等的 2 块</code>,每次清理时将其中 A 内存还存活的对象复制到 B 内存里面,然后再把 A 中清理掉; 优点高效且并不产生碎片,缺点牺牲了一半的内存为代价. 适用存活对象少,回收对象多</p>
</blockquote>
<h6 id="3-标记整理算法"><a href="#3-标记整理算法" class="headerlink" title="3. 标记整理算法"></a>3. 标记整理算法</h6><blockquote>
<p>完成标记后它不是直接清理可回收对象,而是<code>将存活对象都向一端移动</code>,最后清理掉端边界意外的内存;</p>
</blockquote>
<h6 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h6><blockquote>
<p>整合了<code>复制算法</code>和<code>标记整理算法</code>,根据<code>新生代和老年代</code>的不同特性采取上面的不同算法</p>
<ul>
<li>新生代 生命周期短,每次回收时都有大量垃圾对象需要回收 <code>复制算法</code>, 内存划分按照 8:1:1 分一个大的 Eden 区和两个小的 survivor 的空间，<code>新生代中存活的对象,需要转移的 Survivor 的对象不多</code>,算是缓解了复制算法的缺点</li>
<li>老年代 每次只有少量的对象需要回收 <code>标记整理算法</code></li>
</ul>
</blockquote>
<p>当前商业虚拟机都采用<strong>分代收集</strong>的垃圾收集算法。分代收集算法，顾名思义是根据对象的<strong>存活周期</strong>将内存划分为几块。一般包括<strong>年轻代</strong>、<strong>老年代</strong> 和 <strong>永久代</strong>，如图所示：</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20210706091858163.png" alt=""></p>
<blockquote>
<p><strong>新生代</strong> 中存在一个<code>Eden</code>区和两个<code>Survivor</code>区。新对象会首先分配在<code>Eden</code>中（如果新对象过大，会直接分配在老年代中）。在<code>GC</code>中，<code>Eden</code>中的对象会被移动到<code>Survivor</code>中，直至对象满足一定的年纪（定义为熬过<code>GC</code>的次数），会被移动到<strong>老年代</strong>。</p>
<p>可以设置<strong>新生代</strong>和<strong>老年代</strong>的相对大小。这种方式的优点是新生代大小会随着整个<strong>堆</strong>大小<strong>动态扩展</strong>。参数 <code>-XX:NewRatio</code> 设置<strong>老年代</strong>与<strong>新生代</strong>的比例。例如 <code>-XX:NewRatio=8</code> 指定 <strong>老年代/新生代</strong> 为<code>8/1</code>. <strong>老年代</strong> 占堆大小的 <code>7/8</code> ，<strong>新生代</strong> 占堆大小的 <code>1/8</code>（默认即是 <code>1/8</code>）。</p>
<p>老年代： 对象没有变得不可达，并且从新生代中<strong>存活</strong>下来，会被<strong>拷贝</strong>到这里。其所占用的空间要比新生代多。也正由于其相对<strong>较大的空间</strong>，发生在<strong>老年代</strong>上的<code>GC</code>要比<strong>新生代</strong>要<strong>少得多</strong>。对象从<strong>老年代</strong>中消失的过程，可以称之为<code>major GC</code>（或者<code>full GC</code>）。</p>
<p>像一些<strong>类的层级信息</strong>，<strong>方法数据</strong> 和<strong>方法信息</strong>（如<strong>字节码</strong>，<strong>栈</strong> 和 <strong>变量大小</strong>），<strong>运行时常量池</strong>（<code>JDK7</code>之后移出<strong>永久代</strong>），已确定的<strong>符号引用</strong>和<strong>虚方法表</strong>等等。它们几乎都是<strong>静态的</strong>并且<strong>很少</strong>被<strong>卸载和回收</strong>，在<code>JDK8</code>之前的<code>HotSpot</code>虚拟机中，类的这些<strong>“永久的”</strong> 数据存放在一个叫做<strong>永久代</strong>的区域。</p>
<p>永久代一段<strong>连续的内存空间</strong>，我们在<code>JVM</code>启动之前可以通过设置<code>-XX:MaxPermSize</code>的值来控制永久代的大小。但是<code>JDK8</code>之后取消了永久代，这些<strong>元数据</strong>被移到了一个与堆<strong>不相连</strong>的称为<strong>元空间</strong> (<code>Metaspace</code>) 的<strong>本地内存区域</strong>。</p>
</blockquote>
<h5 id="5-垃圾回收三色标记法："><a href="#5-垃圾回收三色标记法：" class="headerlink" title=".5.垃圾回收三色标记法："></a>.5.垃圾回收三色标记法：</h5><blockquote>
<p>⼀开始所有对象都染成⽩⾊初始化完成后，会启动标记程序。在标记的过程中，是可以暂停标记程序执⾏ Mutation，算法需要维护 3 个集合，⽩⾊集合、⿊⾊集合、灰⾊集合。3 个集合是互斥的，对象只能在⼀个集合 中。执⾏之初，所有对象都放⼊⽩⾊集合</p>
<ol>
<li>第一次执行：算法将Root集合能直接引用的对象加入到灰色集合中</li>
<li>往后执行：不断从灰色集合中取出元素进行标记<ol>
<li>如果对象在白色集合中，那么将白色对象放入到黑色集合中</li>
<li>然后遍历节点所有引用对象，并递归所有引用对象</li>
<li>当一个对象的所有引用都在灰色集合中，就把这个点放在黑色集合中</li>
</ol>
</li>
<li>当算法执行完成，所有不需要GC的元素都会涂黑，白色集合中就是需要进行回收的对象</li>
</ol>
</blockquote>
<h5 id="6-CMS垃圾回收器介绍："><a href="#6-CMS垃圾回收器介绍：" class="headerlink" title=".6. CMS垃圾回收器介绍："></a>.6. CMS垃圾回收器介绍：</h5><blockquote>
<p>当垃圾回收开始清理资源时，其余的所有线程都会被停止。如果清理的时间过长，在我们的应用程序中就能感觉到明显的卡顿。</p>
</blockquote>
<blockquote>
<p>CMS（Concurrent Mark Sweep）收集器是⼀种<code>以获取最短回收停顿时间为⽬标</code>的收集器。它⾮常符合在注重⽤ 户体验的应⽤上使⽤。 是 HotSpot 虚拟机第⼀款真正意义上的并发收集器，它第⼀次实现了让 垃圾收集线程与⽤户线程（基本上）同时⼯作。</p>
<ol>
<li>初始标记：暂停所有其他线程，并<code>记录下直接与root相连的对象</code>，速度恒快</li>
<li>并发标记:同时开启GC和用户线程，用一个闭包结构去记录可达对象，因为用户线程可能会不停的更新引用域，无法保证可达性分析的实时性。</li>
<li>重新标记：为了修正并发期间因为用户程序继续运行而导致标记产生变动的那一部分标记记录</li>
<li>并发清除：开启用户线程同时GC线程开始对未标记的区域做清扫。</li>
</ol>
</blockquote>
<h5 id="7-JVM-俩个内存"><a href="#7-JVM-俩个内存" class="headerlink" title=".7. JVM 俩个内存"></a>.7. JVM 俩个内存</h5><h6 id="1-栈内存"><a href="#1-栈内存" class="headerlink" title="1. 栈内存"></a>1. 栈内存</h6><blockquote>
<p>在<code>函数中</code>定义的一些<code>基本类型的变量</code>和<code>对象的引用变量</code>都在函数的<code>栈内存</code>中分配。当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当<code>超过变量的作用域后</code>，Java 会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p>
</blockquote>
<h6 id="2-堆内存"><a href="#2-堆内存" class="headerlink" title="2. 堆内存"></a>2. 堆内存</h6><blockquote>
<p>堆内存用来存放由 <code>new 创建的对象和数组</code>。在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。</p>
</blockquote>
<h5 id="8-类加载器"><a href="#8-类加载器" class="headerlink" title=".8. 类加载器"></a>.8. 类加载器</h5><ul>
<li><code>启动类加载器</code>：Bootstrap ClassLoader，负责加载存放在 JDK\jre\lib(JDK 代表 JDK 的安装目录，下同)下，或被-Xbootclasspath 参数指定的路径中的，并且能被<code>虚拟机识别的类库</code></li>
<li><code>扩展类加载器</code>：Extension ClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 DK\jre\lib`ext 目录`中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如 javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li><code>应用程序类加载器</code>：Application ClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载<code>用户类路径</code>（ClassPath）所指定的类，开发者可以直接使用该类加载器<ul>
<li><code>避免重复加载 + 避免核心类篡改</code></li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20210728123914692.png" alt=""></p>
<blockquote>
<ol>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过Class.forName()方法动态加载， 将类的.class文件加载到jvm中之外，还会<code>对类进行解释</code>，执行类中的static块；</li>
<li>通过ClassLoader.loadClass()方法动态加载， 是<code>将.class文件加载到jvm中</code>，<code>不会执行static中的内容,只有在newInstance才会去执行static块</code>。</li>
</ol>
</blockquote>
<h6 id="2-加载机制"><a href="#2-加载机制" class="headerlink" title=".2. 加载机制"></a>.2. 加载机制</h6><ul>
<li><strong>全盘负责：</strong> 当一个类加载器负责加载某个Class时，<code>该Class所依赖的和引用的其他Class也将由该类加载器负责载入</code>，除非显示使用另外一个类加载器来载入。</li>
<li><strong>缓存机制：</strong> 缓存机制将会保证<code>所有加载过的Class都会被缓存</code>，当程序中需要使用某个Class时，类加载器<code>先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区</code>。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</li>
<li><strong>双亲委派机制:</strong> 如果一个类加载器收到了类加载的请求，它<code>首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成</code>，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，<code>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</code></li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20210728130444041.png" alt=""></p>
<h5 id="9-对象创建"><a href="#9-对象创建" class="headerlink" title=".9. 对象创建"></a>.9. 对象创建</h5><blockquote>
<p>HotSpot VM遇到一条<code>new 类型（）指令时</code>，①首先在<code>常量池中是否</code>有这个类的符号引用(<code>符号引用代表类是否已被加载、解析和初始化过</code>)；②如果没有检测到此类的符号引用就必须先执行相应的<code>类加载过程</code>；3 类加载通过后<code>从Java堆中分配确定大小的内存</code>(分配内存的过程是一个并发进行的过程)；④内存分配完成后，将<code>分配到的内存空间初始化为零值</code>(对象头不初始化–对象头在下面介绍)；5 虚拟机对对象进行必要的设置，并将这些<code>设置信息存放在对象头中</code>；⑥此时就得到了<code>从JVM视角看到的对象</code>；⑦<code>从java程序的角度来看对象才刚刚创建---&lt;init&gt;方法还没有执行，所有的字段都还为0，执行init方法后真正的可用对象产生</code>。</p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210604095009684.png" alt=""></p>
<h5 id="10-对象内存分布"><a href="#10-对象内存分布" class="headerlink" title=".10. 对象内存分布"></a>.10. 对象内存分布</h5><blockquote>
<p>目前主流访问方式有使用<code>句柄和直接指针</code>两种。句柄—从Java堆中划分一块内存作为句柄池，refernece中存储对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息，修改代价小；直接指针—reference中<code>直接存储堆中对象地址</code>，如图二所示，其访问速度更快，节省指针定位的时间开销，HotSpot VM就是采用直接指针方式。</p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20210604100851032.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20210604101002942.png" alt=""></p>
<h5 id="11-OutofMemory错误"><a href="#11-OutofMemory错误" class="headerlink" title=".11. OutofMemory错误"></a>.11. OutofMemory错误</h5><blockquote>
<p>OutOfMemory异常原因：<code>根据报错信息确定出是那个区域发生OutOfMemory异常</code>，然后分析是<code>内存泄露还是内存溢出</code>。</p>
<ul>
<li><code>内存泄漏</code>：与GC Roots相关联并导致GC无法自动回收。</li>
<li><code>内存溢出</code>：众多对象确实还必须活着，导致大量内存被占用而无法GC，当超出限制内存最大值时就抛出OutOfMemory异常。</li>
</ul>
</blockquote>
<h5 id="12-Full-GC"><a href="#12-Full-GC" class="headerlink" title=".12. Full GC"></a>.12. Full GC</h5><blockquote>
<p><strong>Full GC：</strong>无官方定义，通常意义上而言指的是一次特殊 GC 的行为描述，这次 GC 会回收整个堆的<a href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">内存</a>，包含老年代，新生代，metaspace 等。</p>
<ul>
<li>System.gc () 方法的调用</li>
<li>旧生代空间不足。旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行 Full GC 后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。</li>
<li>Permanet Generation 空间满了</li>
</ul>
</blockquote>
<h5 id="12-拷贝"><a href="#12-拷贝" class="headerlink" title=".12. 拷贝"></a>.12. 拷贝</h5><ul>
<li>浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值；如果<code>属性是内存地址</code>（引用类型），拷贝的就是内存地址</li>
<li>深拷贝：会拷贝所有的属性，并<code>拷贝属性指向的动态分配的内存</code>. 可以使用Arrays.copyof()</li>
</ul>
<h5 id="13-反射"><a href="#13-反射" class="headerlink" title=".13. 反射"></a>.13. 反射</h5><blockquote>
<ul>
<li>通过外部类的<code>全路径名创建对象</code>，并使用这些类，实现一些<code>扩展的功能</code>。</li>
<li>反射让开发人员可以<code>枚举出类的全部成员</code>，包括构造函数、属性、方法。以帮助开发者写出正确的代码。</li>
<li>测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率。</li>
</ul>
</blockquote>
<ul>
<li>是JVM 在运行时动态加载类，调用方法或者访问属性，不需要知道运行对象是谁</li>
<li>相关的类：<ul>
<li>class： 每一个类都有一个class对象（类实例），包含类的相关信息</li>
<li>Field：使用get/set 修改或者读取Field相关对象</li>
<li>method：使用<code>invoke方法调用与method相关联的对象</code></li>
<li>Constructor： 使用newInstance()构建对象</li>
<li>Object 类：Object 是所有 Java 类的父类。所有对象都默认实现了 Object 类的方法。</li>
</ul>
</li>
</ul>
<h5 id="14-如何避免内存泄漏"><a href="#14-如何避免内存泄漏" class="headerlink" title=".14. 如何避免内存泄漏"></a>.14. 如何避免内存泄漏</h5><ul>
<li>未对作废数据内存单元置为 null</li>
<li>尽早释放无用对象的引用，</li>
<li>使用临时变量时，让引用变量在推出活动域后自动设置为 null，暗示垃圾收集器收集；</li>
<li>程序避免用 String 拼接，用 StringBuffer，因为每个 String 会占用内存一块区域；</li>
<li>尽量少用静态变量（全局不会回收）；</li>
<li>不要集中创建对象尤其大对象，可以使用流操作；</li>
<li>尽量使用对象池，不再循环中创建对象，优化配置；</li>
<li>创建对象到单例 getInstance 中，对象无法回收被单例引用；</li>
<li>服务器 session 时间设置过长也会引起内存泄漏。</li>
</ul>
<h5 id="15-检查异常-amp-运行时异常"><a href="#15-检查异常-amp-运行时异常" class="headerlink" title=".15. 检查异常&amp;运行时异常"></a>.15. 检查异常&amp;运行时异常</h5><ul>
<li><p>检查异常是在程序中最经常碰到异常，<code>所有继承自 Exception 并且不是运行时异常的异常都是检查异常</code>，比如咱们最常见的 IO 异常和 SQL 异常。这种异常都发生在编译的阶段，Java 编译器强制程序去捕获此类型的异常，即它会把可能会出现这些异常的代码放到 try 块中，把对异常的处理代码放到 catch 块中。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。</p>
</li>
<li><p>运行时异常不同于检查异常，编译器没有强制对其进行捕获并处理，如果不对异常进行处理，那么当出现这种异常的时候，会由 JVM 来处理，比如 NullPointerException 异常，它就是运行时异常。只要程序设计得没有问题通常就不会发生运行时异常。</p>
</li>
</ul>
<h4 id="8-网站"><a href="#8-网站" class="headerlink" title="8. 网站"></a>8. 网站</h4><h5 id="1-网站灰度发布"><a href="#1-网站灰度发布" class="headerlink" title=".1. 网站灰度发布"></a>.1. 网站灰度发布</h5><blockquote>
<p>灰度发布是指在<code>黑与白之间</code>，能够平滑过渡的一种发布方式，<code>AB test 就是一种灰度发布方式</code>，让一部用户继续用 A，一部分用户开始用 B。如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面 来灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度</p>
</blockquote>
<h4 id="9-数据库"><a href="#9-数据库" class="headerlink" title="9. 数据库"></a>9. 数据库</h4><blockquote>
<ul>
<li>内存中，虽然说存取速度快，但是会导致数据不能永久的保存</li>
<li>文件中，可以解决数据永久保存的问题, 速度比内存操作慢，频繁的 IO 操作，而且查询数据不方便</li>
<li>数据库中,  数据可以永久保存，通过使用 SQL 语句，使得查询方便效率高，并且管理数据方便</li>
</ul>
</blockquote>
<h5 id="1-数据库三大范式"><a href="#1-数据库三大范式" class="headerlink" title=".1.  数据库三大范式"></a>.1.  数据库三大范式</h5><p><strong>第一范式（ 1NF）：</strong> <code>字段具有原子性，不可再分</code>。</p>
<p><strong>第二范式（ 2NF）：</strong>是在第一范式（ 1NF） 的基础上建立起来的，要求数据库表中的<code>每个实例或行必须可以被惟一地区分</code>。通常需要为表加上一个列， 以存储各个实例的惟一标识。 这个惟一属性列被称为主关键字或主键。</p>
<p><strong>第三范式（ 3NF）：</strong> 必须先满足第二范式（ 2NF）。 简而言之， 第三范式（ 3NF） 要求<code>一个数据库表中不包含已在其它表中已包含的非主关键字信息</code>。所以第三范式具有如下特征：1， 每一列只有一个值。2， 每一行都能区分。3，<code>每一个表都不包含其他表已经包含的非主关键字信息</code>。</p>
<h5 id="2-数据库事务"><a href="#2-数据库事务" class="headerlink" title=".2. 数据库事务"></a>.2. 数据库事务</h5><ul>
<li><p>事务：主要用于<code>处理操作量大，复杂度高的数据</code>。一般来说，事务是必须满足 4 个条件（ACID）：</p>
<ul>
<li><strong>原子性：</strong>所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>一致性：</strong>在事务开始之前和事务结束以后，<code>数据库的完整性没有被破坏</code>。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li><strong>隔离性：</strong>数据库允许<code>多个并发事务同时对其数据进行读写和修改的能力</code>，隔离性可以防止多个事务并发执行时由于交叉执行，而导致数据的不一致。事务隔离分为不同级别<ul>
<li><code>读未提交 (脏读)</code>：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务<code>未提交的结果</code>。所有的并发事务问题都会发生</li>
<li><code>读提交 (读旧数据，不可重复读问题)</code>：只有在<code>事务提交后</code>，其更新结果才会被其他事务看见。可以解决脏读问题。</li>
<li><code>可重复读</code> (解决了脏读但是有幻影读)：在<code>一个事务中</code>，对<code>于同一份数据的读取结果总是相同的</code>，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。</li>
<li><code>串行化</code>：事务<code>串行化执行</code>，隔离级别最高，<code>牺牲了系统的并发性</code>。可以解决并发事务的所有问题。</li>
</ul>
</li>
<li><strong>持久性：</strong>事务处理结束后，对数据的修改就是<code>永久的</code>，即便系统故障也不会丢失。</li>
</ul>
</li>
<li><p>锁：是实现事务的关键，所可以保证事务的完整性和并发行，与现实生活中的锁一样，可以使某些数据的拥有者，在某段时间内不能使用某些数据或者数据结构。</p>
</li>
</ul>
<h5 id="2-并发事务问题"><a href="#2-并发事务问题" class="headerlink" title=".2. 并发事务问题"></a>.2. 并发事务问题</h5><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<ul>
<li>脏读</li>
<li>不可重复读</li>
<li>写丢弃</li>
<li><h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1></li>
<li>脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是 “脏数据”，依据 “脏数据” 所做的操作可能是不正确的。</li>
<li>丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li>
<li>不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li>幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<h5 id="3-如何解决并发性问题"><a href="#3-如何解决并发性问题" class="headerlink" title=".3. 如何解决并发性问题"></a>.3. 如何解决并发性问题</h5><ul>
<li>版本检查：</li>
<li>共享锁、乐观锁、悲观锁</li>
<li><blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1e47b44c4b6fa78d2ea8908e6b5b9426ded989b4</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h5 id="3-一对多和多对一场景"><a href="#3-一对多和多对一场景" class="headerlink" title=".3. 一对多和多对一场景"></a>.3. 一对多和多对一场景</h5><ul>
<li><p><strong>一对多：</strong>当在数据库的设计中，涉及到一个对象可以包含多个另外对象，而单个另外对象只能对应一个对象时就产生了一对多的关系，例学生和班级，这种情况通常将外键设在多的对象表结构中。</p>
</li>
<li><p><strong>多对多：</strong>当在数据库的设计中，涉及到一个对象可以包含多个另外对象，而单个另外对象也对应多个对象时就产生了多对多的关系，例书籍和作者，这种情况通常将外键设在多的对象表结构中。</p>
</li>
</ul>
<h5 id="4-触发器、函数、视图、存储过程"><a href="#4-触发器、函数、视图、存储过程" class="headerlink" title=".4. 触发器、函数、视图、存储过程"></a>.4. 触发器、函数、视图、存储过程</h5><ul>
<li><strong>触发器:</strong> 使用触发器可以<code>定制用户对表进行【增、删、改】操作时前后的行为</code>，触发器无法由用户直接调用，而由于对表的【增 / 删 / 改】操作被动引发的</li>
<li><strong>函数:</strong> 是 MySQL 数据库提供的<code>内部函数</code> (当然也可以<code>自定义函数</code>)。这些内部函数可以帮助用户更加方便的处理表中的数据, avg, min, count, sum, upper, lower, hour, year</li>
<li><strong>视图:</strong> 视图是<code>虚拟表或逻辑表</code>，它被定义为具有连接的 SQL SELECT 查询语句。</li>
<li><strong>存储过程:</strong> 存储过程是<code>存储在数据库目录中的一堆的声明性 SQL 语句</code>，数据库中的一个重要对象，有效提高了程序的性能</li>
</ul>
<h5 id="5-数据库索引"><a href="#5-数据库索引" class="headerlink" title=".5. 数据库索引"></a>.5. 数据库索引</h5><ul>
<li>唯一索引（<code>UNIQUE</code>）：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li>
<li>主键索引（<code>PRIMARY</code>）：一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。</li>
<li>普通索引（<code>INDEX</code>）：最基本的索引，没有任何限制。</li>
<li>组合索引：多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</li>
</ul>
<h5 id="5-索引数据结构"><a href="#5-索引数据结构" class="headerlink" title=".5. 索引数据结构"></a>.5. 索引数据结构</h5><ul>
<li>B树，B+树，Hash</li>
</ul>
<h5 id="6-主键和外键"><a href="#6-主键和外键" class="headerlink" title=".6. 主键和外键"></a>.6. 主键和外键</h5><ul>
<li><strong>主键：</strong>是指表中一个列或者列的组合，其值能够<code>唯一的标识表中的每一个行</code>。这样的一列或者多列成为表的主键，通过它可以强制表的实体完整性。当创建或者更改表时可以通过定义 <code>PRIMARY KEY</code> 约束来创建主键，<code>一个表只能有一个主键约束，而且主键约束中的列不能是空值</code>，由于主键约束确保唯一数据，所一经常来定义标识列。</li>
<li><strong>外键：</strong>外键是建立于<code>表与表之间的联系</code>。外键保证了数据的完整性，使用外键，简单直观，可以直接在数据模型中体现，无论是设计、维护等。</li>
</ul>
<blockquote>
<p>关于主键自增问题：</p>
<ul>
<li>MyISAM 表会把自增主键的最大 ID 记录到<code>数据文件里</code>，重启 MySQL 自增主键的最大 ID 也不会丢失。</li>
<li>InnoDB 表只是把自增主键的最大 ID 记录到<code>内存中</code>，所以重启数据库或者是对表进行 OPTIMIZE 操作，都会导致最大 ID 丢失。</li>
</ul>
</blockquote>
<h5 id="7-创建索引但是无法命中索引的-8-种情况"><a href="#7-创建索引但是无法命中索引的-8-种情况" class="headerlink" title=".7. 创建索引但是无法命中索引的 8 种情况"></a>.7. 创建索引但是无法命中索引的 8 种情况</h5><ul>
<li>查询条件中有 or、not in、not exist 等</li>
<li>小表查询</li>
<li>like 查询是以 % 开头</li>
<li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引</li>
<li>没有使用索引字段查询</li>
<li>对索引列进行运算，需要建立函数索引</li>
<li>单独引用联合索引中的非第一位置的索引</li>
<li>没有查询条件</li>
</ul>
<h5 id="8-char-和-varchar之间区别"><a href="#8-char-和-varchar之间区别" class="headerlink" title=".8. char 和 varchar之间区别"></a>.8. char 和 varchar之间区别</h5><ul>
<li>char 的<strong>长度</strong>是不可变的，而 varchar 的长度是可变的。</li>
<li>char 的<strong>存取速度</strong>还是要比 varchar 要快得多，因为其长度固定，方便程序的存储与查找；但是 char 也为此付出的是<strong>空间</strong>的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取<strong>时间</strong>效率，而 varchar 是以空间效率为首位的。</li>
<li>char 的<strong>存储方式</strong>是，对英文字符（ASCII）占用 1 个字节，对一个汉字占用两个字节；而 varchar 的存储方式是，对每个英文字符占用 2 个字节，汉字也占用 2 个字节。</li>
</ul>
<h5 id="9-使用limit-offset-为什么越往后越慢"><a href="#9-使用limit-offset-为什么越往后越慢" class="headerlink" title=".9. 使用limit offset 为什么越往后越慢"></a>.9. 使用limit offset 为什么越往后越慢</h5><ul>
<li>原因：越是向后，<code>扫描的数据也就越多</code></li>
<li>解决方案:<ul>
<li>limit 限制优化法：把 limit 偏移量限制低于某个数。超过这个数等于没数据</li>
<li>存储本页数据两端的主键，按主键查找后向前或向后取多少条</li>
</ul>
</li>
</ul>
<h5 id="10-sql注入"><a href="#10-sql注入" class="headerlink" title=".10. sql注入"></a>.10. sql注入</h5><blockquote>
<p>SQL 注入攻击指的是通过构建特殊的输入作为参数传入 Web 应用程序，而这些输入大都是 SQL 语法里的一些组合，通过执行 SQL 语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。</p>
</blockquote>
<h5 id="11-数据库读写分离"><a href="#11-数据库读写分离" class="headerlink" title=".11. 数据库读写分离"></a>.11. 数据库读写分离</h5><blockquote>
<p>很多数据库拥有双机热备功能。也就是，第一台数据库服务器，是<code>对外提供增删改业务的生产服务器</code>；第二台数据库服务器，主要进行<code>读的操作</code>。</p>
</blockquote>
<h5 id="12-红黑树和AVL树"><a href="#12-红黑树和AVL树" class="headerlink" title=".12. 红黑树和AVL树"></a>.12. 红黑树和AVL树</h5><ul>
<li>红黑树不追求 “完全平衡”， 任何不平衡在三次旋转之内解决， 减少频繁的移动，</li>
<li>AVL树： 更平衡，时间效能对读取较高，维护较慢，开销大</li>
</ul>
<blockquote>
<p>动态查找树主要包括：二叉搜索树，平衡二叉树，红黑树，B 树，B - 树时间复杂度 O (log2N)，通过对树高度的降低可以提升查找效率</p>
<ul>
<li>B树以 O (log n) 的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B 树，概括来说是一个节点可以拥有多于 2 个子节点的二叉查找树。</li>
<li><code>B 树的节点可以有很多孩子节点</code>，红黑树是一种近似平衡的二叉搜索树即每个节点只有两个孩子<ul>
<li>每个节点有 M-1 个 key，并且以升序排列</li>
<li>位于 M-1 和 M key 的子节点的值位于 M-1 和 M key 对应的 Value 之间</li>
</ul>
</li>
<li>B + 树<code>内部结点没有指向关键字具体信息的指</code>针，内部结点相对 B 树小<ul>
<li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中</li>
</ul>
</li>
<li>B+树查询稳定：<code>非终端结点并不是指向文件内容的结点，仅仅是作为叶子结点的关键字索引</code>，因此所有的关键字查询都会走一条从根节点到叶子结点的路径。即 s 所有关键字查询的长度是一样的，查询效率稳定。</li>
<li><code>当数据量较小</code>，数据完全可以放入内存中，不需要进行磁盘 IO，这时候，红黑树时间复杂度比 B + 树低。threshold = loadFactor * capacity</li>
</ul>
</blockquote>
<h5 id="12-B树和B-树区别"><a href="#12-B树和B-树区别" class="headerlink" title="12. B树和B+树区别"></a>12. B树和B+树区别</h5><ul>
<li><code>B 树每个节点都存储数据</code>，所有节点组成这棵树。<code>B + 树只有叶子节点存储数据</code>（B + 数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，<code>所有的叶子结点使用链表相连</code>，便于<strong>区间</strong><code>查找和遍历</code>，所<code>有非叶节点起到索</code>引作用。</li>
<li>B + 树中查找，无论查找是否成功，每次都是一条<code>从根节点到叶节点的路径</code>。</li>
<li>B 树中<code>叶节点包含的关键字和其他节点包含的关键字是不重复的</code>，B + 树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li>
</ul>
<h5 id="13-图片在数据库中怎么存储的"><a href="#13-图片在数据库中怎么存储的" class="headerlink" title="13. 图片在数据库中怎么存储的"></a>13. 图片在数据库中怎么存储的</h5><ul>
<li>将<code>图片保存的路径存储到数据库</code>；</li>
<li>将图片以<a href="https://so.csdn.net/so/search?q=二进制&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">二进制</a>数据流的形式直接写入数据库字段中。</li>
</ul>
<h5 id="14-mysql-持久化存储"><a href="#14-mysql-持久化存储" class="headerlink" title="14. mysql 持久化存储"></a>14. mysql 持久化存储</h5><h5 id="15-MVCC"><a href="#15-MVCC" class="headerlink" title="15. MVCC"></a>15. MVCC</h5><blockquote>
<p>可以认为 MVCC 是<code>行级锁的一个变种</code>，innoDB 采用了<code>乐观锁的策略</code>，<code>在每行记录后保存两个隐藏列来实现</code>，这两个<code>列保存了行的版本号信息</code>，每开启一个新事务，<code>版本号自动更新</code>，事务开始时刻的版本号作为事务的版本号。用来和查询到的记录所带的版本号进行比较来判断。</p>
</blockquote>
<p>todo :<a href="https://posts.careerengine.us/p/61762a161590276a0e56a18d" target="_blank" rel="noopener">https://posts.careerengine.us/p/61762a161590276a0e56a18d</a></p>
<h5 id="16-MyISAM-和-InnoDB-引擎"><a href="#16-MyISAM-和-InnoDB-引擎" class="headerlink" title="16. MyISAM 和 InnoDB 引擎"></a>16. MyISAM 和 InnoDB 引擎</h5><ul>
<li><p><strong>InnoDB 引擎</strong>：MySQL 的 5.5 之后的默认引擎，InnoDB 引擎提供了<code>对数据库事务的支持</code>，并且还提供了<code>行级锁和外键的约束</code>，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。由于锁的粒度小，写操作是不会锁定全表的，所以在并发度较高的场景下使用会提升效率的。</p>
</li>
<li><p><strong>MyISAM 引擎</strong>：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即<code>执行写操作的时候需要锁定这个表</code>，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是<code>保存了表的行数</code>，于是当进行 select count (*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>
</li>
<li><p><strong>是否支持行级锁</strong> : MyISAM 只有表级锁 (table-level locking)，而 InnoDB 支持行级锁 (row-level locking) 和表级锁，默认为行级锁，适合高并发操作。</p>
</li>
<li><p><strong>是否支持外键</strong>： MyISAM 不支持，而 InnoDB 支持</p>
</li>
<li><p><strong>是否支持事务</strong>：MyISAM 不支持，而 InnoDB 支持</p>
</li>
<li><p><strong>缓存</strong>：MyISAM 只<code>缓存索引</code>，<code>InnoDB 缓存索引和真实数据</code>，所以对内存要求高</p>
</li>
<li><p><strong>崩溃恢复</strong>：<code>MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多</code>，而且恢复的速度也更慢。</p>
</li>
</ul>
<h5 id="16-where-与-having-的区别"><a href="#16-where-与-having-的区别" class="headerlink" title="16. where 与 having 的区别"></a>16. where 与 having 的区别</h5><ul>
<li><p>用的地方不一样</p>
<p>where 可以用于 select、update、delete 和 insert into values (select * from table where ..) 语句中。</p>
<p><code>having 只能用于 select 语句中</code></p>
</li>
<li><p>执行的顺序不一样</p>
<p><code>where 的搜索条件是在执行语句进行分组之前应用</code></p>
<p><code>having 的搜索条件是在分组条件后执行的</code></p>
<p>即如果 where 和 having 一起用时，where 会先执行，having 后执行</p>
</li>
</ul>
<h5 id="17-批量往-mysql-导入-1000-万数据有什么方法？"><a href="#17-批量往-mysql-导入-1000-万数据有什么方法？" class="headerlink" title=".17. 批量往 mysql 导入 1000 万数据有什么方法？"></a>.17. 批量往 mysql 导入 1000 万数据有什么方法？</h5><ul>
<li>减少 IO 次数</li>
<li><code>SQL 写法优化，一条 SQL 语句插入多条数据</code></li>
<li>合理设置<code>批量大小</code></li>
<li>尽量顺序插入， 减少索引的维护压力</li>
</ul>
<h4 id="10-SpringBoot"><a href="#10-SpringBoot" class="headerlink" title="10. SpringBoot"></a>10. SpringBoot</h4><h5 id="1-IOC-控制反转"><a href="#1-IOC-控制反转" class="headerlink" title=".1. IOC 控制反转"></a>.1. IOC 控制反转</h5><blockquote>
<p> IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/SpringIOC%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt=""></p>
<h5 id="2-AOP"><a href="#2-AOP" class="headerlink" title=".2. AOP"></a>.2. AOP</h5><ul>
<li>AOP(Aspect-Oriented Programming:面向切面编程): 能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</li>
</ul>
<ul>
<li><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，<code>实现了某个接口</code>，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong>生成一个被代理对象的子类来作为代理，如下图所示：</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<h5 id="3-SpringBoot-启动过程"><a href="#3-SpringBoot-启动过程" class="headerlink" title=".3. SpringBoot 启动过程"></a>.3. SpringBoot 启动过程</h5><p>Spring Boot 项目创建完成会默认生成一个名为 *Application 的入口类，我们是通过该类的 main 方法启动 Spring Boot 项目的。在 main 方法中，通过 SpringApplication 的静态方法，即 run 方法进行 SpringApplication 类的实例化操作，然后再针对实例化对象调用另外一个 run 方法来完成整个项目的初始化和启动。</p>
<p><img src="../../../../../picture2022/image-20220317200607725.png" alt=""></p>
<h5 id="4-Spring-SpringMVC-SpringBoot区别"><a href="#4-Spring-SpringMVC-SpringBoot区别" class="headerlink" title=".4. Spring, SpringMVC, SpringBoot区别"></a>.4. Spring, SpringMVC, SpringBoot区别</h5><ul>
<li>Spring 框架就像一个<code>家族</code>，有众多衍生产品例如 boot、security、jpa 等等；但他们的基础都是<code>Spring 的 ioc 和 aop</code>，<code>ioc 提供了依赖注入的容器</code>，<code>aop 解决了面向切面编程</code>，然后在此两者的基础上实现了其他延伸产品的高级功能。</li>
<li>Spring MVC 提供了一种轻度耦合的方式来<code>开发 web 应用</code>；<code>它是 Spring 的一个模块，是一个 web 框架</code>；通过 <code>DispatcherServlet, ModelAndView 和 View Resolver</code>，开发 web 应用变得很容易；解决的问题领域是网站应用程序或者服务开发 ——URL 路由、Session、模板引擎、静态 Web 资源等等。</li>
<li>Spring Boot 实现了<code>auto-configuration 自动配置</code>（另外三大神器 actuator 监控，cli 命令行接口，starter 依赖），降低了项目搭建的复杂度。它主要是为了解决使用 Spring 框架需要<code>进行大量的配置太麻烦的问题</code>，所以它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具；同时它集成了大量常用的第三方库配置 (例如 Jackson, JDBC, Mongo, Redis, Mail 等等)，Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用 (out-of-the-box)。</li>
</ul>
<h5 id="5-IOC实现机制-初始化流程"><a href="#5-IOC实现机制-初始化流程" class="headerlink" title=".5. IOC实现机制 / 初始化流程"></a>.5. IOC实现机制 / 初始化流程</h5><p>主要实现原理就是工厂模式加反射机制。</p>
<p>调用 refresh () 方法：</p>
<ul>
<li>刷新准备，设置开始时间，状态， 初始化占位符等操作</li>
<li>获取内部的 BeanFactory，<code>Spring 容器在启动的时候，先会保存所有注册进来的 Bean 的定义信息， 注册到 BeanFactory 中。</code></li>
<li>设置 BeanFactory 的类加载器和后置处理器，添加几个 BeanPostProcessor，手动注册默认的环境 bean</li>
<li>为子类提供后置处理 BeanFactory 的扩展能力，初始化上下文之前，可以复写 postProcessBeanFactory 这个方法</li>
<li><code>执行 Context 中注册的 BeanFactory 后置处理器，对 SpringBoot 来说，这一步会进行 BeanDefintion 的解析</code></li>
<li>按优先级在 BeanFactory 注册 Bean 的后置处理器，这是在 Bean 初始化前后执行的方法</li>
<li>初始化国际化，事件广播器的模块，注册事件监听器</li>
<li>然后 <strong>Spring 容器就会创建这些非延迟加载的单例 Bean</strong></li>
<li>最后<code>广播事件，ApplicationContext 初始化 / 刷新完成</code></li>
</ul>
<h5 id="6-ApplicationContext-和-BeanFactory-的区别"><a href="#6-ApplicationContext-和-BeanFactory-的区别" class="headerlink" title=".6. ApplicationContext 和 BeanFactory 的区别"></a>.6. ApplicationContext 和 BeanFactory 的区别</h5><ul>
<li>BeanFactory 粗暴简单，可以理解为就是个 <code>HashMap</code>，Key 是 BeanName，Value 是 Bean 实例。通常只提供实例化对象 和获取这两个功能。BeanFactory 在启动的时候不会去实例化 Bean，中有从容器中拿 Bean 的时候才会去实例化。</li>
<li>ApplicationContext（<strong>应用上下文</strong>） 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能，<code>继承了多个接口</code>，因此具备了更多的功能。 <code>如国际化，访问资源，载入多个（有继承关系）上下文 ，消息发送、响应机制，AOP 等。</code></li>
</ul>
<h5 id="7-Springmvc-有哪些组件"><a href="#7-Springmvc-有哪些组件" class="headerlink" title=".7. Springmvc 有哪些组件"></a>.7. Springmvc 有哪些组件</h5><p><strong>1、</strong> 前端控制器 DispatcherServlet（不需要工程师开发）, 由框架提供（重要）</p>
<p>作用：<strong>Spring MVC 的入口函数。接收请求，响应结果，相当于转发器，中央处理器。有了 DispatcherServlet 减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于 mvc 模式中的 c，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</strong></p>
<p><strong>2、处理器映射器 HandlerMapping (不需要工程师开发), 由框架提供</strong></p>
<p>作用：根据请求的 url 查找 Handler。<code>HandlerMapping 负责根据用户请求找到 Handler 即处理器（Controller）</code>，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p><strong>3、处理器适配器 HandlerAdapter</strong></p>
<p>作用：按照特定规则（HandlerAdapter 要求的规则）去执行 Handler 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<p><strong>4、处理器 Handler (需要工程师开发)</strong></p>
<p>注意：编写 Handler 时按照 HandlerAdapter 的要求去做，这样<code>适配器才可以去正确执行 Handler Handler 是继 DispatcherServlet 前端控制器的后端控制器</code>，在<code>DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理</code>。 由于 Handler 涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发 Handler。</p>
<p><strong>5、视图解析器 View resolver (不需要工程师开发), 由框架提供</strong></p>
<p>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 springmvc 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p>
<p><strong>6、视图 View (需要工程师开发)</strong></p>
<p>View 是一个接口，实现类支持不同的 View 类型（jsp、freemarker、pdf…）</p>
<h5 id="8-spring-boot-自动装配过程"><a href="#8-spring-boot-自动装配过程" class="headerlink" title="8. spring boot 自动装配过程"></a>8. spring boot 自动装配过程</h5><blockquote>
<p>Spring Boot 通过 @EnableAutoConfiguration 注解开启自动配置，加载 spring.factories 中注册的各种 AutoConfiguration 类，当某个 AutoConfiguration 类满足其注解 @Conditional 指定的生效条件（Starters 提供的依赖、配置或 Spring 容器中是否存在某个 Bean 等）时，实例化该 AutoConfiguration 类中定义的 Bean（组件等），并注入 Spring 容器，就可以完成依赖框架的自动配置。</p>
</blockquote>
<p><img src="../../../../../picture2022/image-20220317201230425.png" alt=""></p>
<h5 id="9-Post方法不具备幂等性"><a href="#9-Post方法不具备幂等性" class="headerlink" title="9. Post方法不具备幂等性"></a>9. Post方法不具备幂等性</h5><ul>
<li><p>HTTP 方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP 规范也没有办法通过消息格式等语法手段来定义它。</p>
</li>
<li><p>POST 所对应的 URI 并非创建的资源本身，而是资源的接收者。比如：POST <a href="http://www.forum.com/articles" target="_blank" rel="noopener">http://www.forum.com/articles</a> 的语义是在 <a href="http://www.forum.com/articles" target="_blank" rel="noopener">http://www.forum.com/articles</a> 下创建一篇帖子，HTTP 响应中应包含帖子的创建状态以及帖子的 URI。两次相同的 POST 请求会在服务器端创建两份资源，它们具有不同的 URI。所以，POST 方法不具备幂等性。</p>
</li>
</ul>
<h4 id="10-Spring-MVC-执行流程"><a href="#10-Spring-MVC-执行流程" class="headerlink" title="10. Spring MVC 执行流程"></a>10. Spring MVC 执行流程</h4><ol>
<li>整个过程开始于客户端发出的一个 HTTP 请求，Web 应用服务器接收到这个请求。如果<code>匹配 DispatcherServlet 的请求映射路径</code>，则 Web 容器将该请求转交给 DispatcherServlet 处理。</li>
<li>DispatcherServlet 接收到这个请求后，将根据<code>请求的信息</code>（包括 URL、HTTP 方法、请求报文头、请求参数、Cookie 等）及 HandlerMapping 的配置找到<code>处理请求的处理器（Handler）</code>。可将 HandlerMapping 看做路由控制器，将 Handler 看做目标主机。值得注意的是，在 Spring MVC 中并没有定义一个 Handler 接口，实际上任何一个 Object 都可以成为请求处理器。</li>
<li>当 DispatcherServlet 根据 HandlerMapping 得到对应当前请求的 Handler 后，<code>通过 HandlerAdapter 对 Handler 进行封装，再以统一的适配器接口调用 Handler</code>。HandlerAdapter 是 Spring MVC 框架级接口，顾名思义，HandlerAdapter 是一个适配器，它用统一的接口对各种 Handler 方法进行调用。</li>
<li>处理器完成业务逻 辑的处理后，将<code>返回一个 ModelAndView 给 DispatcherServlet</code>，ModelAndView 包含了视图逻辑名和模型数据信息。</li>
<li>ModelAndView 中包含的是 “逻辑视图名” 而非真正的视图对象，DispatcherServlet 借由<code>ViewResolver 完成逻辑视图名到真实视图对象的解析工作。</code></li>
<li>当得到真实的视图对象 View 后，DispatcherServlet 就使用这个 View 对象对 ModelAndView 中的模型数据进行视图渲染。</li>
<li>最终客户端得到的响应消息可能是一个普通的 HTML 页面，也可能是一个 XML 或 JSON 串，甚至是一张图片或一个 PDF 文档等不同的媒体形式。</li>
</ol>
<p><img src="../../../../../picture2022/image-20220317202209317.png" alt=""></p>
<h5 id="11-Bean-作用域"><a href="#11-Bean-作用域" class="headerlink" title="11. Bean 作用域"></a>11. Bean 作用域</h5><p>Bean 在 Spring 容器中是单例的，我们可以通过<code>@Scope</code>注解修改 Bean 的作用域。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td align="left">在 Spring 容器中仅存在一个实例，即 Bean 以单例的形式存在。</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left"><code>每次调用 getBean () 时</code>，都会执行 new 操作，返回一个新的实例。</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left"><code>每次 HTTP 请求</code>都会创建一个新的 Bean。</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left"><code>同一个 HTTP Session</code>共享一个 Bean，不同的 HTTP Session 使用不同的 Bean。</td>
</tr>
<tr>
<td align="left">globalSession</td>
<td align="left"><code>同一个全局的 Session</code>共享一个 Bean，一般用于 Portlet 环境。</td>
</tr>
</tbody></table>
<p><img src="../../../../../picture2022/7EF8F66C3DFA7434E4CA11B47CF8F1F7.png" alt=""></p>
<h5 id="12-Autowired-和-Resource-注解有什么区别？"><a href="#12-Autowired-和-Resource-注解有什么区别？" class="headerlink" title=".12.  @Autowired 和 @Resource 注解有什么区别？"></a>.12.  @Autowired 和 @Resource 注解有什么区别？</h5><ol>
<li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li>
<li>@Autowired 是只能按类型注入，@Resource 默认<code>按名称注入，也支持按类型注入</code>。</li>
<li>@Autowired 按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许 null 值，可以设置它 required 属性为 false，如果我们想使用按名称装配，可以结合 @Qualifier 注解一起使用。@Resource 有两个中重要的属性：name 和 type。name 属性指定 byName，如果没有指定 name 属性，当注解标注在字段上，即默认取字段的名称作为 bean 名称寻找依赖对象，当注解标注在属性的 setter 方法上，即默认取属性名作为 bean 名称寻找依赖对象。需要注意的是，@Resource 如果没有指定 name 属性，并且按照默认的名称仍然找不到依赖对象时， @Resource 注解会回退到按类型装配。但一旦指定了 name 属性，就只能按名称装配了。</li>
</ol>
<h5 id="13-Spring-中默认提供的单例是线程安全的吗？"><a href="#13-Spring-中默认提供的单例是线程安全的吗？" class="headerlink" title=".13. Spring 中默认提供的单例是线程安全的吗？"></a>.13. Spring 中默认提供的单例是线程安全的吗？</h5><p>Spring 容器本身并没有提供 Bean 的线程安全策略。</p>
<ul>
<li>如果单例的 Bean 是一个无状态的 Bean，即线程中的操作不会对 Bean 的成员执行查询以外的操作，那么这个单例的 Bean 是线程安全的。比如，Controller、Service、DAO 这样的组件，通常都是单例且线程安全的。</li>
<li>如果单例的 Bean 是一个有状态的 Bean，则可以采用 ThreadLocal 对状态数据做线程隔离，来保证线程安全。</li>
</ul>
<h5 id="14-Spring-如何管理事务"><a href="#14-Spring-如何管理事务" class="headerlink" title=".14. Spring 如何管理事务"></a>.14. Spring 如何管理事务</h5><ol>
<li>编程式事务：Spring 提供了 TransactionTemplate 模板，利用该模板我们可以通过编程的方式实现事务管理，而无需关注资源获取、复用、释放、事务同步及异常处理等操作。相对于声明式事务来说，这种方式相对麻烦一些，但是好在更为灵活，我们可以将事务管理的范围控制的更为精确。</li>
<li>声明式事务：Spring 事务管理的亮点在于声明式事务管理，它允许我们通过声明的方式，在 IoC 配置中指定事务的边界和事务属性，Spring 会自动在指定的事务边界上应用事务属性。相对于编程式事务来说，这种方式十分的方便，只需要在需要做事务管理的方法上，增加<code>@Transactional 注解，以声明事务特征</code>即可。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">事务传播类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PROPAGATION_REQUIRED</td>
<td align="left">如果当前没有事务，则新建一个事务；如果已存在一个事务，则加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td align="left">PROPAGATION_SUPPORTS</td>
<td align="left">支持当前事务，如果当前没有事务，则以非事务方式执行。</td>
</tr>
<tr>
<td align="left">PROPAGATION_MANDATORY</td>
<td align="left">使用当前的事务，如果当前没有事务，则抛出异常。</td>
</tr>
<tr>
<td align="left">PROPAGATION_REQUIRES_NEW</td>
<td align="left">新建事务，如果当前存在事务，则把当前事务挂起。</td>
</tr>
<tr>
<td align="left">PROPAGATION_NOT_SUPPORTED</td>
<td align="left">以非事务方式执行操作，如果当前存在事务，则把当前事务挂起。</td>
</tr>
<tr>
<td align="left">PROPAGATION_NEVER</td>
<td align="left">以非事务方式执行操作，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td align="left">PROPAGATION_NESTED</td>
<td align="left">如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</td>
</tr>
</tbody></table>
<h4 id="11-C"><a href="#11-C" class="headerlink" title="11. C++"></a>11. <a href="https://www.iamshuaidi.com/2337.html" target="_blank" rel="noopener">C++</a></h4><h5 id="1-构造函数和析构函数"><a href="#1-构造函数和析构函数" class="headerlink" title=".1.  构造函数和析构函数"></a>.1.  构造函数和析构函数</h5><blockquote>
<p>C++ 中构造函数和析构函数<code>只会在编译阶段运行一次</code>，无论你定义了多少不同的构造函数，在一般情况下只会让编译器选择其中一个进行执行，且<code>不会调用构造函数内部其他的构造函数</code>。</p>
<p>（1）<code>创建类类型的新对象</code>，<code>系统会自动调用构造函数</code><br>（2）构造函数是为了<code>保证对象的每个数据成员都被初始化</code></p>
<p>B:没有返回类型 C:没有参数 D:析构函数不能被重载 E:如果没有定义析构函数，编译器将会自动生成一个默认析构函数</p>
</blockquote>
<h5 id="2-动态链接和静态链接区别"><a href="#2-动态链接和静态链接区别" class="headerlink" title=".2.  动态链接和静态链接区别"></a>.2.  动态链接和静态链接区别</h5><ul>
<li>静态链接：编译时直接将需要执行代码拷贝到调用处，体积大，独立运行</li>
<li>动态链接：编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行时加载这些信息，，操作系统负责将需要的动态链接库加载到内存中。   运行需要加载。</li>
</ul>
<h5 id="2-C-编译过程"><a href="#2-C-编译过程" class="headerlink" title=".2. C++ 编译过程"></a>.2. C++ 编译过程</h5><ol>
<li><p>预编译：这个过程主要的处理操作如下：</p>
<p>（1） 将所有的 #define 删除，并且展开所有的宏定义</p>
<p>（2） 处理所有的条件预编译指令，如 #if、#ifdef</p>
<p>（3） 处理 #include 预编译指令，将被包含的文件插入到该预编译指令的位置。</p>
<p>（4） 过滤所有的注释</p>
<p>（5） 添加行号和文件名标识。</p>
</li>
<li><p>编译：这个过程主要的处理操作如下：</p>
<p>（1） 词法分析：将源代码的字符序列分割成一系列的记号。</p>
<p>（2） 语法分析：对记号进行语法分析，产生语法树。</p>
<p>（3） 语义分析：判断表达式是否有意义。</p>
<p>（4） 代码优化：</p>
<p>（5） 目标代码生成：生成汇编代码。</p>
<p>（6） 目标代码优化：</p>
</li>
<li><p>汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。</p>
</li>
<li><p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p>
</li>
</ol>
<h5 id="3-c-和C-区别"><a href="#3-c-和C-区别" class="headerlink" title=".3. c 和C++ 区别"></a>.3. c 和C++ 区别</h5><ul>
<li>C++ 是<code>面向对象</code>的语言，而 C 是<code>面向过程</code>的语言；</li>
<li>C++ 引入 <code>new/delete</code> 运算符，取代了 C 中的 <code>malloc/free</code> 库函数；</li>
<li>C++ 引入<code>引用</code>的概念，而 C 中没有；</li>
<li>C++ 引入<code>类</code>的概念，而 C 中没有；</li>
<li>C++ 引入<code>函数重载</code>的特性，而 C 中没有</li>
<li>C 语言是 C++ 的子集，C++ 可以很好兼容 C 语言。但是 C++ 又有很多<strong>新特性</strong>，如<code>引用、智能指针、auto 变量</code>等。</li>
<li>C++ 是<strong>面对对象</strong>的编程语言；C 语言是<strong>面对过程</strong>的编程语言。</li>
<li>C 语言有一些不安全的语言特性，如<code>指针使用的潜在危险、强制转换的不确定性、内存泄露</code>等。而 C++ 对此增加了不少新特性来<strong>改善安全性</strong>，如 <code>const 常量、引用、cast 转换、智能指针、try—catch</code>等等；</li>
<li>C++ <strong>可复用性</strong>高，C++ 引入了<strong>模板</strong>的概念，后面在此基础上，实现了方便开发的标准模板库 STL。C++ 的 STL 库相对于 C 语言的函数库<strong>更灵活、更通用</strong>。</li>
</ul>
<h5 id="4-变量的声明和定义区别"><a href="#4-变量的声明和定义区别" class="headerlink" title=".4. 变量的声明和定义区别"></a>.4. 变量的声明和定义区别</h5><ul>
<li>定义：为变量分配地址和存储空间，</li>
<li>声明：不分配地址</li>
<li>可以多个声明，只能有一个定义， 一般在具体使用时才初始化</li>
</ul>
<h5 id="5-引用和指针区别"><a href="#5-引用和指针区别" class="headerlink" title=".5. 引用和指针区别"></a>.5. 引用和指针区别</h5><ul>
<li>指针是一个实体，引用是别名</li>
<li>指针可以为空，引用不可以</li>
<li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是<code>指针本身</code>(所指向的变量或对象的地址)的大小；</li>
<li>从内存分配上看：程序为<code>引用变量分配内存区域</code>，而<code>指针不需要分配内存区域</code></li>
<li>指针和引用的自增(++)运算，意义一样</li>
</ul>
<h5 id="6-Struct-和Class-区别"><a href="#6-Struct-和Class-区别" class="headerlink" title=".6. Struct 和Class 区别"></a>.6. Struct 和Class 区别</h5><ul>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是<code>public</code> 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 <code>private</code> 的</li>
<li>struct 一般用于描述一个<code>数据结构集合</code>，而 class 是对一个<code>对象数据的封装</code>；</li>
<li>在继承关系中，struct 默认是公有继承，而 class 是私有继承；</li>
</ul>
<p><img src="../../../../../picture2022/image-20220309205243068.png" alt=""></p>
<h5 id="6-说说-include-头文件的顺序以及双引号-“”-和尖括号-lt-gt-的区别"><a href="#6-说说-include-头文件的顺序以及双引号-“”-和尖括号-lt-gt-的区别" class="headerlink" title=".6. 说说 include 头文件的顺序以及双引号 “” 和尖括号 <> 的区别"></a>.6. 说说 include 头文件的顺序以及双引号 “” 和尖括号 &lt;&gt; 的区别</h5><ol>
<li><p>区别：</p>
<p>（1）尖括号 &lt;&gt; 的头文件是<strong>系统文件</strong>，双引号 “” 的头文件是<strong>自定义文件</strong>。</p>
<p>（2）<code>编译器预处理阶段查找头文件的路径</code>不一样。</p>
</li>
<li><p>查找路径：</p>
<p>（1）使用尖括号 &lt;&gt; 的头文件的查找路径：<code>编译器设置的头文件路径 --&gt; 系统变量</code>。</p>
<p>（2）使用双引号 “” 的头文件的查找路径：<code>当前头文件目录 --&gt; 编译器设置的头文件路径 --&gt; 系统变量</code>。</p>
</li>
</ol>
<h5 id="7-C-多态-静态和动态"><a href="#7-C-多态-静态和动态" class="headerlink" title=".7. C++ 多态(静态和动态)"></a>.7. C++ 多态(静态和动态)</h5><ul>
<li>对<code>不同对象发送同一个消息，不同对象会做出不同的响应</code>。</li>
<li><code>静态多态</code>就是在<code>系统编译期间</code>就可以确定程序执行到这里将要执行哪个函数，例如：<code>函数的重载</code>，对象名加点操作符执行成员函数等，都是静态多态，其中，<code>重载是在形成符号表的时候，对函数名做了区分</code>，从而确定了程序执行到这里将要执行哪个函数，对象名加点操作符执行成员函数是<code>通过 this 指针来调用</code>的。</li>
<li><code>虚函数</code>就是在基类中声明该函数是虚拟的（在函数之前加 virtual 关键字），然后在<code>子类中正式的定义</code>（子类中的该函数的函数名，返回值，函数参数个数，参数类型，全都与基类的所声明的虚函数相同，此时才能称为重写，才符合虚函数，否则就是函数的重载），再<code>定义一个指向基类对象的指针</code>，然后使该<code>指针指向由该基类派生的子类对象</code>，再然后<code>用这个指针来调用改虚函数，就能实现动态多态</code>。</li>
<li>都能够使<code>接口和实现相分离</code>，一个是模板定义接口，类型参数定义实现，一个是基类虚函数定义接口，继承类负责实现；</li>
<li>虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针</li>
</ul>
<p><img src="../../../../../picture2022/image-20220308170550092.png" alt=""></p>
<p><img src="../../../../../picture2022/image-20220308170815576.png" alt=""></p>
<h5 id="8-malloc-和-new-区别"><a href="#8-malloc-和-new-区别" class="headerlink" title=".8. malloc 和 new 区别"></a>.8. malloc 和 new 区别</h5><ul>
<li><code>new/delete</code>是<code>C++ 关键字</code>，需要编译器支持。<code>malloc/free 是库函数，需要头文件支持</code></li>
<li>使用 new 操作符<code>申请内存分配时无须指定内存块的大小</code>，<code>编译器</code>会根据类型信息自行计算。而<code>malloc 则需要显式地指出所需内存的尺寸</code></li>
<li>new 操作符内存分配成功时，<code>返回的是对象类型的指针</code>，类型严格与对象匹配，无须进行类型转换，故 new 是符合类<code>型安全性</code>的操作符。而<code>malloc 内存分配成功则是返回 void *</code>，需要通过<code>强制类型</code>转换将 void * 指针转换成我们需要的类型</li>
<li>new 内存分配失败时，会<code>抛出 bad_alloc 异常</code>。<code>malloc 分配内存失败时返回 NULL</code></li>
</ul>
<blockquote>
<p>new 会先调用 operator new 函数，<code>申请</code>足够的内存（通常<code>底层使用 malloc 实现</code>）。然后<code>调用类型的构造函数，初始化成员变量</code>，最后<code>返回自定义类型指针</code>。delete 先调用<code>析构函数</code>，然后调用 <code>operator delete 函数释放内存</code>（通常底层使用<code>free 实现</code>）。malloc/free 是库函数，只能<code>动态的申请和释放内存</code>，无法强制要求其做自定义类型对象构造和析构工作</p>
</blockquote>
<h5 id="11-智能指针-目的"><a href="#11-智能指针-目的" class="headerlink" title=".11. 智能指针, 目的"></a>.11. 智能指针, 目的</h5><ul>
<li>智能指针的作用是管理一个指针， 申请的空间在函数结束时忘记释放，造成内存泄漏。</li>
<li>能指针是一个类，当<code>超出了类的实例对象的作用域时，会自动调用对象的析构函数</code>，析构函数会自动释放资源。所以智能指针的作用原理就是<code>在函数结束时自动释放内存空间</code>，不需要手动释放内存空间。  // 栈帧不是自己清空的吗</li>
</ul>
<h5 id="12-面向过程和面向对象的区别"><a href="#12-面向过程和面向对象的区别" class="headerlink" title=".12. 面向过程和面向对象的区别"></a>.12. 面向过程和面向对象的区别</h5><ul>
<li>面向过程是一种<code>以事件为中心的编程思想</code>，编程的时候把<code>解决问题的步骤分析出来</code>，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。</li>
<li>面向对象是一种以 “对象” 为中心的编程思想，把要<code>解决的问题分解成各个对象</code>，建立<code>对象的目的不是为了完成一个步骤</code>，而是为了<code>描叙某个对象在整个解决问题的步骤中的属性和行为</code>。</li>
</ul>
<h5 id="13-虚函数，虚函数底层实现原理"><a href="#13-虚函数，虚函数底层实现原理" class="headerlink" title=".13. 虚函数，虚函数底层实现原理"></a>.13. 虚函数，虚函数底层实现原理</h5><blockquote>
<p>在<code>有虚函数的类</code>中，<code>类的最开始部分是一个虚函数表的指针</code>，这个指针指向一个虚函数表，表中放了<code>虚函数的地址</code>，实际的虚函数在代码段 (.text) 中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
</blockquote>
<h5 id="14-重载和重写区别-多个重载如何找到"><a href="#14-重载和重写区别-多个重载如何找到" class="headerlink" title=".14. 重载和重写区别, 多个重载如何找到"></a>.14. 重载和重写区别, 多个重载如何找到</h5><ul>
<li><p>重载：</p>
<ul>
<li>参数列表：被重载的方法<code>必须改变参数列表</code>。</li>
<li>返回类型：可以<code>改变返回类型</code>。</li>
<li>修饰符：可以<code>改变修饰符</code>。</li>
<li>异常：可以声明<code>新的或者更广泛的异常</code>。</li>
</ul>
</li>
<li><p>重写：(多继承)</p>
</li>
<li><ol>
<li>参数列表：必须与被重写方法的<code>参数列表完全匹配</code>。</li>
</ol>
<p>　　2. 返回类型：必须与超类中被重写的方法中声明的返回类型或子类型完全相同<br>　　3. 访问级别：一定不能比被重写方法强，可以比被重写方法的弱。<br>　　4. 非检查异常：重写方法可以抛出任何非检查的异常，无论被重写方法是否声明了该异常。<br>　　5. 检查异常：重写方法一定不能抛出新的检查异常，或比被重写方法声明的检查异常更广的检查异常。<br>　　6. 不能重写标志为 final, static 的方法。</p>
</li>
</ul>
<h5 id="16-类对象的内存分布与生存周期"><a href="#16-类对象的内存分布与生存周期" class="headerlink" title=".16. 类对象的内存分布与生存周期"></a>.16. 类对象的内存分布与生存周期</h5><blockquote>
<ul>
<li><p>在 main () 函数中的显示代码执行之前，会调用一个由编译器生成的_main () 函数，而_main () 函数会进行所有全局对象的的构造及初始化工作。而在 main () 函数结束之前，会调用由编译器生成的 exit 函数，来释放所有的全局对象</p>
</li>
<li><p>垃圾回收的时候，只需要扫描<code>bss 段，data 段</code>以及<code>当前被使用着的栈空间</code>，找到可能是动态内存指针的量，把引用到的内存递归扫描就可以得到当前正在使用的所有动态内存了。</p>
</li>
</ul>
</blockquote>
<h5 id="17-C-内存管理"><a href="#17-C-内存管理" class="headerlink" title=".17. C++ 内存管理"></a>.17. C++ 内存管理</h5><ul>
<li><code>text (代码段)</code>： 用来存放程序<code>执行代码</code>，同时也可能会包含一些<code>常量</code>(如一些字符串常量等）。该段内存为静态分配，只读 (某些架构可能允许修改)</li>
<li><code>data (数据段)</code>：用来存放程序中<code>已经初始化的非零全局变量</code>，静态分配。data 又可分为读写（RW）区域和只读（RO）区域，RO 段保存常量所以也被称为.constdata，RW 段则是普通非常全局变量，静态变量就在其中</li>
<li>bss：存放程序中<code>未初始化的和零值全局变量</code>。静态分配，在程序开始时通常会被清零。</li>
<li>堆：在<code>内存开辟另一块存储区域</code>，般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收</li>
<li>栈：程序<code>运行时由编译器自动分配</code>，存放函数的参数值，局部变量的值等</li>
</ul>
<h5 id="18-内存对齐"><a href="#18-内存对齐" class="headerlink" title=".18. 内存对齐"></a>.18. 内存对齐</h5><ul>
<li>平台原因（移植原因）：<code>不是所有的硬件平台都能访问任意地址上的任意数据的</code>；某些硬件平台只能<code>在某些地址处取某些特定类型的数据，否则抛出硬件异常</code></li>
<li>性能原因：数据结构（尤其是栈）应该尽可能地在<code>自然边界上对齐</code>。原因在于，为了访问未对齐的内存，处理器需要作<code>两次内存访问</code>；而对齐的内存访问仅需要一次访问</li>
</ul>
<p>如何对齐:</p>
<ul>
<li>分配内存的顺序是<code>按照声明的顺序</code></li>
<li>每个变量相对于<code>起始位置的偏移量必须是该变量类型大小的整数倍</code>，不是整数倍空出内存，直到偏移量是整数倍为止</li>
<li>最后整个结构体的大小必须是里面变量类型最大值的整数倍</li>
</ul>
<h5 id="19-类型转化"><a href="#19-类型转化" class="headerlink" title=".19. 类型转化"></a>.19. 类型转化</h5><ol>
<li>const_cast: 用于将 const 变量转为非 const</li>
<li>static_cast: 用于各种隐式转换</li>
<li>dynamic_cast: 用于动态类型转换。只能用于含有虚函数的类</li>
<li>reinterpret_cast: 几乎什么都可以转</li>
</ol>
<h5 id="20-构造函数可以是虚函数"><a href="#20-构造函数可以是虚函数" class="headerlink" title=".20 构造函数可以是虚函数"></a>.20 构造函数可以是虚函数</h5><ul>
<li>析构函数可以，构造函数不行</li>
<li><code>虚函数的调用需要虚函数表指针</code>，而该<code>指针存放在对象的内容空间中</code>；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数 —— 构造函数了。</li>
</ul>
<h5 id="22-类为空的时候编译器怎么初始化？"><a href="#22-类为空的时候编译器怎么初始化？" class="headerlink" title="22. 类为空的时候编译器怎么初始化？"></a>22. 类为空的时候编译器怎么初始化？</h5><ul>
<li>空类是没有数据成员，没有函数的类</li>
<li>空类或者空类对象的大小（无继承情况下）：<code>编译器会在空类中安插一个 char</code>，使得这个<code>空类的两个 objects</code>得以在内存中配置<code>独一无二的地址</code>。只有当一个类为空的时候，编译器才会向该类中加入这样一个 char</li>
<li>空类或者空类对象的大小（有继承但无虚继承情况下）：继承的基类都是空类，<code>大小是 *1*</code>，不管有多少个父类。</li>
<li>空类或者空类对象的大小（单一虚继承情况下）：对每一个虚继承基类，都有一个虚基类索引 <em>(</em>或者偏移量、指针<em>)</em>，占 <em>4</em> 字节</li>
</ul>
<h5 id="23-32-位机和-64-位机的区别"><a href="#23-32-位机和-64-位机的区别" class="headerlink" title="23. 32 位机和 64 位机的区别"></a>23. 32 位机和 64 位机的区别</h5><blockquote>
<p>常的 64 位技术是相对 32 位而言的，这个位数指的是 <code>CPU GPRs (General-Purpose register 通用寄存器) 的数据宽度为 64 位</code>，而 32 位的处理器的通用寄存器的数据宽度为 32 位，64 位指令集就是运行 64 位数据的指令，也就是说一次可以运行 64bit 的数据。</p>
</blockquote>
<h5 id="24-拷贝构造函数和赋值构造函数"><a href="#24-拷贝构造函数和赋值构造函数" class="headerlink" title="24.拷贝构造函数和赋值构造函数"></a>24.拷贝构造函数和赋值构造函数</h5><ul>
<li>都是将一个对象的值复制给另一个对象</li>
<li>拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将<code>对象的值</code>复制给一个<strong>已经存在的实例</strong>。</li>
<li>主要是看是否有<code>新的对象实例产生</code>。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。</li>
</ul>
<h5 id="25-什么是页表，同一进程的不同线程是否共享页表"><a href="#25-什么是页表，同一进程的不同线程是否共享页表" class="headerlink" title="25. 什么是页表，同一进程的不同线程是否共享页表"></a>25. 什么是页表，同一进程的不同线程是否共享页表</h5><blockquote>
<ul>
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位. </li>
<li>线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位</li>
<li>两个<strong>线程</strong>具有各自独立的 PCB，但<strong>共享</strong>同一个<strong>页目录</strong>，也就共享同一个页表和物理页面。所以两个 PCB 共享一个地址空间</li>
</ul>
</blockquote>
<h5 id="26-Static-作用"><a href="#26-Static-作用" class="headerlink" title="26. Static 作用"></a>26. Static 作用</h5><ol>
<li><strong>定义全局静态变量和局部静态变量</strong>：在变量前面加上 static 关键字。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在 BSS 段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；</li>
<li><strong>定义静态函数</strong>：在函数返回类型前加上 static 关键字，函数即被定义为静态函数。静态函数只能在<strong>本源文件</strong>中使用；</li>
<li>类中的 static 静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都<strong>共享</strong>这一块静态存储空间。</li>
<li>当<code>调用一个对象的非静态成员函数时</code>，系统会把<code>该对象的起始地址赋给成员函数的 this 指针</code>。而静态成员函数不属于任何一个对象，因此 C++ 规定静态成员函数没有 this 指针（划重点，面试题常考）。既然它没有指向某一对象，也就<code>无法对一个对象中的非静态成员进行访问</code>。</li>
</ol>
<h4 id="12-分布式"><a href="#12-分布式" class="headerlink" title="12. 分布式"></a>12. 分布式</h4><h5 id="1-分布式系统的特点："><a href="#1-分布式系统的特点：" class="headerlink" title=".1. 分布式系统的特点："></a>.1. 分布式系统的特点：</h5><p>（1）<code>分布性</code><br>（2）<code>对等性</code><br>（3）<code>并发性</code><br>（4）<code>缺乏全局时钟</code><br>（5）<code>故障总是会发生</code></p>
<h5 id="2-分布式面临问题"><a href="#2-分布式面临问题" class="headerlink" title=".2. 分布式面临问题"></a>.2. 分布式面临问题</h5><ul>
<li>通信异常：消息丢失和消息延迟</li>
<li>网络分区：网络不连通，但各个子网络的内部网络是正常的</li>
<li>节点故障：</li>
<li>三态：成功、失败和超时</li>
</ul>
<h5 id="3-CAP-理论"><a href="#3-CAP-理论" class="headerlink" title=".3. CAP 理论"></a>.3. CAP 理论</h5><blockquote>
<p>CAP 理论含义是，一个分布式系统不可能同时满足一致性（C:Consistency)，可用性（A: Availability）和分区容错 性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的2个。</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>C 一致性</td>
<td>分布式系统当中的一致性指的是<code>所有节点的数据一致，或者说是所有副本的数据一致</code></td>
</tr>
<tr>
<td>A 可用性</td>
<td>Reads and writes always succeed. 也就是说<code>系统一直可用</code>，而且<code>服务一直保持正常</code></td>
</tr>
<tr>
<td>P 分区容错性</td>
<td>系统<code>在遇到一些节点或者网络分区故障的时候</code>，<code>仍然能够提供满足一致性和可用性的服务</code></td>
</tr>
</tbody></table>
<h5 id="4-一致性哈希协议"><a href="#4-一致性哈希协议" class="headerlink" title=".4. 一致性哈希协议"></a>.4. 一致性哈希协议</h5><ul>
<li>通过 <code>hash 环</code>来实现负载均衡，将不同的服务器<code>hash 映射到一致性 hash 环上</code>，当服务请求到来时，使用 hash 将其映射到 hash 环上，然后可以采用<code>如顺时针寻找的方法选择距其最近的服务器进行服务</code>。</li>
<li>当服务器较少或 hash 公式不够好时，可能出现大多数请求都会落在同一个服务器上，这就是<code>数据倾斜</code>，可以采<code>用添加服务器、虚拟节点、更换一致性 hash 的方法</code>进行解决。</li>
</ul>
<h5 id="5-docker"><a href="#5-docker" class="headerlink" title=".5.  docker"></a>.5.  docker</h5><ul>
<li>虚拟机通过添加<code>Hypervisor 层，虚拟出网卡、内存、CPU 等虚拟硬件</code>，再在其上建立 虚拟机，每个虚拟机都有自己的系统内核。</li>
<li>而 Docker 容器则是通过<code>隔离的方式，将文件系 统、进程、设备、网络等资源进行隔离</code>，再对权限、CPU 资源等进行控制，最终让容器之间互不影响，</li>
<li>容器无法影响宿主机。<code>容器与宿主机共享内核、文件系统、硬件等资源。</code></li>
</ul>
<h5 id="6-容器要解决基本技术问题"><a href="#6-容器要解决基本技术问题" class="headerlink" title=".6. 容器要解决基本技术问题"></a>.6. 容器要解决基本技术问题</h5><ul>
<li><code>限制每一个容器能够使用资源的数量</code>，不能让单一容器大量消耗 cpu、内存等资源</li>
<li><code>容器间隔离</code>，不能让一个容器无限制的访问其余容器的网络或进程内存</li>
<li><code>文件系统隔离</code>，使用某个镜像建立一个容器，对该容器的文件系统中的文件修改，不能影响其他使用该镜像创建的容器</li>
<li><code>特权分配问题</code>，容器技术本质上是<code>对进程进行权限、资源访问限制</code>。而进程中有时会需要一定的特权保证程序正常运行。</li>
<li>容器间隔离依靠操作系统所提供的 namespace（命名空间）机制</li>
</ul>
<h5 id="6-k8s-架构"><a href="#6-k8s-架构" class="headerlink" title=".6. k8s 架构"></a>.6. k8s 架构</h5><ul>
<li>类似RestAPI 控制接口， 系统资源调度，系统运行监测，网络通信（内部，外部），容器挂载</li>
</ul>
<p><img src="../../../../../picture2022/kubertes-archi.png" alt=""></p>
<ul>
<li>kube-apiserver：通过调用 kube-apiserver 提供的 api 接口，用户可以对集群中的 node、deployments、pods、service 进行管理。我们使用的 kubectl 工具就是通过调用 api 对集群进行的管理。apiserver 是唯一一个会和 etcd 集群进行交互的组件，它会在 etcd 集群中存取数据。</li>
<li>kube-scheduler：对 pods 的部署调度就是这个组件负责的，该组件会<code>对 Worker-Node 的资源进行统计</code>，然后决策应该将 pod 部署在哪一台 Worker-Node 中。</li>
<li>kube-controller-manager：这个里面包含了许多控制程序，这些控制程序会对集群中<code>部署内容的状态进行监控</code>，例如当某个 deployment 的 image 变化时，该组件负责对 pods 进行更新。</li>
<li>kube-proxy：为 pods 和外部用户<code>创建代理网络</code>，使得外部用户能够访问到 pods 中提供的服务。</li>
<li>flannel：是一种<code>网络规划服务</code>，简单来说，通过该服务能够让集群中的各个 docker 容器处于同一个虚拟内网之中。</li>
<li>pause：pause 容器主要用于给 pod 中的各个业务容器共享网络和挂载卷，例如一个 php 容器和一个 mysql 容器，可以同时将自己的网络和一个 pause 容器进行共享。此时，若 mysql 通过 localhost 的 3306 端口对外提供服务，则 php 容器可以通过 localhost:3306 访问到该 mysql 提供的服务。</li>
<li>coredns：集群内部的 dns 服务器。</li>
<li>etcd：<code>键值对数据库，官方提供了两种 master 集群的部署方</code>式，etcd 既可以和 master 节点安装在一起，也可以单独做成一个集群。</li>
</ul>
<h5 id="9-linux-下-i-o-读数据经历了什么"><a href="#9-linux-下-i-o-读数据经历了什么" class="headerlink" title=".9.  linux 下 i/o 读数据经历了什么"></a>.9.  linux 下 i/o 读数据经历了什么</h5><blockquote>
<p><code>准备阶段</code>，即组织通道程序并把<code>通道程序的首地址存入通道地址字</code>中；</p>
<p>启动 I／O 阶段，即用启动 I／O 指令启动通道工作，通道执行通道程序并把执行情况记录在通道状态字中；</p>
<p>结束处理阶段，即完成输入输出操作后形成 I／O 中断，由操作系统做相应的处理。</p>
</blockquote>
<h5 id="12-当需要执行时，使用什么技术自动将程序和数据块移动到物理主存储器中？"><a href="#12-当需要执行时，使用什么技术自动将程序和数据块移动到物理主存储器中？" class="headerlink" title=".12. 当需要执行时，使用什么技术自动将程序和数据块移动到物理主存储器中？"></a>.12. 当需要执行时，使用什么技术自动将程序和数据块移动到物理主存储器中？</h5><ul>
<li>使用<code>虚拟内存技术</code>。它提供了将程序生成的地址转换为正确的主存储器位置的机制。通过<code>映射表转换或映射</code>进行处理。</li>
</ul>
<h5 id="13-如果你现在开发一个缓存服务呢？你会使用什么样的模式？"><a href="#13-如果你现在开发一个缓存服务呢？你会使用什么样的模式？" class="headerlink" title=".13. 如果你现在开发一个缓存服务呢？你会使用什么样的模式？"></a>.13. 如果你现在开发一个缓存服务呢？你会使用什么样的模式？</h5><p><img src="../../../../../picture2022/171910e19430c623tplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" alt="存储器层次结构"></p>
<p><img src="../../../../../picture2022/image-20220308103827022.png" alt=""></p>
<ul>
<li><strong>时间局部性</strong>：被引用过一次的内存位置很可能在不远的将来再被多次引用。</li>
<li><strong>空间局部性</strong>：如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。</li>
</ul>
<h5 id="14-缓存使用场景"><a href="#14-缓存使用场景" class="headerlink" title="14. 缓存使用场景"></a>14. 缓存使用场景</h5><ul>
<li><code>和数据库中的数据结构保持一致</code>，原样缓存： 数据库里面啥样，我缓存也啥样，数据库里面有商品信息，缓存里面也放商品信息，唯一不同的是，数据库里面是全量的商品信息，<code>缓存里面是最热的商品信息</code>。</li>
<li><code>列表排序分页场景的缓存</code>: 可以<code>后台有一个线程</code>，<code>异步的初始化和刷新缓存</code>，在缓存里面保存一个<code>时间戳</code>，当有更新的时候，刷新时间戳，异步任务发现时间戳改变了，就刷新缓存</li>
</ul>
<h5 id="15-缓存存在的问题"><a href="#15-缓存存在的问题" class="headerlink" title="15.  缓存存在的问题"></a>15.  缓存存在的问题</h5><ul>
<li>缓存实时性和一致性问题：当有了写入后咋办？数据保存了多份，数据库一份，缓存中一份，当数据库中因写入而产生了新的数据，往往缓存是不会和数据库操作放在一个事务里面的，如何将新的数据更新到缓存里面，什么时候更新到缓存里面，不同的策略不一样,  <ul>
<li>马上废弃缓存，触发一次数据库的读取，从而更新缓存。有问题，高并发</li>
</ul>
</li>
<li>存的穿透问题：当没有读到咋办？<ul>
<li>冷数据，原来从来没有访问过，所以需要到数据库里面查询一下，然后放入缓存，再返回给客户。</li>
<li>缓存失效了</li>
<li>数据被换出，由于缓存内存是有限的，当使用快满了的时候，就会使用类似 LRU 策略</li>
<li>异步的访问数据库，暂且返回客户一个 fallback 值，然后同时触发一个异步更新，这样下次就有了，这样数据库压力小很多，但是用户就访问不到实时的数据了。</li>
</ul>
</li>
<li><strong>解决思路</strong><ul>
<li>实时策略<ul>
<li><code>读取</code>的过程，应用程序先从 cache 取数据，没有得到，则从<code>数据库中取数据</code>，成功后，放到缓存中。如果命中，应用程序从 cache 中取数据，取到后返回。 <code>数据库有事务性</code></li>
<li><code>写入</code>的过程，把<code>数据存到数据库中</code>，成功后，再让<code>缓存失效</code>，失效后下次读取的时候，会被写入缓存</li>
</ul>
</li>
<li>异步策略:<ul>
<li>读取的时候读不到的时候，不直接访问数据库，而是<code>返回一个 fallback 数据</code>，然后往<code>消息队列里面放入一个数据加载的事件</code>，在背后有一个任务，收到事件后，会异步的读取数据库，由于有队列的作用，可以实现消峰，缓冲对数据库的访问，甚至可以将多个队列中的任务合并请求，合并更新缓存，提高了效率。</li>
<li>一是先更新数据库，然后异步更新缓存。当数据库更新后，同样生成一个异步消息，放入消息队列中，等待背后的任务通过消息进行缓存更新，同样可以实现消峰和任务合并。缺点就是实时性比较差，估计要过一段时间才能看到更新，好处是数据持久性可以得到保证。</li>
<li>一是先更新缓存，然后异步更新数据库。这种方式读取和写入都用缓存，将缓存完全挡在了数据库的前面，把缓存当成了数据库在用。所以一般会使用有持久化机制和主备的 redis，但是仍然不能保证缓存不丢数据，所以这种情况适用于并发量大，但是数据没有那么关键的情况，好处是实时性好。</li>
</ul>
</li>
<li>定时策略<ul>
<li>并发量实在太大，数据量也大的情况，异步都难以满足，可以降级为定时刷新的策略，这种情况下，应用只访问缓存，不访问数据库，更新频率也不高，而且用户要求也不高，例如详情，评论等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="16-高并发系统设计目标"><a href="#16-高并发系统设计目标" class="headerlink" title="16. 高并发系统设计目标"></a>16. 高并发系统设计目标</h5><h6 id="1-宏观目标"><a href="#1-宏观目标" class="headerlink" title="1. 宏观目标"></a>1. 宏观目标</h6><ol>
<li><code>高性能</code>：性能体现了系统的并行处理能力，在有限的硬件投入下，提高性能意味着节省成本。同时，性能也反映了用户体验，响应时间分别是 100 毫秒和 1 秒，给用户的感受是完全不同的。</li>
<li><code>高可用</code>：表示系统可以正常服务的时间。一个全年不停机、无故障；另一个隔三差五出线上事故、宕机，用户肯定选择前者。另外，如果系统只能做到 90% 可用，也会大大拖累业务。</li>
<li><code>高扩展</code>：表示系统的扩展能力，流量高峰时能否在短时间内完成扩容，更平稳地承接峰值流量，比如双 11 活动、明星离婚等热点事件。</li>
</ol>
<h6 id="2-性能指标"><a href="#2-性能指标" class="headerlink" title="2. 性能指标"></a>2. 性能指标</h6><ol>
<li><code>平均响应时间</code>：最常用，但是缺陷很明显，对于慢请求不敏感。比如 1 万次请求，其中 9900 次是 1ms，100 次是 100ms，则平均响应时间为 1.99ms，虽然平均耗时仅增加了 0.99ms，但是 1% 请求的响应时间已经增加了 100 倍。</li>
<li><code>TP90、TP99 等分位值</code>：将响应时间按照从小到大排序，<code>TP90 表示排在第 90 分位的响应时间</code>， 分位值越大，对慢请求越敏感。</li>
<li><code>吞吐量</code>：和响应时间呈反比，比如响应时间是 1ms，则吞吐量为每秒 1000 次。</li>
</ol>
<h6 id="3-高并发实现方案"><a href="#3-高并发实现方案" class="headerlink" title="3. 高并发实现方案"></a>3. 高并发实现方案</h6><ul>
<li><p>纵向扩展：</p>
<ul>
<li>提升<code>单机的硬件性能</code>：通过增加内存、CPU 核数、存储容量、或者将磁盘升级成 SSD 等堆硬件的方式来提升。</li>
<li>提升<code>单机的软件性能</code>：使用缓存减少 IO 次数，使用并发或者异步的方式增加吞吐量。</li>
</ul>
</li>
<li><p>横向扩展：</p>
<ul>
<li>做好分层架构</li>
</ul>
<p><img src="../../../../../picture2022/image-20220317195448563.png" alt=""></p>
<ol>
<li>集群部署，通过负载均衡减轻单机压力。</li>
<li>多级缓存，包括静态数据使用 CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点 key、缓存穿透、缓存并发、数据一致性等问题的处理。</li>
<li>分库分表和索引优化，以及借助搜索引擎解决复杂查询问题。</li>
<li>考虑 NoSQL 数据库的使用，比如 HBase、TiDB 等，但是团队必须熟悉这些组件，且有较强的运维能力。</li>
<li>异步化，将次要流程通过多线程、MQ、甚至延时任务进行异步处理。</li>
<li>限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、Nginx 接入层的限流、服务端的限流。</li>
<li>对流量进行削峰填谷，通过 MQ 承接流量。</li>
<li>并发处理，通过多线程将串行逻辑并行化。</li>
<li>预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。</li>
<li>缓存预热，通过异步任务提前预热数据到本地缓存或者分布式缓存中。</li>
<li>减少 IO 次数，比如数据库和缓存的批量读写、RPC 的批量接口支持、或者通过冗余数据的方式干掉 RPC 调用。</li>
<li>减少 IO 时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存 key 的大小、压缩缓存 value 等。</li>
<li>程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For 循环的计算逻辑优化，或者采用更高效的算法。</li>
<li>各种池化技术的使用和池大小的设置，包括 HTTP 请求池、线程池（考虑 CPU 密集型还是 IO 密集型设置核心参数）、数据库和 Redis 连接池等。</li>
<li>JVM 优化，包括新生代和老年代的大小、GC 算法的选择等，尽可能减少 GC 频率和耗时。</li>
<li>锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。</li>
</ol>
</li>
</ul>
<h5 id="17-分布式存储"><a href="#17-分布式存储" class="headerlink" title="17. 分布式存储"></a>17. 分布式存储</h5><h6 id="1-中间控制节点架构（HDFS）"><a href="#1-中间控制节点架构（HDFS）" class="headerlink" title=".1. 中间控制节点架构（HDFS）"></a>.1. 中间控制节点架构（HDFS）</h6><p><img src="../../../../../picture2022/image-20220317195723140.png" alt=""></p>
<p>从 namenode 获取该文件的位置（具体在哪个 datanode），然后从该位置获取具体的数据。在该架构中 namenode 通常是主备部署，而 datanode 则是由大量节点构成一个集群。</p>
<h6 id="2-完全无中心架构-—-计算模式（Ceph）"><a href="#2-完全无中心架构-—-计算模式（Ceph）" class="headerlink" title=".2. 完全无中心架构 — 计算模式（Ceph）"></a>.2. 完全无中心架构 — 计算模式（Ceph）</h6><p><img src="../../../../../picture2022/image-20220317195707784.png" alt=""></p>
<ul>
<li>OSD 服务用于实现对磁盘的管理，实现真正的数据读写，通常一个磁盘对应一个 OSD 服务。</li>
<li>Mon 服务通过集群的方式保证其服务的可用性。</li>
<li>客户端访问存储的大致流程是，客户端在启动后会首先<code>从 Mon 服务拉取存储资源布局信息</code>，然后根据该<code>布局信息和写入数据的名称等信息计算出期望数据的位置</code>（包含具体的物理服务器信息和磁盘信息），然后该位置信息直接通信，读取或者写入数据。</li>
</ul>
<h6 id="3-完全无中心架构-—-一致性哈希（Swift）"><a href="#3-完全无中心架构-—-一致性哈希（Swift）" class="headerlink" title=".3. 完全无中心架构 — 一致性哈希（Swift）"></a>.3. 完全无中心架构 — 一致性哈希（Swift）</h6><p><img src="../../../../../picture2022/image-20220317195947155.png" alt=""></p>
<h5 id="18-分布式事务"><a href="#18-分布式事务" class="headerlink" title="18. 分布式事务"></a>18. 分布式事务</h5><blockquote>
<p>分布式事务就是指<code>事务的参与者</code>、<code>支持事务的服务器</code>、<code>资源服务器</code>以及<code>事务管理器</code>分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证<code>不同数据库的数据一致性</code>。</p>
</blockquote>
<h6 id="1-2PC"><a href="#1-2PC" class="headerlink" title=".1. 2PC"></a>.1. 2PC</h6><h5 id="19-raft-paxos"><a href="#19-raft-paxos" class="headerlink" title="19. raft/paxos"></a>19. raft/paxos</h5><h3 id="10-Hadoop-相关"><a href="#10-Hadoop-相关" class="headerlink" title="10. Hadoop 相关"></a>10. <a href="https://jishuin.proginn.com/p/763bfbd2f819" target="_blank" rel="noopener">Hadoop 相关</a></h3><blockquote>
<p>Hadoop 是一个能够对大量数据进行分布式处理的软件框架。以一种可靠、高效、可伸缩的方式进行数据处理。主要包括三部分内容：<code>Hdfs，MapReduce，Yarn</code></p>
</blockquote>
<h4 id="1-hadoop-和-spark-区别"><a href="#1-hadoop-和-spark-区别" class="headerlink" title="1. hadoop 和 spark 区别"></a>1. hadoop 和 spark 区别</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Hadoop</th>
<th>Spark</th>
</tr>
</thead>
<tbody><tr>
<td align="left">类型</td>
<td align="left">基础平台，包含计算，存储，调度</td>
<td>分布式计算工具</td>
</tr>
<tr>
<td align="left">场景</td>
<td align="left">大规模数据集上的<code>批处理</code></td>
<td>迭代计算，交互式计算，<code>流计算</code></td>
</tr>
<tr>
<td align="left">价格</td>
<td align="left">对机器要求低，便宜</td>
<td><code>对内存有要求，相对较贵</code></td>
</tr>
<tr>
<td align="left">编程范式</td>
<td align="left">MapReduce，API 较为<code>底层</code>，算法适应性差</td>
<td>RDD 组成 DAG 有向无环图，API 较为<code>顶层</code>，方便使用</td>
</tr>
<tr>
<td align="left">数据存储结构</td>
<td align="left">MapReduce 中间计算结果存在 HDFS 磁盘上，延迟大</td>
<td>RDD 中间运算结果存在内存中，延迟小</td>
</tr>
<tr>
<td align="left">运行方式</td>
<td align="left">Task 以进程方式维护，任务启动慢</td>
<td>Task 以线程方式维护，任务启动快</td>
</tr>
</tbody></table>
<h4 id="2-介绍-Hadoop1-0，2-0，3-0-的区别"><a href="#2-介绍-Hadoop1-0，2-0，3-0-的区别" class="headerlink" title="2. 介绍 Hadoop1.0，2.0，3.0 的区别"></a>2. 介绍 Hadoop1.0，2.0，3.0 的区别</h4><ul>
<li>Hadoop1.0 由分布式存储系统 HDFS 和分布式计算框架 MapReduce 组成，其中 HDFS 由一个 NameNode 和多个 DateNode 组成，MapReduce 由一个 JobTracker 和多个 TaskTracker 组成。在 Hadoop1.0 中容易导致<code>单点故障，拓展性差，性能低，支持编程模型单一</code>的问题。</li>
<li>Hadoop2.0 即为克服 Hadoop1.0 中的不足，提出了以下关键特性：<ul>
<li>Yarn：它是 Hadoop2.0 引入的一个全新的通用资源管理系统，完全代替了 Hadoop1.0 中的 JobTracker。在 MRv1 中的 JobTracker 资源管理和作业跟踪的功能被抽象为 ResourceManager 和 AppMaster 两个组件。Yarn 还支持多种应用程序和框架，提供统一的资源调度和管理功能</li>
<li>NameNode 单点故障得以解决：Hadoop2.2.0 同时解决了 NameNode 单点故障问题和内存受限问题，并提供 <code>NFS，QJM 和 Zookeeper 三种可选的共享存储系统</code></li>
<li><code>HDFS 快照</code>：指 HDFS（或子系统）在某一时刻的只读镜像，该只读镜像对于防止数据误删、丢失等是非常重要的。例如，管理员可定时为重要文件或目录做快照，当发生了数据误删或者丢失的现象时，管理员可以将这个数据快照作为恢复数据的依据</li>
<li>支持 Windows 操作系统：Hadoop 2.2.0 版本的一个重大改进就是开始支持 Windows 操作系统</li>
<li>Append：新版本的 Hadoop 引入了对文件的追加操作</li>
</ul>
</li>
<li>Hadoop3.0 是直接基于 JDK1.8 发布的一个新版本<ul>
<li><code>HDFS 可擦除编码</code>：这项技术使 HDFS 在不降低可靠性的前提下节省了很大一部分存储空间</li>
<li><code>多 NameNode 支持</code>：在 Hadoop3.0 中，新增了对多 NameNode 的支持。当然，<code>处于 Active 状态的 NameNode 实例必须只有一个</code>。也就是说，从 Hadoop3.0 开始，在同一个集群中，支持一个 ActiveNameNode 和 多个 StandbyNameNode 的部署方式。</li>
<li>MR Native Task 优化</li>
<li><code>Yarn 基于 cgroup 的内存和磁盘 I/O 隔离</code></li>
<li><code>Yarn container resizing</code></li>
</ul>
</li>
</ul>
<h4 id="3-Hadoop-读写流程"><a href="#3-Hadoop-读写流程" class="headerlink" title="3. Hadoop 读写流程"></a>3. Hadoop 读写流程</h4><p><img src="../../../../../picture2022/image-20220317215640867.png" alt=""></p>
<p><img src="../../../../../picture2022/image-20220317215806337.png" alt=""></p>
<h4 id="4-Shuffler过程"><a href="#4-Shuffler过程" class="headerlink" title="4. Shuffler过程"></a>4. Shuffler过程</h4><p><img src="../../../../../picture2022/658187cd34c8b8aceadf8d57b6efb313.webp" alt=""></p>
<ol>
<li>Map 方法之后 Reduce 方法之前这段处理过程叫<strong>「Shuffle」</strong></li>
<li>Map 方法之后，<code>数据首先进入到分区方法</code>，<code>把数据标记好分区，然后把数据发送到环形缓冲区</code>；环形缓冲区默认大小 100m，环形缓冲区达到 80% 时，进行溢写；<code>溢写前对数据进行排序，排序按照对 key 的索引进行字典顺序排序</code>，排序的手段<strong>「快排」</strong>；溢写产生大量溢写文件，需要对溢写文件进行<strong>「归并排序」</strong>；对溢写的文件也可以进行 Combiner 操作，前提是汇总操作，求平均值不行。最后将文件按照分区存储到磁盘，等待 Reduce 端拉取。</li>
<li>每个 Reduce 拉取 Map 端对应分区的数据。拉取数据后先存储到内存中，内存不够了，再存储到磁盘。拉取完所有数据后，采用归并排序将内存和磁盘中的数据都进行排序。在进入 Reduce 方法前，可以对数据进行分组操作。</li>
</ol>
<h4 id="5-HDFS-小文件影响"><a href="#5-HDFS-小文件影响" class="headerlink" title="5. HDFS 小文件影响"></a>5. HDFS 小文件影响</h4><ul>
<li>影响 NameNode 的寿命，因为文件元数据存储在 NameNode 的内存中</li>
<li>影响计算引擎的任务数量，比如每个小的文件都会生成一个 Map 任务</li>
</ul>
<h4 id="6-Yarn-的Job提交流程"><a href="#6-Yarn-的Job提交流程" class="headerlink" title="6. Yarn 的Job提交流程"></a>6. Yarn 的Job提交流程</h4><p><img src="../../../../../picture2022/image-20220317220638948.png" alt=""></p>
<p><img src="../../../../../picture2022/image-20220317220717291.png" alt=""></p>
<ol>
<li>client 向 RM 提交应用程序，其中包括启动该应用的 ApplicationMaster 的必须信息，例如 ApplicationMaster 程序、启动 ApplicationMaster 的命令、用户程序等</li>
<li><code>ResourceManager 启动一个 container 用于运行 ApplicationMaster</code></li>
<li><code>启动中的 ApplicationMaster 向 ResourceManager 注册自己，启动成功后与 RM 保持心跳</code></li>
<li>ApplicationMaster 向 ResourceManager 发送请求，申请相应数目的 container</li>
<li>申请成功的 container，由 ApplicationMaster 进行初始化。container 的启动信息初始化后，AM 与对应的 NodeManager 通信，要求 NM 启动 container</li>
<li>NM 启动 container</li>
<li>container 运行期间，ApplicationMaster 对 container 进行监控。container 通过 RPC 协议向对应的 AM 汇报自己的进度和状态等信息</li>
<li>应用运行结束后，ApplicationMaster 向 ResourceManager 注销自己，并允许属于它的 container 被收回</li>
</ol>
<h3 id="10-设计类题目"><a href="#10-设计类题目" class="headerlink" title="10. 设计类题目"></a>10. 设计类题目</h3><h4 id="1-秒杀系统相关问题"><a href="#1-秒杀系统相关问题" class="headerlink" title=".1. 秒杀系统相关问题"></a>.1. 秒杀系统相关问题</h4><h5 id="1-秒杀存在问题"><a href="#1-秒杀存在问题" class="headerlink" title="1. 秒杀存在问题"></a>1. 秒杀存在问题</h5><ol>
<li><code>超卖问题</code>：分析秒杀的业务场景，最重要的有一点就是超卖问题，假如备货只有 100 个，但是最终超卖了 200，一般来讲秒杀系统的价格都比较低，如果超卖将严重影响公司的财产利益，因此首当其冲的就是解决商品的超卖问题。</li>
<li><code>高并发</code>：秒杀具有时间短、并发量大的特点，秒杀持续时间只有几分钟，而一般公司都为了制造轰动效应，会以极低的价格来吸引用户，因此参与抢购的用户会非常的多。短时间内会有大量请求涌进来，后端如何防止并发过高造成缓存击穿或者失效，击垮数据库都是需要考虑的问题。</li>
<li><code>接口防刷</code>：现在的秒杀大多都会出来针对秒杀对应的软件，这类软件会模拟不断向后台服务器发起请求，一秒几百次都是很常见的，如何防止这类软件的重复无效请求，防止不断发起的请求也是需要我们针对性考虑的。</li>
<li><code>秒杀 URL</code>：对于普通用户来讲，看到的只是一个比较简单的秒杀页面，在未达到规定时间，秒杀按钮是灰色的，一旦到达规定时间，灰色按钮变成可点击状态。这部分是针对小白用户的，如果是稍微有点电脑功底的用户，会通过 F12 看浏览器的 network 看到秒杀的 url，通过特定软件去请求也可以实现秒杀。或者提前知道秒杀 url 的人，一请求就直接实现秒杀了。这个问题我们需要考虑解决。</li>
<li><code>数据库设计</code>：秒杀有把我们服务器击垮的风险，如果让它与我们的其他业务使用在同一个数据库中，耦合在一起，就很有可能牵连和影响其他的业务。如何防止这类问题发生，就算秒杀发生了宕机、服务器卡死问题，也应该让他尽量不影响线上正常进行的业务。</li>
</ol>
<h5 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h5><ol>
<li><code>使用 nginx</code>：nginx 是一个高性能 web 服务器，它的并发能力可以达到几万，而 tomcat 只有几百。通过 nginx 映射客户端请求，再分发到后台 tomcat 服务器集群中可以大大提升并发能力。</li>
<li><code>服务降级</code>：通过 Hystrix 进行服务熔断和降级，可以开发一个备用服务，假如服务器真的宕机了，直接给用户一个友好的提示返回，而不是直接卡死，服务器错误等生硬的反馈。</li>
<li><code>异步下单</code>：使用队列，队列最显著的三个优点：异步、削峰、解耦。这里可以采用 rabbitmq，在后台经过了限流、库存校验之后，流入到这一步骤的就是有效请求。然后发送到队列里，队列接受消息，异步下单。下完单，入库没有问题可以用短信通知用户秒杀成功。假如失败的话，可以采用补偿机制，重试。</li>
<li><code>接口限流</code>：<ol>
<li><code>前端限流</code>：首先第一步就是通过前端限流，用户在秒杀按钮点击以后发起请求，那么在接下来的 5 秒是无法点击（通过设置按钮为 disable）。这一小举措开发起来成本很小，但是很有效。</li>
<li><code>同一个用户 x 秒内重复请求直接拒绝</code>：具体多少秒需要根据实际业务和秒杀的人数而定，一般限定为 10 秒。具体的做法就是通过 redis 的键过期策略，首先对每个请求都从 String value = redis.get(userId);。如果获取到这个 value 为空或者为 null，表示它是有效的请求，然后放行这个请求。如果不为空表示它是重复性请求，直接丢掉这个请求。如果有效，采用 redis.setexpire(userId,value,10).value 可以是任意值，一般放业务属性比较好，这个是设置以 userId 为 key，10 秒的过期时间（10 秒后，key 对应的值自动为 null）。</li>
<li><code>令牌桶算法限流</code>：接口限流的策略有很多，我们这里采用令牌桶算法。令牌桶算法的基本思路是每个请求尝试获取一个令牌，后端只处理持有令牌的请求，生产令牌的速度和效率我们都可以自己限定。</li>
</ol>
</li>
</ol>
<h4 id="2-认证方面"><a href="#2-认证方面" class="headerlink" title=".2. 认证方面"></a>.2. 认证方面</h4><h5 id="1-移动端基于-token-的认证机制"><a href="#1-移动端基于-token-的认证机制" class="headerlink" title="1. 移动端基于 token 的认证机制"></a>1. 移动端基于 token 的认证机制</h5><p>基于 token 的认证机制，只有在第一次使用需要输入账号密码，后续使用将不在输入账号密码。其实在登陆的时候不仅传入<code>账号、密码，还传入了手机的设备信息</code>。在服务端验证账号、密码正确后，服务端会做两件事。</p>
<ol>
<li><code>将账号与设备关联起来</code>，在某种意义上，设备信息就代表着账号。</li>
<li><code>生成一个 token 令牌，并且在 token 与账号、设备关联</code>，类似于 key/value，token 作为 key ，账号、设备信息作为 value，持久化在磁盘上。</li>
</ol>
<p>将 token 返回给移动端，移动端将 token 存入在本地，往后移动端都通过 token 访问服务端 API ，当然除了 token 之外，还需要携带设备信息，因为 token 可能会被劫持。带上设备信息之后，就算 token 被劫持也没有关系，因为设备信息是唯一的。</p>
<h5 id="2-单点登录"><a href="#2-单点登录" class="headerlink" title="2. 单点登录"></a>2. 单点登录</h5><blockquote>
<p>单点登录全称 Single Sign On（以下简称 SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。</p>
</blockquote>
<p><code>间接授权通过令牌</code>实现，sso 认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p>
<ol>
<li>用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数；</li>
<li>sso 认证中心发现用户未登录，将用户引导至登录页面；</li>
<li>用户输入用户名密码提交登录申请；</li>
<li>sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为<code>全局会话，同时创建授权令牌</code>；</li>
<li>sso 认证中心带着令牌跳转会最初的请求地址（系统 1）；</li>
<li>系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效；</li>
<li>sso 认证中心校验令牌，返回有效，注册系统 1；</li>
<li>系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源；</li>
<li>用户访问系统 2 的受保护资源；</li>
<li>系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数；</li>
<li>sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌；</li>
<li>系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效；</li>
<li>sso 认证中心校验令牌，返回有效，注册系统 2；</li>
<li>系统 2 使用该令牌创建与用户的局部会话，返回受保护资源。</li>
</ol>
<h4 id="3-如何设计本地缓存"><a href="#3-如何设计本地缓存" class="headerlink" title="3. 如何设计本地缓存"></a>3. <a href="https://www.nowcoder.com/tutorial/94/cdcd4f0590d24d0490c97892da2b0a14" target="_blank" rel="noopener">如何设计本地缓存</a></h4><ol>
<li><p><code>数据结构</code></p>
<p>首要考虑的就是数据该如何存储，用什么数据结构存储。最简单的就直接用 Map 来存储数据，或者复杂的如 redis 一样提供了多种数据类型哈希，列表，集合，有序集合等，底层使用了双端链表，压缩列表，集合，跳跃表等数据结构。</p>
</li>
<li><p><code>对象上限</code></p>
<p>因为是本地缓存，内存有上限，所以一般都会指定缓存对象的数量比如 1024，当达到某个上限后需要有某种策略去删除多余的数据。</p>
</li>
<li><p><code>清除策略</code></p>
<p>上面说到当达到对象上限之后需要有清除策略，常见的比如有 LRU (最近最少使用)、FIFO (先进先出)、LFU (最近最不常用)、SOFT (软引用)、WEAK (弱引用) 等策略。</p>
</li>
<li><p><code>过期时间</code></p>
<p>除了使用清除策略，一般本地缓存也会有一个过期时间设置，比如 redis 可以给每个 key 设置一个过期时间，这样当达到过期时间之后直接删除，采用清除策略 + 过期时间双重保证。</p>
</li>
<li><p><code>线程安全</code></p>
<p>像 redis 是直接使用单线程处理，所以就不存在线程安全问题。而我们现在提供的本地缓存往往是可以多个线程同时访问的，所以线程安全是不容忽视的问题，并且线程安全问题是不应该抛给使用者去保证。</p>
</li>
<li><p><code>简明的接口</code></p>
<p>提供一个傻瓜式的对外接口是很有必要的，对使用者来说使用此缓存不是一种负担而是一种享受，提供常用的 get，put，remove，clear，getSize 等方法即可。</p>
</li>
<li><p><code>是否持久化</code></p>
<p>这个其实不是必须的，是否需要将缓存数据持久化看需求。本地缓存如 ehcache 是支持持久化的，而 guava 是没有持久化功能的。分布式缓存如 redis 是有持久化功能的，memcached 是没有持久化功能的。</p>
</li>
<li><p><code>阻塞机制</code></p>
<p>我们使用缓存的目的就是因为被缓存的数据生成比较费时，比如调用对外的接口，查询数据库，计算量很大的结果等等。这时候如果多个线程同时调用 get 方法获取的结果都为 null，每个线程都去执行一遍费时的计算，其实也是对资源的浪费。最好的办法是只有一个线程去执行，其他线程等待，计算一次就够了。但是此功能基本上都交给使用者来处理，很少有本地缓存有这种功能。</p>
</li>
</ol>
<h4 id="4-ID-全局唯一且自增"><a href="#4-ID-全局唯一且自增" class="headerlink" title="4. ID 全局唯一且自增"></a>4. ID 全局唯一且自增</h4><p>SnowFlake 雪花算法：雪花 ID 生成的是一个 64 位的二进制正整数，然后转换成 10 进制的数。64 位二进制数由如下部分组成：</p>
<ul>
<li><code>1 位标识符</code>：始终是 0，由于 long 基本类型在 Java 中是带符号的，最高位是符号位，正数是 0，负数是 1，所以 id 一般是正数，最高位是 0。</li>
<li><code>41 位时间戳</code>：41 位时间截不是存储当前时间的时间截，而是<code>存储时间截的差值</code>（当前时间截 - 开始时间截 ) 得到的值，这里的的开始时间截，一般是我们的<code>id 生成器开始使用的时间</code>，由我们程序来指定的。</li>
<li><code>10 位机器标识码</code>：可以部署在 1024 个节点，如果机器分机房（IDC）部署，这 10 位可以由 5 位机房 ID + 5 位机器 ID 组成。</li>
<li><code>12 位序列</code>：毫秒内的计数，12 位的计数顺序号支持每个节点每毫秒 (同一机器，同一时间截) 产生 4096 个 ID 序号</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>简单高效，生成速度快。</li>
<li>时间戳在高位，自增序列在低位，整个 ID 是趋势递增的，按照时间有序递增。</li>
<li>灵活度高，可以根据业务需求，调整 bit 位的划分，满足不同的需求。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><code>依赖机器的时钟</code>，如果服务器时钟回拨，会导致重复 ID 生成。</li>
<li><code>在分布式环境</code>上，<code>每个服务器的时钟不可能完全同步</code>，有时会出现不是全局递增的情况。</li>
</ul>
<h3 id="9-技能篇"><a href="#9-技能篇" class="headerlink" title="9. 技能篇"></a>9. 技能篇</h3><h4 id="1-Java-1"><a href="#1-Java-1" class="headerlink" title=".1. Java"></a>.1. Java</h4><ul>
<li>熟练掌握Java基础，集合等相关知识，了解常见的设计模式。</li>
<li>熟悉JVM的垃圾回收机制、类加载机制及Java的内存区域。</li>
<li>熟悉Java并发编程，掌握JUC中常用的工具类，如ConcurrentHashMap等，熟悉多线程，线程池，</li>
<li>Java内存模型。</li>
<li>熟悉OSI七层模型和TCP/IP四层体系分层结构，掌握常见网络协议，如HTTP/HTTPS 、TCP、</li>
<li>UDP、DNS等。</li>
<li>熟练使用 MySQL，熟悉 MySQL 索引、事务、存储引擎、锁机制。</li>
<li>熟悉操作系统的进程通信、死锁、内存管理等知识。</li>
<li>熟悉Redis数据类型使用场景和内部实现，熟悉持久化和过期淘汰策略，熟悉缓存高并发场景，比</li>
<li>如缓存穿透、缓存击穿、缓存雪崩。</li>
<li>熟练使用Spring Boot、Spring、Mybatis等常用框架，熟悉 Spring IOC 、AOP 原理，了解 Nacos</li>
<li>、Zookeeper 等常见组件。</li>
<li>掌握 Linux 常用命令，如 netstat 、grep、top、chmod、find 等。</li>
</ul>
<h4 id="2-C"><a href="#2-C" class="headerlink" title=".2. C++"></a>.2. C++</h4><ul>
<li>熟练C++，（列举C++的若干知识点），了解 Java，python，go （适当补充对这些语言的理解）</li>
<li>熟悉常见设计模式（例句一些设计模式）</li>
<li>熟悉linux操作系统vim开发环境，（列举网络编程相关知识，例如epoll，socket等等）</li>
<li>熟悉网络，（列举网络协议相关考点，tcp/ip,http, https, 三次，四次握手，流量控制等等）</li>
<li>熟练掌握数据结构与算法（列举常用算法，最好搞透一个算法，说对该算法有独到见解）</li>
<li>熟练使用Git，等版本控制</li>
</ul>
<h3 id="10-阿里HR面试"><a href="#10-阿里HR面试" class="headerlink" title="10. 阿里HR面试"></a>10. 阿里HR面试</h3><ul>
<li>建议回答的不要东一句，西一句，尽量的有条理一些； 要注意问题是什么？问题想要问什么？问题之间的先后关系</li>
<li>先要对问题做一个分析，可以<code>先判断做这件事的目的是什么</code>，然后<code>和对方确认自己理解的是否正确</code>，<code>确认后给出临时想到的拆解方案</code>，无关对错，对方考察的是你的思路和分析能力。</li>
<li>人品、个人素质、积极性、皮实、是否爱折腾、韧性</li>
<li>思维能力、学习能力、执行力、上进心、人品、个人素质、对细节的把控、对全局的分析能力。</li>
</ul>
<h4 id="1-你平时是如何学习的？-你是怎么学习你的专业技术的？"><a href="#1-你平时是如何学习的？-你是怎么学习你的专业技术的？" class="headerlink" title="1. 你平时是如何学习的？/ 你是怎么学习你的专业技术的？"></a>1. 你平时是如何学习的？/ 你是怎么学习你的专业技术的？</h4><ul>
<li>我是抱着什么目的去学习的，如果项目开发还是自己自学，如果项目开发，先请教一下，防止学偏了</li>
<li>去淘宝看相关书，然后对比下目录，知道这个技术主要是干啥，有哪些部分，每个部分有什么功能，然后对自己感兴趣，或者需要的去github上找开源项目，demo 或者技术博客看一看</li>
</ul>
<h4 id="2-你觉得你的实习经历给你带来了什么？-你在实习中收获了什么？"><a href="#2-你觉得你的实习经历给你带来了什么？-你在实习中收获了什么？" class="headerlink" title="2. 你觉得你的实习经历给你带来了什么？/ 你在实习中收获了什么？"></a>2. 你觉得你的实习经历给你带来了什么？/ 你在实习中收获了什么？</h4><ul>
<li>思维锻炼：逻辑性更强，发现问题，问题抽象，设计解决方案</li>
<li>沟通能力：和导师沟通，和同学沟通，如何通过沟通展示自己的作品</li>
<li>社交圈子： 变广了</li>
<li>眼界更加开阔：实验室提供了很大的平台</li>
</ul>
<h4 id="3-如果其他的大厂也给你了-offer，例如字节，阿里等等，那你会考虑我们吗？"><a href="#3-如果其他的大厂也给你了-offer，例如字节，阿里等等，那你会考虑我们吗？" class="headerlink" title="3. 如果其他的大厂也给你了 offer，例如字节，阿里等等，那你会考虑我们吗？"></a>3. 如果其他的大厂也给你了 offer，例如字节，阿里等等，那你会考虑我们吗？</h4><h4 id="4-你的预期薪资是多少？-你希望拿到的薪资是多少？"><a href="#4-你的预期薪资是多少？-你希望拿到的薪资是多少？" class="headerlink" title="4. 你的预期薪资是多少？/ 你希望拿到的薪资是多少？"></a>4. <strong>你的预期薪资是多少？/ 你希望拿到的薪资是多少？</strong></h4><h4 id="5-阿里味"><a href="#5-阿里味" class="headerlink" title="5. 阿里味"></a>5. 阿里味</h4><h5 id="1-皮实，抗打击能力强"><a href="#1-皮实，抗打击能力强" class="headerlink" title=".1. 皮实，抗打击能力强"></a>.1. 皮实，抗打击能力强</h5><ul>
<li>喜欢那种爱折腾的人，挖一下你经历过的失败，他们会依据你失败后的动作，来判断你是否皮实</li>
</ul>
<h5 id="2-乐观"><a href="#2-乐观" class="headerlink" title=".2. 乐观"></a>.2. <strong>乐观</strong></h5><ul>
<li>乐观心态，如果这种负面情绪或者永远看到坏的一面，会打击团队士气</li>
</ul>
<h5 id="3-拥抱变化"><a href="#3-拥抱变化" class="headerlink" title=".3. 拥抱变化"></a>.3. 拥抱变化</h5><ul>
<li>既有主动变化，也有被动变化。主动变化一般是自己走转岗这个途径实现；被动变化是组织业务需要，对个体进行岗位轮换或调整。</li>
</ul>
<h5 id="6-你最大的优点是什么"><a href="#6-你最大的优点是什么" class="headerlink" title="6. 你最大的优点是什么"></a>6. <strong>你最大的优点是什么</strong></h5><ul>
<li>STAR 原则，什么情景，发生了什么事情，你怎么处理的，最终的结果是什么。</li>
<li>喜好钻研，定了一个目标就会坚持去实现，很有毅力；</li>
<li>喜欢交朋友，他们都觉得我比较随和好相处，会为别人考虑，做事比较细心；</li>
<li>可以信赖的人，一旦答应别人的事情，就一定会拼尽全力做到。如果我做不到，从不轻易许诺。</li>
<li>环境改变的时候，首先要积极学习，其次要学会寻找帮助</li>
</ul>
<h5 id="7-你最大的缺点是什么"><a href="#7-你最大的缺点是什么" class="headerlink" title="7. 你最大的缺点是什么"></a>7. <strong>你最大的缺点是什么</strong></h5><ul>
<li><h5 id="8-你经历最失败的项目是什么？"><a href="#8-你经历最失败的项目是什么？" class="headerlink" title="8. 你经历最失败的项目是什么？"></a>8. <strong>你经历最失败的项目是什么？</strong></h5></li>
<li><p>与其说问你失败的项目，其实更多的是想了解，你从这个失败的项目中学到了什么，对你自己有什么提升，如果让你从头来一遍，你能不能转败为赢</p>
</li>
<li><p>当初自己在家DIY自美魔镜系统： 起初目标：在家里做个猫眼摄像头功能？ 但最后做了个简单的智能魔镜（语言调用摄像头进行监控，语音聊天，人体存在检测，温度湿度检测），不能用的，背离的最开始的目标</p>
<ul>
<li>完全自己玩了，没有考虑具体部署情况，（怎么供电，放哪，怎么能无死角，便宜，设计公益）</li>
<li>需求是啥，只是个猫眼监控，先完成最基本的，然后可以的话在进行相应扩展</li>
<li>给我大侄子用了，介绍以后物联网可以干啥</li>
</ul>
</li>
</ul>
<h5 id="9-你经历的最大挫折是什么"><a href="#9-你经历的最大挫折是什么" class="headerlink" title="9. 你经历的最大挫折是什么"></a>9. <strong>你经历的最大挫折是什么</strong></h5><ul>
<li>小时候太皮了，我考了倒数第二，我爸求老师让我升学，老师很冷漠</li>
<li>高二时候腿摔伤了</li>
</ul>
<h5 id="10-你跳槽的原因是什么"><a href="#10-你跳槽的原因是什么" class="headerlink" title="10. 你跳槽的原因是什么"></a>10. <strong>你跳槽的原因是什么</strong></h5><ul>
<li>想提高自己的研究能力，分析能力，解决问题能力</li>
<li>导师很在科研方面很厉害</li>
</ul>
<h5 id="11-绩效被打-3-25-怎么办"><a href="#11-绩效被打-3-25-怎么办" class="headerlink" title="11. 绩效被打 3.25 怎么办"></a>11. <strong>绩效被打 3.25 怎么办</strong></h5><ul>
<li>表态，在态度与能力上，自己会全情投入去把工作做好，避免 3.25 的发生；如果真的发生了，做好<code>复盘、做好沟通，找到问题的关键点，并进行提升</code>。</li>
<li>其他团队的挑战、不配合、竞争等：做好自己，把外部压力与挑战转化成自我提升的动力，感到难受的时候就是进步的时候。</li>
</ul>
<h5 id="12-最近遇到最有压力的事情"><a href="#12-最近遇到最有压力的事情" class="headerlink" title="12. 最近遇到最有压力的事情"></a>12. 最近遇到最有压力的事情</h5><ul>
<li>最开始面试的时候，准备比较少，担心算法题不会写（每天都是一个新的我，时间很宝贵，天天刷题）</li>
</ul>
<h5 id="13-对选择工作最看重的三个点"><a href="#13-对选择工作最看重的三个点" class="headerlink" title="13. 对选择工作最看重的三个点"></a>13. 对选择工作最看重的三个点</h5><ul>
<li>是否自己喜欢的，分布式存储的，技术栈是C、C++和linux，以及脚本编写</li>
<li>boss怎么样：面试过程中面试官很好，我是师兄推荐的，师兄也是主管很好</li>
<li>技术度和晋升空间：偏底层，能在工作中不断成长</li>
</ul>
<ul>
<li><p>你更但愿从事哪方面的工做，应用型仍是研究型的工做？为何？ </p>
<ul>
<li>研究：了解工业界需求，发现新的技术问题，并加以解决。<ul>
<li>研究是一种量变：喜欢读paper，逛掘金，微信公众号等技术网站，了解最新的技术，不断积累。</li>
<li>研究注重思维逻辑：为了提高自己的研究能力，思维能力，离开本科学校去天津大学，跟随心仪的教授读硕士，自己也阅读了麦肯锡意识一些列书籍。</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点：刚刚毕业，算法能力有些薄弱，一些基础知识由于长时间没用，虽然以博客方式记录下来，但仍忘记了。</p>
</li>
<li><p>对新人的培养,   培养计划和晋升机制, 技术栈,  面试官自己的技能经历, 评价自己前俩次面试表现(1. 面试流程感觉很好，交流很愉快。2. 自己算法那块还带提高，写单调栈的时候尽然没有了解这个数据结构，写的时候有一点没想明白，导致最后只是最开始暴力方法。3. 感觉注重思维能力，工程技术只是思维的实现过程)</p>
</li>
</ul>
<h3 id="10-相关企业"><a href="#10-相关企业" class="headerlink" title="10. 相关企业"></a>10. 相关企业</h3><h4 id="1-外企-上海"><a href="#1-外企-上海" class="headerlink" title=".1. 外企-上海"></a>.1. 外企-上海</h4><ul>
<li>Google（上海）</li>
<li>微软（上海）</li>
<li>LeetCode/力扣（上海）</li>
<li>unity（上海）游戏引擎</li>
<li>SAP（上海）主要产品是ERP</li>
<li>PayPal（上海）在线支付鼻祖</li>
<li>eBay（上海）电子商务公司</li>
</ul>
<p>偏硬件</p>
<ul>
<li>IBM（上海）</li>
<li>Tesla（上海）特斯拉</li>
<li>Cisco（上海）思科</li>
<li>Intel（上海）</li>
<li>AMD（上海）半导体产品领域</li>
<li>EMC（上海）易安信是美国信息存储资讯科技公司</li>
<li>NVIDIA（上海）英伟达是GPU(图形处理器)的发明者，人工智能计算的引领者</li>
</ul>
<h4 id="2-外企-北京"><a href="#2-外企-北京" class="headerlink" title=".2. 外企-北京"></a>.2. 外企-北京</h4><ul>
<li>微软（北京）微软中国主要就是北京和苏州</li>
<li>Hulu（北京）美国的视频网站，听说福利待遇超级棒</li>
<li>Airbnb（北京）房屋租赁平台</li>
<li>Grab（北京）东南亚第一大出行 App</li>
<li>印象笔记（北京）evernote在中国的独立品牌</li>
<li>FreeWheel（北京）美国最大的视频广告管理和投放平台</li>
<li>amazon（北京）全球最大的电商平台</li>
</ul>
<h4 id="3-外企-杭州"><a href="#3-外企-杭州" class="headerlink" title=".3. 外企-杭州"></a>.3. 外企-杭州</h4><ul>
<li><p>ZOOM （杭州研发中心）全球知名云视频会议服务提供商</p>
</li>
<li><p>infosys（杭州）印度公司，据说工资相对不高</p>
</li>
<li><p>思科（杭州）</p>
</li>
<li><p>Citrix - 南京 </p>
</li>
<li><p>eHealth 厦门 </p>
</li>
<li><p>Microsoft - 北京/上海/苏州 </p>
</li>
<li><p>Red Hat - 北京/上海/深圳 </p>
</li>
<li><p>Shopee - 深圳 （勉强算是外企吧） </p>
</li>
<li><p>ThoughtWorks - 西安/北京/深圳/成都/武汉/上海/香港 （口碑不好）</p>
</li>
<li><p>Zoom - 合肥/杭州/苏州</p>
</li>
</ul>
<h4 id="4-具体部门"><a href="#4-具体部门" class="headerlink" title=".4. 具体部门"></a>.4. 具体部门</h4><h5 id="1-华为云IoT产品部边缘计算团队"><a href="#1-华为云IoT产品部边缘计算团队" class="headerlink" title="1. 华为云IoT产品部边缘计算团队"></a>1. 华为云IoT产品部边缘计算团队</h5><p><a href="mailto:jiajie3@huawei.com">jiajie3@huawei.com</a>  邮件标题：华为云校招 + 名字 + 代码随想录 简历pdf命名：求职岗位+学校+名字+代码随想录 </p>
<ul>
<li>华为云校招：<a href="https://mp.weixin.qq.com/s/SYKLwgCAiDwjb4-Vl---yg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SYKLwgCAiDwjb4-Vl---yg</a></li>
<li>华为云开发工程师：<a href="https://wx.zsxq.com/mweb/views/topicdetail/topicdetail.html?topic_id=215128812884181&amp;inviter_id=88881445884882&amp;share_from=ShareToWechat&amp;keyword=nuFIAe2" target="_blank" rel="noopener">2021.4</a></li>
<li><a href="https://mp.weixin.qq.com/s/x8NIBWhG0iadBi9yVnUW6w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/x8NIBWhG0iadBi9yVnUW6w</a>  云计算内推</li>
</ul>
<h4 id="【腾讯实习】蚂蚁集团2023届实习生招聘"><a href="#【腾讯实习】蚂蚁集团2023届实习生招聘" class="headerlink" title="【腾讯实习】蚂蚁集团2023届实习生招聘"></a>【腾讯实习】蚂蚁集团2023届实习生招聘</h4><h4 id="华为云核心产品线"><a href="#华为云核心产品线" class="headerlink" title="华为云核心产品线"></a>华为云核心产品线</h4><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220221140611474.png" alt="image-20220221140611474"></p>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><ul>
<li>各类面试：<a href="https://www.cnblogs.com/QLCZ/p/15004102.html" target="_blank" rel="noopener">https://www.cnblogs.com/QLCZ/p/15004102.html</a></li>
<li>资源： <a href="https://leetcode-cn.com/circle/discuss/zIxrWn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/discuss/zIxrWn/</a></li>
<li>Linux: <a href="https://juejin.cn/post/6952876066155429924#heading-26" target="_blank" rel="noopener">https://juejin.cn/post/6952876066155429924#heading-26</a></li>
<li>Java-Doc: <a href="https://github.com/lvminghui/Java-Notes/blob/master/docs/Java%E5%9F%BA%E7%A1%80.md" target="_blank" rel="noopener">https://github.com/lvminghui/Java-Notes/blob/master/docs/Java%E5%9F%BA%E7%A1%80.md</a></li>
<li>比较全的Java相关知识：<a href="https://juejin.cn/post/6950532370567004196/" target="_blank" rel="noopener">https://juejin.cn/post/6950532370567004196/</a></li>
<li>c++ 面经： <a href="https://www.nowcoder.com/tutorial/93/b36a4e16637540b48edebbe29a405eb8" target="_blank" rel="noopener">https://www.nowcoder.com/tutorial/93/b36a4e16637540b48edebbe29a405eb8</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://liudongdong1.github.io" rel="external nofollow noreferrer">liudongdong1</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://liudongdong1.github.io/2021/04/05/yu-yan-kuang-jia/java/leetcode/mian-jing/">https://liudongdong1.github.io/2021/04/05/yu-yan-kuang-jia/java/leetcode/mian-jing/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="https://liudongdong1.github.io" target="_blank">liudongdong1</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/skill/">
                                    <span class="chip bg-color">skill</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2021/04/05/writing/logicconvey/abilityfoster/">
                    <div class="card-image">
                        
                        <img src="https://gitee.com/github-25970295/blogImage/raw/master/img/20210501111834.png" class="responsive-img" alt="AbilityFoster">
                        
                        <span class="card-title">AbilityFoster</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
不懂得做产品，你不懂得营销，你不懂得供应链，你不懂得财务，你不懂得法律，你不懂得和人沟通，你不懂得管理;



1. 理解一个行业

学习好的行业报告，大纲脉络，文章结构组织，图标等；
快速了解一个行业的关键是摸清楚最基本的情况，了解一个
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-04-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%94%9F%E6%B4%BB/" class="post-category">
                                    生活
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/skill/">
                        <span class="chip bg-color">skill</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/04/02/yu-yan-kuang-jia/c/threadrelative/">
                    <div class="card-image">
                        
                        <img src="https://cdn.pixabay.com/photo/2021/05/02/23/26/red-6224930__340.jpg" class="responsive-img" alt="ThreadRelative">
                        
                        <span class="card-title">ThreadRelative</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
1. 线程基础.1. 生命周期
在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。当线程start后，它不能一直”独占”着CPU独自运行，所以C
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-04-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AF%AD%E8%A8%80%E6%A1%86%E6%9E%B6/" class="post-category">
                                    语言框架
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java/">
                        <span class="chip bg-color">java</span>
                    </a>
                    
                    <a href="/tags/c/">
                        <span class="chip bg-color">c#</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <!-- <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="463294659"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://liudongdong1.github.io" target="_blank">liudongdong</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">1349.4k</span>&nbsp;字
            
            
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/liudongdong1/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:3463264078@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>














    <a href="https://blog.csdn.net/liudongdong19/" class="tooltipped" target="_blank" data-tooltip="关注我的CSDN: https://blog.csdn.net/liudongdong19/" data-position="top" data-delay="50">
        <i class="fab fa-csdn">C</i>
    </a>





</div>
    </div>
</footer>

<div class="progress-bar"></div>
 -->

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script type="text/javascript" src="/js/CFS.Snow.min.js"></script>
    <!-- 点击爆灯效果 -->
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <!--动态线条背景-->
    <script type="text/javascript"
        color="122 103 238" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
    </script>
    <!-- 天气 -->
    <!-- weather -->
    <!-- weather -->
    <script type="text/javascript">
         WIDGET = {FID: 'knAMQaFanP'}
    </script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>
    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
    <!-- {% include '_custom/custom.swig' %} -->

</body>

</html>
