<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="ThreadRelative, AIOT,Space&amp;Temporal Sequence Analysis,SpringBoot,liudongdong1,cloud">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>ThreadRelative | DaybyDay</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="DaybyDay" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">DaybyDay</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">

      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/about">
          
          <i class="fas fa-user-circle" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>about</span>
        </a>
      </li>
      
      <li>
        <a href="/resume">
          
          <i class="fa fa-user-secret" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>resume</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/gallery" class="waves-effect waves-light">
      
      <i class="fas fa-camera" style="zoom: 0.6;"></i>
      
      <span>Galleries</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">DaybyDay</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-user-circle"></i>
			
			About
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/about " style="margin-left:75px">
				  
				   <i class="fa fas fa-user-circle" style="position: absolute;left:50px" ></i>
			      
		          <span>about</span>
                  </a>
                </li>
              
                <li>

                  <a href="/resume " style="margin-left:75px">
				  
				   <i class="fa fa fa-user-secret" style="position: absolute;left:50px" ></i>
			      
		          <span>resume</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/gallery" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-camera"></i>
			
			Galleries
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/liudongdong1" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/liudongdong1" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.pixabay.com/photo/2021/05/02/23/26/red-6224930__340.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">ThreadRelative</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    .toc-fixed .toc-link::before{
        position: fixed!important;/*当toc的位置改为fixed时，.toc-link::before也要改为fixed*/
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/java/">
                                <span class="chip bg-color">java</span>
                            </a>
                        
                            <a href="/tags/c/">
                                <span class="chip bg-color">c#</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AF%AD%E8%A8%80%E6%A1%86%E6%9E%B6/" class="post-category">
                                语言框架
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2021-04-02
                </div>
                

                <!-- 
                    <i class="fa fa-pencil"></i> Author: liudongdong1
                  -->

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2021-07-04
                </div>
                

                <!-- 
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    12.3k
                </div>
                 -->

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    55 Min
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/v2-d52274949a2e01bba91ff2ec256718ed_1441w.jpg" alt=""></p>
<h3 id="1-线程基础"><a href="#1-线程基础" class="headerlink" title="1. 线程基础"></a>1. 线程基础</h3><h4 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title=".1. 生命周期"></a>.1. 生命周期</h4><blockquote>
<p>在线程的生命周期中，它要经过<code>新建（New）</code>、<code>就绪（Runnable</code>）、<code>行（Running）</code>、<code>阻塞（Blocked）</code>和<code>死亡（Dead）</code>五种状态。当线程start后，它不能一直”独占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换.</p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210703144630738.png" alt=""></p>
<ul>
<li><strong>新建状态（new）</strong>：指新建了一个线程对象。<strong>Thread  t1 =new Thread();这里就新建了一个Thread类的线程对象。</strong></li>
<li><strong>就绪状态（Runnable）</strong>：当线程对象创建后，该线程对象自身或者其他对象调用了该对象的start()方法。该线程就位于了可运行池中，变的可运行，等待获取cpu的使用权。<strong>因为在同一时间里cpu只能执行某一个线程。</strong></li>
<li><strong>运行状态（Running）: 当就绪状态的线程获取了cpu的时间片或者说获取了cpu的执行时间</strong>，这时就会调用该线程对象的run()方法，然后就从就绪状态就入了运行状态。</li>
<li><strong>阻塞状态（Blocked）</strong>：<strong>阻塞状态就是线程因为某种原因暂时放弃了对cpu的使用权，暂时停止运行。</strong>直到线程再次进入就绪状态，才有机会转到运行状态。阻塞状态分为三种情况：<ul>
<li>等待阻塞：运行状态的线程调用了<code>wait()方法后</code>，该线程会释放它所持有的锁，然后被jvm放入到等待池中，只有<code>等其他线程调用Object类的notify()方法或者norifyAll()方法时，才能进入重新进入到就绪状态</code>。</li>
<li>同步阻塞：<code>运行的线程在获取对象的同步锁时</code>，若该同步锁被别的线程占用，JVM就会把该线程设置为阻塞状态，一直到线程获取到同步锁，才能转入就绪状态。</li>
<li>其它阻塞：运行的线程在<code>执行sleep()或者join()方法</code>时，或者发出了<code>I/O请求</code>，JVM就会把该线程设置为阻塞状态，当<code>sleep()状态超时、join()等待等待线程终止或者超时</code>、或者I/O处理完毕时，线程重进转入到就绪状态。在这需要注意的是sleep()方法和wait()不同，sleep不会释放自身所持有的锁。</li>
</ul>
</li>
<li><strong>死亡状态（Dead）：</strong>当线程执行完了或者因异常退出了run()的执行，该线程的生命周期就结束了。</li>
</ul>
<h4 id="2-线程优先级"><a href="#2-线程优先级" class="headerlink" title=".2. 线程优先级"></a>.2. 线程优先级</h4><blockquote>
<ul>
<li>记住当线程的优先级<code>没有指定时</code>，所有线程都携带<code>普通优先级</code>。</li>
<li>java优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。</li>
<li>记住优先级最高的线程在执行时被给予优先。但是<code>不能保证线程在启动时就进入运行状态</code>。</li>
<li>与在线程池中等待运行机会的线程相比，当前正在运行的线程可能总是拥有更高的优先级。</li>
<li>由调度程序决定哪一个线程被执行。</li>
<li>t.<code>setPriority()</code>用来设定线程的优先级。</li>
<li>记住<code>在线程开始方法被调用之前，线程的优先级应该被设定</code>。</li>
<li>你可以使用常量，如MIN_PRIORITY,MAX_PRIORITY，NORM_PRIORITY来设定优先级。</li>
</ul>
</blockquote>
<h5 id="1-c-demo"><a href="#1-c-demo" class="headerlink" title=".1. c# demo"></a>.1. c# demo</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">{</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Current thread priority: {0}", Thread.CurrentThread.Priority);</span><br><span class="line">        Console.WriteLine("Running on all cores available");</span><br><span class="line">        RunThreads();</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(2));</span><br><span class="line">        Console.WriteLine("Running on a single core");</span><br><span class="line">        Process.GetCurrentProcess().ProcessorAffinity = new IntPtr(1);</span><br><span class="line">        RunThreads();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static void RunThreads()</span><br><span class="line">    {</span><br><span class="line">        var sample = new ThreadSample();</span><br><span class="line"></span><br><span class="line">        var threadOne = new Thread(sample.CountNumbers);</span><br><span class="line">        threadOne.Name = "ThreadOne";</span><br><span class="line">        var threadTwo = new Thread(sample.CountNumbers);</span><br><span class="line">        threadTwo.Name = "ThreadTwo";</span><br><span class="line"></span><br><span class="line">        threadOne.Priority = ThreadPriority.Highest;</span><br><span class="line">        threadTwo.Priority = ThreadPriority.Lowest;</span><br><span class="line">        threadOne.Start();</span><br><span class="line">        threadTwo.Start();</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(2));</span><br><span class="line">        sample.Stop();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    class ThreadSample</span><br><span class="line">    {</span><br><span class="line">        private bool _isStopped = false;</span><br><span class="line"></span><br><span class="line">        public void Stop()</span><br><span class="line">        {</span><br><span class="line">            _isStopped = true;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public void CountNumbers()</span><br><span class="line">        {</span><br><span class="line">            long counter = 0;</span><br><span class="line"></span><br><span class="line">            while (!_isStopped)</span><br><span class="line">            {</span><br><span class="line">                counter++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Console.WriteLine("{0} with {1,11} priority " +</span><br><span class="line">                        "has a count = {2,13}", Thread.CurrentThread.Name,</span><br><span class="line">                        Thread.CurrentThread.Priority,</span><br><span class="line">                        counter.ToString("N0"));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-java-demo"><a href="#2-java-demo" class="headerlink" title=".2.  java demo"></a>.2.  java demo</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//或取优先级</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    System.out.println(Thread.currentThread().getPriority());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置优先级</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">    System.out.println(Thread.currentThread().getPriority());</span><br><span class="line">    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    System.out.println(Thread.currentThread().getPriority());</span><br><span class="line">    Thread.currentThread().setPriority(<span class="number">8</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getPriority());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//不同优先级设置</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomThread</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> CustomThread(<span class="string">"A"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> CustomThread(<span class="string">"B"</span>);</span><br><span class="line">    t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">    t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-前台线程-amp-后台线程"><a href="#3-前台线程-amp-后台线程" class="headerlink" title=".3. 前台线程&amp;后台线程"></a>.3. 前台线程&amp;后台线程</h4><blockquote>
<p><code>应用程序必须运行完所有的前台线程才会完全退出</code>，<code>若前台线程未执行完成</code>，关闭应用程序后，<code>应用程序并没有完全退出</code>，在任务管理器中还存在此进程；而<code>对于后台线程</code>，应用程序则可以不考虑其是否已经运行完毕而直接退出，所有的后台线程在应用程序退出时<code>都会自动结束</code>。</p>
<ul>
<li>　后台线程：<code>后台线程是可以随时被CLR关闭而不引发异常的</code>，也就是说当后台线程被关闭时，资源的回收是立即的，不等待的，也不考虑后台线程是否执行完成，就算是正在执行中也立即被终止。【后台，存在于黑暗之中默默无闻，它的消亡和存在，别人也感受不到】</li>
<li>　前台线程：前台线程是不会被立即关闭的，它的关闭只会发生在自己执行完成时，不受外在因素的影响。假如应用程序退出，造成它的前台线程终止，此时CLR仍然保持活动并运行，使应用程序能继续运行，当它的的前台线程都终止后，整个进程才会被销毁。</li>
<li>　<code>应用程序的主线程</code>以及使用<code>Thread构造的线程</code>都默认为<strong>前台线程</strong>, <code>线程池线程</code>也就是使用 <code>ThreadPool.QueueUserWorkItem()</code>和<code>Task工厂创建的线程都默认为后台线程</code></li>
<li>　可以在任何时候将前台线程修改为后台线程，方式是设置Thread.IsBackground 属性。</li>
<li>　不管是前台线程还是后台线程，<code>如果线程内出现了异常，都会导致进程的终止</code>。</li>
<li>　<code>UI 一般使用前台进程</code>，<code>处理计算繁琐的一般放在后台进程</code>，否则会导致UI卡住。</li>
</ul>
</blockquote>
<h5 id="1-c-demo-1"><a href="#1-c-demo-1" class="headerlink" title=".1. c# demo"></a>.1. c# demo</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">{</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    {</span><br><span class="line">        var sampleForeground = new ThreadSample(10);</span><br><span class="line">        var sampleBackground = new ThreadSample(20);</span><br><span class="line"></span><br><span class="line">        var threadOne = new Thread(sampleForeground.CountNumbers);</span><br><span class="line">        threadOne.Name = "ForegroundThread";</span><br><span class="line">        var threadTwo = new Thread(sampleBackground.CountNumbers);</span><br><span class="line">        threadTwo.Name = "BackgroundThread";</span><br><span class="line">        threadTwo.IsBackground = true;</span><br><span class="line"></span><br><span class="line">        threadOne.Start();</span><br><span class="line">        threadTwo.Start();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    class ThreadSample</span><br><span class="line">    {</span><br><span class="line">        private readonly int _iterations;</span><br><span class="line"></span><br><span class="line">        public ThreadSample(int iterations)</span><br><span class="line">        {</span><br><span class="line">            _iterations = iterations;</span><br><span class="line">        }</span><br><span class="line">        public void CountNumbers()</span><br><span class="line">        {</span><br><span class="line">            for (int i = 0; i &lt; _iterations; i++)</span><br><span class="line">            {</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(0.5));</span><br><span class="line">                Console.WriteLine("{0} prints {1}", Thread.CurrentThread.Name, i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210701094247878.png" alt=""></p>
<h4 id="4-lock-Monitor"><a href="#4-lock-Monitor" class="headerlink" title=".4. lock/Monitor"></a>.4. lock/Monitor</h4><blockquote>
<p>在多线程代码中，<code>多个线程可能会访问一些公共的资源（变量、方法逻辑等等）</code>，这些公共资源称为临界区（共享区）；临界区的资源是不安全，所以需要<code>通过线程同步对多个访问临界区的线程进行控制</code>.</p>
<p>lock关键字可以锁住任何object类型及其派生类，但是尽量不要用public 类型的，否则实例将超出代码的控制范围。根据MSDN，常见的结构 lock (this)、lock (typeof (MyType)) 和 lock (“myLock”) 违反此准则：</p>
<ul>
<li>如果<code>实例可以被公共访问，将出现 lock (this) 问题</code>。</li>
<li>如果 <code>MyType 可以被公共访问，将出现 lock (typeof (MyType)) 问题</code>。</li>
<li>由于<code>进程中使用同一字符串的任何其他代码将共享同一个锁</code>，所以出现 lock(“myLock”) 问题。</li>
<li><strong>最好定义 private 对象 或 private static 对象进行上锁，从而保护所有实例所共有的数据。</strong></li>
</ul>
</blockquote>
<h5 id="1-lock-C-demo"><a href="#1-lock-C-demo" class="headerlink" title=".1.  lock C# demo"></a>.1.  lock C# demo</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">namespace LockTest</span><br><span class="line">{</span><br><span class="line">    class PrintNum</span><br><span class="line">    {</span><br><span class="line">        private object lockObj = new object();</span><br><span class="line"></span><br><span class="line">        public void PrintOddNum()</span><br><span class="line">        {</span><br><span class="line">            lock (lockObj)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine("Print Odd numbers:");</span><br><span class="line">                for (int i = 0; i &lt; 10; i++)</span><br><span class="line">                {</span><br><span class="line">                    if(i%2 != 0)</span><br><span class="line">                        Console.Write(i);</span><br><span class="line">                    Thread.Sleep(100);</span><br><span class="line">                }</span><br><span class="line">                Console.WriteLine();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            PrintNum printNum = new PrintNum();</span><br><span class="line">            for (int i = 0; i &lt; 3; i++)</span><br><span class="line">            {</span><br><span class="line">                Thread temp = new Thread(new ThreadStart(printNum.PrintOddNum));</span><br><span class="line">                temp.Start();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-lock-c-错误代码"><a href="#2-lock-c-错误代码" class="headerlink" title=".2.  lock c# 错误代码"></a>.2.  lock c# 错误代码</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#因为Main函数和PrintNum类型中都对printNum对象进行了加锁，所以当主线程获得了互斥锁之后，其他子线程都被block住了，没有办法执行PrintOddNum方法了。</span><br><span class="line">namespace LockTest</span><br><span class="line">{</span><br><span class="line">    class PrintNum</span><br><span class="line">    {</span><br><span class="line">        private object lockObj = new object();</span><br><span class="line"></span><br><span class="line">        public void PrintOddNum()</span><br><span class="line">        {</span><br><span class="line">            lock (this)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine("Print Odd numbers:");</span><br><span class="line">                for (int i = 0; i &lt; 10; i++)</span><br><span class="line">                {</span><br><span class="line">                    if (i % 2 != 0)</span><br><span class="line">                        Console.Write(i);</span><br><span class="line">                    Thread.Sleep(100);</span><br><span class="line">                }</span><br><span class="line">                Console.WriteLine();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            PrintNum printNum = new PrintNum();</span><br><span class="line">            for (int i = 0; i &lt; 3; i++)</span><br><span class="line">            {</span><br><span class="line">                Thread temp = new Thread(new ThreadStart(printNum.PrintOddNum));</span><br><span class="line">                temp.Start();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            lock (printNum)</span><br><span class="line">            {</span><br><span class="line">                Thread.Sleep(5000);</span><br><span class="line">                Console.WriteLine("Main thread will delay 5 seconds");</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-Monitor"><a href="#3-Monitor" class="headerlink" title=".3.  Monitor"></a>.3.  Monitor</h5><blockquote>
<p>lock使用的就是Monitor类型的Enter和Exit方法。很多情况下lock就可以满足需求了，但是当我们需要更进一步的线程同步时，就需要使用Monitor类型了。</p>
<ul>
<li>public static void Enter(object obj);<ul>
<li>在指定对象上获取互斥锁</li>
</ul>
</li>
<li>public static void Exit(object obj);<ul>
<li>释放指定对象上的互斥锁</li>
</ul>
</li>
<li>public static void Pulse(object obj);<ul>
<li>通知等待队列中的线程锁定对象状态的更改</li>
</ul>
</li>
<li>public static bool TryEnter(object obj);<ul>
<li>试图获取指定对象的互斥锁，如果获得了互斥锁就返回true；否则返回false</li>
<li>TryEnter(Object, Int32)形式，表示在指定的毫秒数内尝试获取指定对象上的互斥锁</li>
</ul>
</li>
<li>public static bool Wait(object obj);<ul>
<li>释放对象上的锁并阻止当前线程，直到它重新获取该锁</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>Wait：当线程调用 Wait 时，它释放对象的锁并进入<strong>等待队列</strong>。对象的<strong>就绪队列</strong>中的下一个线程（如果有）获取锁并拥有对对象的独占使用。所有调用 Wait 的线程都将留在等待队列中，直到它们接收到由锁的所有者发送的 Pulse 或 PulseAll 的信号为止。</li>
<li>Pulse：只有锁的当前所有者可以使用 Pulse 向等待对象发出信号。如果发送了 Pulse，则只影响位于等待队列最前面的线程。如果发送了 PulseAll，则将影响正等待该对象的所有线程。接收到信号后，一个或多个线程将离开<strong>等待队列而进入就绪队列</strong>。 在调用 Pulse 的线程释放锁后，<strong>就绪队列中的下一个线程（不一定是接收到脉冲的线程）将获得该锁</strong>。</li>
</ul>
<p>使用注意事项：</p>
<ul>
<li>在使用Enter和Exit方法的时候，建议像lock的IL代码一样，<code>使用try/finally语句块对Enter和Exit进行包装</code>。</li>
<li>Pulse 、PulseAll 和 Wait 方法必须从同步的代码块内调用。</li>
<li>在使用Pulse/Wait进行线程同步的时候，一定要牢记，Monitor 类不对指示 Pulse 方法已被调用的状态进行维护。 因此，<strong>如果在没有等待线程时调用 Pulse，则下一个调用 Wait 的线程将阻止，似乎 Pulse 从未被调用过。 如果两个线程正在使用 Pulse 和 Wait 交互，则可能导致死锁</strong>。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">namespace MointorTest</span><br><span class="line">{</span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        private static object monitorObj = new object();</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            Thread firstThread = new Thread(new ThreadStart(TryEnterTest));</span><br><span class="line">            firstThread.Name = "firstThread";</span><br><span class="line">            Thread secondThread = new Thread(new ThreadStart(TryEnterTest));</span><br><span class="line">            secondThread.Name = "secondThread";</span><br><span class="line">            firstThread.Start();</span><br><span class="line">            secondThread.Start();</span><br><span class="line">            Console.Read();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        public static void TryEnterTest()</span><br><span class="line">        {</span><br><span class="line">            if (!Monitor.TryEnter(monitorObj, 5000))</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine("Thread {0} wait 5 seconds, didn't get the lock", Thread.CurrentThread.Name);</span><br><span class="line">                Console.WriteLine("Thread {0} completed!", Thread.CurrentThread.Name);</span><br><span class="line">                return;</span><br><span class="line">            }</span><br><span class="line">            try</span><br><span class="line">            {</span><br><span class="line">           Monitor.Enter(monitorObj);</span><br><span class="line">                Console.WriteLine("Thread {0} get the lock and will run 10 seconds", Thread.CurrentThread.Name);</span><br><span class="line">                Thread.Sleep(10000);</span><br><span class="line">                Console.WriteLine("Thread {0} completed!", Thread.CurrentThread.Name);</span><br><span class="line">            }</span><br><span class="line">            finally</span><br><span class="line">            {</span><br><span class="line">                Monitor.Exit(monitorObj);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-互斥队列"><a href="#4-互斥队列" class="headerlink" title=".4. 互斥队列"></a>.4. 互斥队列</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">namespace BlockingQueue</span><br><span class="line">{</span><br><span class="line">    class BlockingQueue&lt;T&gt;</span><br><span class="line">    {</span><br><span class="line">        private object lockObj = new object();</span><br><span class="line">        public int QueueSize { get; set; }</span><br><span class="line">        private Queue&lt;T&gt; queue;</span><br><span class="line">        </span><br><span class="line">        public BlockingQueue()</span><br><span class="line">        {</span><br><span class="line">            this.queue = new Queue&lt;T&gt;(this.QueueSize);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public bool EnQueue(T item)</span><br><span class="line">        {</span><br><span class="line">            lock (lockObj)</span><br><span class="line">            {</span><br><span class="line">                while (this.queue.Count() &gt;= this.QueueSize)</span><br><span class="line">                {</span><br><span class="line">                    Monitor.Wait(lockObj);</span><br><span class="line">                }</span><br><span class="line">                this.queue.Enqueue(item);</span><br><span class="line">                Console.WriteLine("---&gt; 0000" + item.ToString());</span><br><span class="line">                Monitor.PulseAll(lockObj);</span><br><span class="line">            }</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public bool DeQueue(out T item)</span><br><span class="line">        {</span><br><span class="line">            lock (lockObj)</span><br><span class="line">            {</span><br><span class="line">                while (this.queue.Count() == 0)</span><br><span class="line">                {</span><br><span class="line">                    if (!Monitor.Wait(lockObj, 3000))</span><br><span class="line">                    {</span><br><span class="line">                        item = default(T);</span><br><span class="line">                        return false;</span><br><span class="line">                    };</span><br><span class="line">                }</span><br><span class="line">                item = this.queue.Dequeue();</span><br><span class="line">                Console.WriteLine("     0000" + item + " &lt;---");</span><br><span class="line">                Monitor.PulseAll(lockObj);</span><br><span class="line">            }</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            BlockingQueue&lt;string&gt; bQueue = new BlockingQueue&lt;string&gt;();</span><br><span class="line">            bQueue.QueueSize = 3;</span><br><span class="line"></span><br><span class="line">            Random ran = new Random();</span><br><span class="line"></span><br><span class="line">            //producer</span><br><span class="line">            new Thread(</span><br><span class="line">            () =&gt; {</span><br><span class="line">                for (int i = 0; i &lt; 5; i++)</span><br><span class="line">                {</span><br><span class="line">                    Thread.Sleep(ran.Next(1000));</span><br><span class="line">                    bQueue.EnQueue(i.ToString());</span><br><span class="line">                    </span><br><span class="line">                }</span><br><span class="line">                Console.WriteLine("producer quit!");</span><br><span class="line">            }).Start();</span><br><span class="line"></span><br><span class="line">            //producer</span><br><span class="line">            new Thread(</span><br><span class="line">            () =&gt;</span><br><span class="line">            {</span><br><span class="line">                for (int i = 5; i &lt; 10; i++)</span><br><span class="line">                {</span><br><span class="line">                    Thread.Sleep(ran.Next(1000));</span><br><span class="line">                    bQueue.EnQueue(i.ToString());</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                Console.WriteLine("producer quit!");</span><br><span class="line">            }).Start();</span><br><span class="line"></span><br><span class="line">            //consumer</span><br><span class="line">            new Thread(</span><br><span class="line">            () =&gt;</span><br><span class="line">            {</span><br><span class="line">                while (true)</span><br><span class="line">                {</span><br><span class="line">                    Thread.Sleep(ran.Next(1000));</span><br><span class="line">                    string item = string.Empty;</span><br><span class="line">                    if (!bQueue.DeQueue(out item))</span><br><span class="line">                    {</span><br><span class="line">                        break;</span><br><span class="line">                    };</span><br><span class="line">                }</span><br><span class="line">                Console.WriteLine("consumer quit!");</span><br><span class="line">            }).Start();</span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h3><h4 id="1-原子操作-amp-上下文切换"><a href="#1-原子操作-amp-上下文切换" class="headerlink" title=".1. 原子操作&amp;上下文切换"></a>.1. 原子操作&amp;上下文切换</h4><blockquote>
<p>即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms）。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，从任务保存到再加载的过程就是一次上下文切换。一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。</p>
<ul>
<li>用户级上下文: 正文、数据、用户堆栈以及共享存储区；</li>
<li>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；</li>
<li>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。</li>
</ul>
</blockquote>
<blockquote>
<p>原子操作是指不会被 <a href="http://baike.baidu.com/view/1336364.htm" target="_blank" rel="noopener">线程调度</a> 机制打断的操作； 这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。通常所说的原子操作包括对非long和double型的primitive进行赋值，以及返回这两者之外的primitive。</p>
</blockquote>
<h4 id="2-内核模式-amp-用户模式-amp-混合模式"><a href="#2-内核模式-amp-用户模式-amp-混合模式" class="headerlink" title=".2. 内核模式&amp;用户模式&amp;混合模式"></a>.2. 内核模式&amp;用户模式&amp;混合模式</h4><blockquote>
<p>内核空间和用户空间是现代操作系统的两种工作模式，内核模块运行在内核空间，而用户态应用程序运行在用户空间。它们代表不同的级别，而对系统资源具有不同的访问权限。内核模块运行在最高级别（内核态），这个级下所有的操作都受系统信任，而应用程序运行在较低级别（用户态）。在这个级别，处理器控制着对硬件的直接访问以及对内存的非授权访问。内核态和用户态有自己的内存映射，即自己的地址空间。</p>
<ul>
<li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li>
<li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li>
<li>用户态，运行于用户空间。</li>
</ul>
</blockquote>
<h4 id="3-同步信号量"><a href="#3-同步信号量" class="headerlink" title=".3. 同步信号量"></a>.3. <a href="https://zhuanlan.zhihu.com/p/34410587" target="_blank" rel="noopener">同步信号量</a></h4><blockquote>
<p>信号量（semaphore）是一种用于提供不同进程之间或者一个给定的不同线程间同步手段的原语。信号量多用于进程间的同步与互斥，简单的说一下同步和互斥的意思：</p>
<ul>
<li><strong>同步</strong>：处理竞争就是同步，安排进程执行的先后顺序就是同步，每个进程都有一定的个先后执行顺序。</li>
<li><strong>互斥</strong>：互斥访问不可共享的临界资源，同时会引发两个新的控制问题（互斥可以说是特殊的同步）。</li>
<li><strong>竞争</strong>：当并发进程竞争使用同一个资源的时候，我们就称为竞争进程。</li>
</ul>
<p>共享资源通常分为两类：一类是<code>互斥共享资源</code>，即任一时刻只允许一个进程访问该资源；另一类是<code>同步共享资源</code>，即同一时刻允许多个进程访问该资源；<code>信号量是解决互斥共享资源的同步问题</code>而引入的机制。</p>
</blockquote>
<h3 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h3><h4 id="1-APM"><a href="#1-APM" class="headerlink" title=".1. APM"></a>.1. APM</h4><blockquote>
<p>Add方法中模拟耗时操作（2s）和Main方法中模拟耗时操作（3s）是串行执行的，那么我们有没有一种方法使这两种操作并行执行了？（3s中之内搞定这两个耗时操作）。</p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210703154125613.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210703154403062.png" alt=""></p>
<h4 id="2-线程取消"><a href="#2-线程取消" class="headerlink" title=".2.  线程取消"></a>.2.  线程取消</h4><blockquote>
<p>如果一个任务能够在正常完成之前被外部代码影响进入终结状态，那么这个任务就是可取消的。直觉上看，每个任务都应该能够被外界的命令所取消。</p>
<ol>
<li>用户请求取消。用户通过交互界面显式地发起取消请求，例如取消正在下载的任务。</li>
<li>有时间限制的操作。特别是在大数据的背景下，某些关键路径的操作不可超过一定时延。超时的情况下宁可返回错误提示用户重试，也不可以继续等待导致吞吐下降甚至级联故障。</li>
<li>应用程序事件。例如，通过多线程执行 anyOf 逻辑时，有一个子任务取得结果，则可以乃至应该取消其他子任务。</li>
</ol>
</blockquote>
<h4 id="3-等待-amp-延时"><a href="#3-等待-amp-延时" class="headerlink" title=".3. 等待&amp;延时"></a>.3. 等待&amp;延时</h4><blockquote>
<p> Sleep 的过程中，进程是不能响应外部操作的，变成了假死状态</p>
</blockquote>
<h5 id="1-sleep"><a href="#1-sleep" class="headerlink" title=".1. sleep"></a>.1. sleep</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using System.Threading;  //导入命名空间,类Thread就在此空间中</span><br><span class="line">Thread.Sleep(2000); //延时2s</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-DispatcherTimer"><a href="#2-DispatcherTimer" class="headerlink" title=".2. DispatcherTimer"></a>.2. DispatcherTimer</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tbkLabel.Text = "two seconds delay";</span><br><span class="line"></span><br><span class="line">var timer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(2) };</span><br><span class="line">timer.Start();</span><br><span class="line">timer.Tick += (sender, args) =&gt;</span><br><span class="line">    {</span><br><span class="line">        timer.Stop();</span><br><span class="line">        var page = new Page2();</span><br><span class="line">        page.Show();</span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-Task-Delay"><a href="#3-Task-Delay" class="headerlink" title=".3. Task.Delay"></a>.3. Task.Delay</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tbkLabel.Text = "two seconds delay";</span><br><span class="line"></span><br><span class="line">Task.Delay(2000).ContinueWith(_ =&gt; </span><br><span class="line">   { </span><br><span class="line">     var page = new Page2();</span><br><span class="line">     page.Show();</span><br><span class="line">   }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-异步-等待"><a href="#4-异步-等待" class="headerlink" title=".4. 异步/等待"></a>.4. 异步/等待</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// we need to add the async keyword to the method signature</span><br><span class="line">public async void TheEnclosingMethod()</span><br><span class="line">{</span><br><span class="line">    tbkLabel.Text = "two seconds delay";</span><br><span class="line"></span><br><span class="line">    await Task.Delay(2000);</span><br><span class="line">    var page = new Page2();</span><br><span class="line">    page.Show();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-BackgroundWorker"><a href="#4-BackgroundWorker" class="headerlink" title=".4. BackgroundWorker"></a>.4. BackgroundWorker</h4><blockquote>
<p>BackgroundWorker是.net里用来执行多线程任务的控件，它允许编程者在一个单独的线程上执行一些操作。耗时的操作（如下载和数据库事务）在长时间运行时可能会导致用户界面 (UI) 始终处于停止响应状态。如果您需要能进行响应的用户界面，而且面临与这类操作相关的长时间延迟，则可以使用<strong>BackgroundWorker</strong>类方便地解决问题。</p>
<p>该控件有三个事件：<code>DoWork</code> 、<code>ProgressChanged</code> 和 <code>RunWorkerCompleted</code>在程序中调用<code>RunWorkerAsync方法</code>则会<code>启动DoWork事件</code>的事件处理，当在事件处理过程中，<code>调用 ReportProgress方法</code>则会<code>启动ProgressChanged事件</code>的事件处理，而当<code>DoWork事件处理完成时</code>，则会触发<code>RunWorkerCompleted事件</code>。</p>
<ul>
<li>确保在 DoWork 事件处理程序中<code>不操作任何用户界面对象</code>。而应该<code>通过 ProgressChanged和 RunWorkerCompleted 事件与用户界面进行通信</code>。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">namespace BwTester</span><br><span class="line">{</span><br><span class="line">public partial class Form1 : Form</span><br><span class="line">{</span><br><span class="line">    public Form1()</span><br><span class="line">    {</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    BackgroundWorker backgroundWorker;</span><br><span class="line">    </span><br><span class="line">    private void button1_Click(object sender, EventArgs e)</span><br><span class="line">    {</span><br><span class="line">        backgroundWorker = new BackgroundWorker();</span><br><span class="line">        backgroundWorker.WorkerReportsProgress = true;</span><br><span class="line">        backgroundWorker.DoWork += new DoWorkEventHandler(backgroundWorker_DoWork);</span><br><span class="line">        backgroundWorker.ProgressChanged += new ProgressChangedEventHandler(backgroundWorker_ProgressChanged);</span><br><span class="line">        backgroundWorker.RunWorkerAsync();</span><br><span class="line">    }</span><br><span class="line">    void backgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)</span><br><span class="line">    {</span><br><span class="line">        progressBar1.Value = e.ProgressPercentage;</span><br><span class="line">    }</span><br><span class="line">    void backgroundWorker_DoWork(object sender, DoWorkEventArgs e)</span><br><span class="line">    {</span><br><span class="line">        for (int i = 0; i &lt; 500; i++)</span><br><span class="line">        {</span><br><span class="line">            backgroundWorker.ReportProgress(i);</span><br><span class="line">            Thread.Sleep(100);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="4-并行任务库"><a href="#4-并行任务库" class="headerlink" title="4. 并行任务库"></a>4. 并行任务库</h3><h4 id="1-任务创建及组合"><a href="#1-任务创建及组合" class="headerlink" title=".1. 任务创建及组合"></a>.1. 任务创建及组合</h4><blockquote>
<p>线程是创建并发的底层工具，因此具有一定的局限性。</p>
<ul>
<li>没有简单的方法可以从联合（Join）线程得到“返回值”。因此必须创建一些共享域。当抛出一个异常时，捕捉和处理异常也是麻烦的。</li>
<li>线程完成之后，无法再次启动该线程。相反，只能联合（Join）它（在进程阻塞当前线程）。</li>
</ul>
</blockquote>
<blockquote>
<p>Task 类的表示单个操作不返回一个值，通常以异步方式执行。Task 对象是一个的中心思想 基于任务的异步模式 首次引入.NET Framework 4 中。 因为由执行工作 Task 对象通常以异步方式执行在线程池线程上而不是以同步方式在主应用程序线程，您可以使用 Status 属性，以及 IsCanceled, ，IsCompleted, ，和 IsFaulted 属性，以确定任务的状态。 大多数情况下，lambda 表达式用于指定的任务是执行的工作。</p>
<ul>
<li>task.Resut获取结果时会阻塞线程，即如果task没有执行完成，会等待task执行完成获取到Result，然后再执行后边的代码，</li>
</ul>
</blockquote>
<h5 id="1-Task-创建"><a href="#1-Task-创建" class="headerlink" title=".1. Task 创建"></a>.1. Task 创建</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    //1.new方式实例化一个Task，需要通过Start方法启动</span><br><span class="line">    Task task = new Task(() =&gt;</span><br><span class="line">                         {</span><br><span class="line">                             Thread.Sleep(100);</span><br><span class="line">                             Console.WriteLine($"hello, task1的线程ID为{Thread.CurrentThread.ManagedThreadId}");</span><br><span class="line">                         });</span><br><span class="line">    task.Start();</span><br><span class="line"></span><br><span class="line">    //2.Task.Factory.StartNew(Action action)创建和启动一个Task</span><br><span class="line">    Task task2 = Task.Factory.StartNew(() =&gt;</span><br><span class="line">                                       {</span><br><span class="line">                                           Thread.Sleep(100);</span><br><span class="line">                                           Console.WriteLine($"hello, task2的线程ID为{ Thread.CurrentThread.ManagedThreadId}");</span><br><span class="line">                                       });</span><br><span class="line"></span><br><span class="line">    //3.Task.Run(Action action)将任务放在线程池队列，返回并启动一个Task， 后台线程</span><br><span class="line">    Task task3 = Task.Run(() =&gt;</span><br><span class="line">                          {</span><br><span class="line">                              Thread.Sleep(100);</span><br><span class="line">                              Console.WriteLine($"hello, task3的线程ID为{ Thread.CurrentThread.ManagedThreadId}");</span><br><span class="line">                          });</span><br><span class="line">    Console.WriteLine("执行主线程！");</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">}</span><br><span class="line">//先打印"执行主线程"，然后再打印各个任务，说明了Task不会阻塞主线程。上边的栗子Task都没有返回值，我们也可以创建有返回值的~task，用法和没有返回值的基本一致,</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-Task-同步"><a href="#2-Task-同步" class="headerlink" title=".2. Task 同步"></a>.2. Task 同步</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Task task = new Task(() =&gt;</span><br><span class="line">                         {</span><br><span class="line">                             Thread.Sleep(100);</span><br><span class="line">                             Console.WriteLine("执行Task结束!");</span><br><span class="line">                         });</span><br><span class="line">    //同步执行，task会阻塞主线程</span><br><span class="line">    task.RunSynchronously();</span><br><span class="line">    Console.WriteLine("执行主线程结束！");</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-Task-阻塞"><a href="#3-Task-阻塞" class="headerlink" title=".3. Task 阻塞"></a>.3. Task 阻塞</h5><ul>
<li><strong>Wait/WaitAny/WaitAll</strong></li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Task task1 = new Task(() =&gt; {</span><br><span class="line">        Thread.Sleep(500);</span><br><span class="line">        Console.WriteLine("线程1执行完毕！");</span><br><span class="line">    });</span><br><span class="line">    task1.Start();</span><br><span class="line">    Task task2 = new Task(() =&gt; {</span><br><span class="line">        Thread.Sleep(1000);</span><br><span class="line">        Console.WriteLine("线程2执行完毕！");</span><br><span class="line">    });</span><br><span class="line">    task2.Start();</span><br><span class="line">    //阻塞主线程。task1,task2都执行完毕再执行主线程</span><br><span class="line">    //执行【task1.Wait();task2.Wait();】可以实现相同功能</span><br><span class="line">    //调用Wait方法，可以阻塞任务，直至任务完成，效果等同于Thread.Join：</span><br><span class="line">    Task.WaitAll(new Task[]{ task1,task2});</span><br><span class="line">    Console.WriteLine("主线程执行完毕！");</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>延续操作</strong></li>
</ul>
<blockquote>
<p>让所有task执行完毕(或者任一task执行完毕)后，<code>开始执行后续操作</code>。WhenAny/WhenAll方法了，这些方法执行完成返回一个task实例。 task.WhenAll(Task[] tasks) 表示所有的task都执行完毕后再去执行后续的操作， task.WhenAny(Task[] tasks) 表示任一task执行完毕后就开始执行后续操作。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Task task1 = new Task(() =&gt; {</span><br><span class="line">        Thread.Sleep(500);</span><br><span class="line">        Console.WriteLine("线程1执行完毕！");</span><br><span class="line">    });</span><br><span class="line">    task1.Start();</span><br><span class="line">    Task task2 = new Task(() =&gt; {</span><br><span class="line">        Thread.Sleep(1000);</span><br><span class="line">        Console.WriteLine("线程2执行完毕！");</span><br><span class="line">    });</span><br><span class="line">    task2.Start();</span><br><span class="line">    //通过TaskFactroy实现</span><br><span class="line">    Task.Factory.ContinueWhenAll(new Task[] { task1, task2 }, (t) =&gt;</span><br><span class="line">                                 {</span><br><span class="line">                                     Thread.Sleep(100);</span><br><span class="line">                                     Console.WriteLine("执行后续操作");</span><br><span class="line">                                 });</span><br><span class="line"></span><br><span class="line">    Console.WriteLine("主线程执行完毕！");</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Task task1 = new Task(() =&gt; {</span><br><span class="line">        Thread.Sleep(500);</span><br><span class="line">        Console.WriteLine("线程1执行完毕！");</span><br><span class="line">    });</span><br><span class="line">    task1.Start();</span><br><span class="line">    Task task2 = new Task(() =&gt; {</span><br><span class="line">        Thread.Sleep(1000);</span><br><span class="line">        Console.WriteLine("线程2执行完毕！");</span><br><span class="line">    });</span><br><span class="line">    task2.Start();</span><br><span class="line">    //task1，task2执行完了后执行后续操作</span><br><span class="line">    Task.WhenAll(task1, task2).ContinueWith((t) =&gt; {</span><br><span class="line">        Thread.Sleep(100);</span><br><span class="line">        Console.WriteLine("执行后续操作完毕！");</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    Console.WriteLine("主线程执行完毕！");</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-Task-取消"><a href="#4-Task-取消" class="headerlink" title=".4. Task 取消"></a>.4. Task 取消</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    bool isStop = false;</span><br><span class="line">    int index = 0;</span><br><span class="line">    //开启一个线程执行任务</span><br><span class="line">    Thread th1 = new Thread(() =&gt;</span><br><span class="line">                            {</span><br><span class="line">                                while (!isStop)</span><br><span class="line">                                {</span><br><span class="line">                                    Thread.Sleep(1000);</span><br><span class="line">                                    Console.WriteLine($"第{++index}次执行，线程运行中...");</span><br><span class="line">                                }</span><br><span class="line">                            });</span><br><span class="line">    th1.Start();</span><br><span class="line">    //五秒后取消任务执行</span><br><span class="line">    Thread.Sleep(5000);</span><br><span class="line">    isStop = true;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>使用CancellationTokenSource</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    CancellationTokenSource source = new CancellationTokenSource();</span><br><span class="line">    int index = 0;</span><br><span class="line">    //开启一个task执行任务</span><br><span class="line">    Task task1 = new Task(() =&gt;</span><br><span class="line">                          {</span><br><span class="line">                              while (!source.IsCancellationRequested)</span><br><span class="line">                              {</span><br><span class="line">                                  Thread.Sleep(1000);</span><br><span class="line">                                  Console.WriteLine($"第{++index}次执行，线程运行中...");</span><br><span class="line">                              }</span><br><span class="line">                          });</span><br><span class="line">    task1.Start();</span><br><span class="line">    //五秒后取消任务执行</span><br><span class="line">    Thread.Sleep(5000);</span><br><span class="line">    //source.Cancel()方法请求取消任务，IsCancellationRequested会变成true</span><br><span class="line">    source.Cancel();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    CancellationTokenSource source = new CancellationTokenSource();</span><br><span class="line">    //注册任务取消的事件</span><br><span class="line">    source.Token.Register(() =&gt;</span><br><span class="line">                          {</span><br><span class="line">                              Console.WriteLine("任务被取消后执行xx操作！");</span><br><span class="line">                          });</span><br><span class="line"></span><br><span class="line">    int index = 0;</span><br><span class="line">    //开启一个task执行任务</span><br><span class="line">    Task task1 = new Task(() =&gt;</span><br><span class="line">                          {</span><br><span class="line">                              while (!source.IsCancellationRequested)</span><br><span class="line">                              {</span><br><span class="line">                                  Thread.Sleep(1000);</span><br><span class="line">                                  Console.WriteLine($"第{++index}次执行，线程运行中...");</span><br><span class="line">                              }</span><br><span class="line">                          });</span><br><span class="line">    task1.Start();</span><br><span class="line">    //延时取消，效果等同于Thread.Sleep(5000);source.Cancel();</span><br><span class="line">    source.CancelAfter(5000);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>跨线程</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public partial class Form1 : Form</span><br><span class="line">{</span><br><span class="line">    public Form1()</span><br><span class="line">    {</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void mySetValueBtn_Click(object sender, EventArgs e)</span><br><span class="line">    {</span><br><span class="line">        Task.Run(() =&gt;</span><br><span class="line">                 {</span><br><span class="line">                     Action&lt;int&gt; setValue = (i) =&gt; { myTxtbox.Text = i.ToString(); };</span><br><span class="line">                     for (int i = 0; i &lt; 1000000; i++)</span><br><span class="line">                     {</span><br><span class="line">                         myTxtbox.Invoke(setValue,i);</span><br><span class="line">                     }</span><br><span class="line">                 });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="5-返回值"><a href="#5-返回值" class="headerlink" title=".5. 返回值"></a>.5. 返回值</h5><p><code>Task&lt;TResult&gt;</code>允许任务返回一个值。调用<code>Task.Run</code>，传入一个<code>Func&lt;TResult&gt;</code>代理（或者兼容的Lambda表达式），代替Action，就可以获得一个Task<tresult>：</tresult></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;int&gt; task = Task.Run (() =&gt; { Console.WriteLine ("Foo"); return 3; });</span><br><span class="line"></span><br><span class="line">int result = task.Result;      // Blocks if not already finished</span><br><span class="line">Console.WriteLine (result);    // 3</span><br></pre></td></tr></tbody></table></figure>

<p>下面的例子创建一个任务，它使用LINQ就按前3百万个整数（从2开始）中的素数个数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;int&gt; primeNumberTask = Task.Run(() =&gt;</span><br><span class="line">                                     Enumerable.Range(2, 3000000).Count(n =&gt; Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =&gt; n % i &gt; 0)));</span><br><span class="line"></span><br><span class="line">Console.WriteLine("Task running...");</span><br><span class="line">Console.WriteLine("The answer is " + primeNumberTask.Result);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-延迟"><a href="#6-延迟" class="headerlink" title=".6. 延迟"></a>.6. 延迟</h5><p><code>Task.Delay</code>是<code>Thread.Sleep</code>的异步版本</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.Delay(5000).GetAwaiter().OnCompleted(()=&gt;Console.WriteLine(42));</span><br></pre></td></tr></tbody></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.Delay(5000).ContinueWith(ant =&gt; Console.WriteLine(42));</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-线程相关"><a href="#2-线程相关" class="headerlink" title="2. 线程相关"></a>2. 线程相关</h4><h5 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1. 创建线程"></a>1. 创建线程</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Thread t = new Thread(PrintNumbers);</span><br><span class="line">    t.Start();//线程开始执行</span><br><span class="line">    PrintNumbers();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">static void PrintNumbers()</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("Starting...");</span><br><span class="line">    for (int i = 1; i &lt; 10; i++)</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-暂停线程"><a href="#2-暂停线程" class="headerlink" title="2. 暂停线程"></a>2. 暂停线程</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">{</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    {</span><br><span class="line">        Thread t = new Thread(PrintNumbersWithDelay);</span><br><span class="line">        t.Start();</span><br><span class="line">        PrintNumbers();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static void PrintNumbers()</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Starting...");</span><br><span class="line">        for (int i = 1; i &lt; 10; i++)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static void PrintNumbersWithDelay()</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Starting...");</span><br><span class="line">        for (int i = 1; i &lt; 10; i++)</span><br><span class="line">        {</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(2));//暂停2S</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-线程等待"><a href="#3-线程等待" class="headerlink" title="3. 线程等待"></a>3. 线程等待</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">{</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Starting program...");</span><br><span class="line">        Thread t = new Thread(PrintNumbersWithDelay);</span><br><span class="line">        t.Start();</span><br><span class="line">        t.Join();</span><br><span class="line">        Console.WriteLine("Thread completed");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static void PrintNumbersWithDelay()</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Starting...");</span><br><span class="line">        for (int i = 1; i &lt; 10; i++)</span><br><span class="line">        {</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(2));</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-终止线程"><a href="#4-终止线程" class="headerlink" title="4. 终止线程"></a>4. 终止线程</h5><blockquote>
<p>并不推荐使用,Abort方法来关闭线程。可优先使用一些其他方法,比如提供一个CancellationToken方法来,取消线程的执行。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">{</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Starting program...");</span><br><span class="line">        Thread t = new Thread(PrintNumbersWithDelay);</span><br><span class="line">        t.Start();</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(6));</span><br><span class="line">        t.Abort();</span><br><span class="line">        Console.WriteLine("A thread has been aborted");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static void PrintNumbersWithDelay()</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Starting...");</span><br><span class="line">        for (int i = 1; i &lt; 10; i++)</span><br><span class="line">        {</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(2));</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="5-监控线程状态"><a href="#5-监控线程状态" class="headerlink" title="5.监控线程状态"></a>5.监控线程状态</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">{</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Starting program...");</span><br><span class="line">        Thread t = new Thread(PrintNumbersWithStatus);</span><br><span class="line">        Thread t2 = new Thread(DoNothing);</span><br><span class="line">        Console.WriteLine(t.ThreadState.ToString());</span><br><span class="line">        t2.Start();</span><br><span class="line">        t.Start();</span><br><span class="line">        for (int i = 1; i &lt; 30; i++)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(t.ThreadState.ToString());</span><br><span class="line">        }</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(6));</span><br><span class="line">        t.Abort();</span><br><span class="line">        Console.WriteLine("A thread has been aborted");</span><br><span class="line">        Console.WriteLine(t.ThreadState.ToString());</span><br><span class="line">        Console.WriteLine(t2.ThreadState.ToString());</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static void DoNothing()</span><br><span class="line">    {</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(2));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static void PrintNumbersWithStatus()</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Starting...");</span><br><span class="line">        Console.WriteLine(Thread.CurrentThread.ThreadState.ToString());</span><br><span class="line">        for (int i = 1; i &lt; 10; i++)</span><br><span class="line">        {</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(2));</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="7-线程传参"><a href="#7-线程传参" class="headerlink" title="7. 线程传参"></a>7. 线程传参</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">{</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    {</span><br><span class="line">        var sample = new ThreadSample(10);</span><br><span class="line"></span><br><span class="line">        var threadOne = new Thread(sample.CountNumbers);</span><br><span class="line">        threadOne.Name = "ThreadOne";</span><br><span class="line">        threadOne.Start();</span><br><span class="line">        threadOne.Join();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine("--------------------------");</span><br><span class="line"></span><br><span class="line">        var threadTwo = new Thread(Count);</span><br><span class="line">        threadTwo.Name = "ThreadTwo";</span><br><span class="line">        threadTwo.Start(8);</span><br><span class="line">        threadTwo.Join();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine("--------------------------");</span><br><span class="line"></span><br><span class="line">        var threadThree = new Thread(() =&gt; CountNumbers(12));</span><br><span class="line">        threadThree.Name = "ThreadThree";</span><br><span class="line">        threadThree.Start();</span><br><span class="line">        threadThree.Join();</span><br><span class="line">        Console.WriteLine("--------------------------");</span><br><span class="line"></span><br><span class="line">        int i = 10;</span><br><span class="line">        var threadFour = new Thread(() =&gt; PrintNumber(i));</span><br><span class="line">        i = 20;</span><br><span class="line">        var threadFive = new Thread(() =&gt; PrintNumber(i));</span><br><span class="line">        threadFour.Start(); </span><br><span class="line">        threadFive.Start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static void Count(object iterations)</span><br><span class="line">    {</span><br><span class="line">        CountNumbers((int)iterations);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static void CountNumbers(int iterations)</span><br><span class="line">    {</span><br><span class="line">        for (int i = 1; i &lt;= iterations; i++)</span><br><span class="line">        {</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(0.5));</span><br><span class="line">            Console.WriteLine("{0} prints {1}", Thread.CurrentThread.Name, i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static void PrintNumber(int number)</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    class ThreadSample</span><br><span class="line">    {</span><br><span class="line">        private readonly int _iterations;</span><br><span class="line"></span><br><span class="line">        public ThreadSample(int iterations)</span><br><span class="line">        {</span><br><span class="line">            _iterations = iterations;</span><br><span class="line">        }</span><br><span class="line">        public void CountNumbers()</span><br><span class="line">        {</span><br><span class="line">            for (int i = 1; i &lt;= _iterations; i++)</span><br><span class="line">            {</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(0.5));</span><br><span class="line">                Console.WriteLine("{0} prints {1}", Thread.CurrentThread.Name, i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-APM-gt-Task"><a href="#2-APM-gt-Task" class="headerlink" title=".2. APM->Task"></a>.2. APM-&gt;Task</h4><blockquote>
<p>APM(Asynchronous Programming Model)是.Net 旧版本中广泛使用的异步编程模型。使用了 APM的异步方法会返回一个 <code>IAsyncResult 对象</code>，这个对象有一个重要的属性 <code>AsyncWaitHandle</code>，他是一个用来等待异步任务执行结束的一个同步信号。 <code>方法名字以 BeginXXX 开头，返回类型为 IAsyncResult，调用结束后需要EndXXX。</code></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileStream fs = File.OpenRead("d:/1.txt");</span><br><span class="line">byte[] buffer = new byte[16];</span><br><span class="line">IAsyncResult aResult = fs.BeginRead(buffer, 0, buffer.Length, null, null);</span><br><span class="line">aResult.AsyncWaitHandle.WaitOne();//等待任务执行结束</span><br><span class="line">MessageBox.Show(Encoding.UTF8.GetString(buffer));</span><br><span class="line">fs.EndRead(aResult);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 异步计算接口</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;</span><br><span class="line">public interface ICalculator&lt;T&gt;</span><br><span class="line">{</span><br><span class="line">    IAsyncResult BeginAdd(T x, T y, AsyncCallback asyncCallback, Object obj);</span><br><span class="line"></span><br><span class="line">    T EndAdd(IAsyncResult ar);</span><br><span class="line">}</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 异步计算接口实现类</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class Calculator : ICalculator&lt;double&gt;</span><br><span class="line">{</span><br><span class="line">    public IAsyncResult BeginAdd(double x, double y, AsyncCallback asyncCallback, Object obj)</span><br><span class="line">    {</span><br><span class="line">        return CalculatorAsyncResult&lt;double&gt;.CreateCalculatorAsyncResult(delegate { return Add(x, y); }, asyncCallback, obj);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public double EndAdd(IAsyncResult ar)</span><br><span class="line">    {</span><br><span class="line">        var calculatorAsyncResult = (CalculatorAsyncResult&lt;double&gt;)(ar);</span><br><span class="line">        Console.WriteLine("EndAdd Wait() start");</span><br><span class="line">        calculatorAsyncResult.Wait();</span><br><span class="line">        Console.WriteLine("EndAdd Wait() Invoke");</span><br><span class="line">        return calculatorAsyncResult.CalulatorResult;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 计算方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name="x"&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name="y"&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    protected double Add(double x, double y)</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Async thread(id={0}) begins.\n", Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(3000);</span><br><span class="line"></span><br><span class="line">        var r = x + y;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine("Async thread(id={0}) ends.\n", Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">        return r;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1 /// &lt;summary&gt;</span><br><span class="line"> 2         /// 异步</span><br><span class="line"> 3         /// &lt;/summary&gt;</span><br><span class="line"> 4         /// &lt;param name="sender"&gt;&lt;/param&gt;</span><br><span class="line"> 5         /// &lt;param name="e"&gt;&lt;/param&gt;</span><br><span class="line"> 6         private void button2_Click(object sender, EventArgs e)</span><br><span class="line"> 7         {</span><br><span class="line">11             var url = this.textBox1.Text.Trim();</span><br><span class="line">12             var request = HttpWebRequest.Create(url);</span><br><span class="line">13             request.BeginGetResponse(AsyncCallbackImpl, request);//BeginGetResponse,发起异步请求</span><br><span class="line">14         }</span><br><span class="line">15 </span><br><span class="line">16         /// &lt;summary&gt;</span><br><span class="line">17         /// 回调</span><br><span class="line">18         /// &lt;/summary&gt;</span><br><span class="line">19         /// &lt;param name="ar"&gt;&lt;/param&gt;</span><br><span class="line">20         public void AsyncCallbackImpl(IAsyncResult ar)</span><br><span class="line">21         {</span><br><span class="line">22             HttpWebRequest request = ar.AsyncState as HttpWebRequest;</span><br><span class="line">23             var response = request.EndGetResponse(ar);//EndGetResponse,异步请求完成</span><br><span class="line">24             var stream = response.GetResponseStream();</span><br><span class="line">25             StringBuilder sb = new StringBuilder();</span><br><span class="line">26             sb.AppendLine("当前线程Id:" + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">27             using (StreamReader reader = new StreamReader(stream))</span><br><span class="line">28             {</span><br><span class="line">29                 var content = reader.ReadLine();</span><br><span class="line">30                 sb.AppendLine(content);</span><br><span class="line">31                 this.richTextBox1.Text = sb.ToString();</span><br><span class="line">32             }</span><br><span class="line">33         }</span><br><span class="line">34</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-EAP-gt-Task"><a href="#3-EAP-gt-Task" class="headerlink" title=".3. EAP ->Task"></a>.3. EAP -&gt;Task</h4><blockquote>
<p>基于<code>事件的异步模式</code>是.net 2.0提出的，实现了基于事件的异步模式的类<code>将具有一个或者多个以Async为后缀的方法</code>和<code>对应的Completed事件</code>，并且这些类都支持<code>异步方法的取消、进度报告和报告结果</code>。</p>
<p>EAP模式类似于 Ajax 中的XmlHttpRequest，<code>send 之后并不是处理完成了</code>，而是在 <code>onreadystatechange 事件中再通知处理完成</code>。</p>
<p>优点是简单，缺点是当实现复杂的业务的时候很麻烦，比如下载 A 成功后再下载 b，如果下载 b成功再下载 c，否则就下载 d。</p>
<p>当调用基于事件的EAP模式的类的XXXAsync方法时，就开始了一个异步操作，并且基于事件的EAP模式是基于APM模式之上的，而APM又是建立在委托之上的。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BackgroundWorker worker = new BackgroundWorker();</span><br><span class="line">worker.DoWork += Worker_DoWork;</span><br><span class="line">worker.RunWorkerCompleted += Worker_RunWorkerCompleted;</span><br><span class="line">worker.RunWorkerAsync(null);</span><br><span class="line"></span><br><span class="line">private static void Worker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("dowork completed");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private static void Worker_DoWork(object sender, DoWorkEventArgs e)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("dowork");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WebClient wc = new WebClient();</span><br><span class="line">wc.DownloadStringCompleted += Wc_DownloadStringCompleted;</span><br><span class="line">wc.DownloadStringAsync(new Uri("http://www.baidu.com"));</span><br><span class="line"></span><br><span class="line">private void Wc_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)</span><br><span class="line">{</span><br><span class="line">　　MessageBox.Show(e.Result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-TAP-gt-Task"><a href="#4-TAP-gt-Task" class="headerlink" title=".4. TAP->Task"></a>.4. TAP-&gt;Task</h4><blockquote>
<p>.net 4.0为我们带来了Task的异步，我们有以下三种方法创建Task。</p>
<p>1，Task.Factory.StartNew()，比较常用。</p>
<p>2，Task t1 = new Task(() =&gt; { Console.WriteLine(“t1 start”); });  t1.Start();</p>
<p>3，Task.Run()，是.net 4.5中增加的。</p>
<p>4，Task.FromResult()，如果结果是已计算，就可以使用这种方法来创建任务。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("start"); </span><br><span class="line">    Task task1= Task.Run(() =&gt;</span><br><span class="line">    {</span><br><span class="line">        Thread.Sleep(2000); </span><br><span class="line">        Console.WriteLine("task1");</span><br><span class="line">    });</span><br><span class="line">    Task task2=Task.Run(() =&gt;</span><br><span class="line">    {</span><br><span class="line">        Thread.Sleep(3000); </span><br><span class="line">        Console.WriteLine("task2");</span><br><span class="line">    });</span><br><span class="line">    Task.WaitAll(task1,task2);</span><br><span class="line">    Console.WriteLine($"task1 task2已经执行完成");</span><br><span class="line">    Task task3=Task.Run(() =&gt;</span><br><span class="line">    {</span><br><span class="line">        Thread.Sleep(5000); </span><br><span class="line">        Console.WriteLine("task3");</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    Console.WriteLine("end"); </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="5-TaskScheduler"><a href="#5-TaskScheduler" class="headerlink" title=".5. TaskScheduler"></a>.5. TaskScheduler</h4><h5 id="1-ThreadPoolTaskScheduler"><a href="#1-ThreadPoolTaskScheduler" class="headerlink" title=".1. ThreadPoolTaskScheduler"></a>.1. ThreadPoolTaskScheduler</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected internal override void QueueTask(Task task)</span><br><span class="line">{</span><br><span class="line">    if ((task.Options &amp; TaskCreationOptions.LongRunning) != TaskCreationOptions.None)</span><br><span class="line">    {</span><br><span class="line">        new Thread(ThreadPoolTaskScheduler.s_longRunningThreadWork)</span><br><span class="line">        {</span><br><span class="line">            IsBackground = true</span><br><span class="line">        }.Start(task);</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line">    bool forceGlobal = (task.Options &amp; TaskCreationOptions.PreferFairness) &gt; TaskCreationOptions.None;</span><br><span class="line">    ThreadPool.UnsafeQueueCustomWorkItem(task, forceGlobal);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-SynchronizationContextTaskScheduler"><a href="#2-SynchronizationContextTaskScheduler" class="headerlink" title=".2. SynchronizationContextTaskScheduler"></a>.2. SynchronizationContextTaskScheduler</h5><blockquote>
<p>这是一个同步上下文的taskscheduler，原理就是把繁重的耗时工作丢给ThreadPool，然后将更新UI的操作丢给 UI线程的队列中</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">{</span><br><span class="line">    Task task = Task.Factory.StartNew(() =&gt;</span><br><span class="line">                                      {</span><br><span class="line">                                          //复杂操作，等待10s</span><br><span class="line">                                          Thread.Sleep(10000);</span><br><span class="line"></span><br><span class="line">                                      }).ContinueWith((t) =&gt;</span><br><span class="line">                                                      {</span><br><span class="line">                                                          button1.Text = "hello world";</span><br><span class="line">                                                      }, TaskScheduler.FromCurrentSynchronizationContext());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-async-await"><a href="#5-async-await" class="headerlink" title="5. async/await"></a>5. async/await</h3><h4 id="1-async-await使用"><a href="#1-async-await使用" class="headerlink" title=".1. async/await使用"></a>.1. async/await使用</h4><blockquote>
<p>await 后面跟上一个异步操作Task，当程序执行到此行代码时，由于有await的修饰，会等待异步操作Task执行，<code>Task执行完成后才会执行此方法里await这一行后面的代码</code>.</p>
<ul>
<li>async用来声明一个异步方法，await是一个上下文关键字（跟代码上下文相关），必须和async配套使用才会生效，await用来声明异步方法中一个可能会产生阻塞的操作（方法）。</li>
<li>当将方法用async标识时且返回值为void或者Task或者Task<treuslt>，此时该方法会在当前线程中一直同步执行。用async标识方法并不会影响方法运行完成是否是同步或者异步，相反，它能够将方法划分成多块，有可能有些在异步中运行，以至于这些方法是异步完成的，而划分异步和同步方法的边界就是使用await关键字。也就是说如果在方法中未用到await关键字时则该方法就是一整块没有所谓的划分，会在同步中运行，在同步中完成。</treuslt></li>
<li>C#编译器一旦遇到以async声明的方法（即异步方法）时会在这个方法中尝试寻找await关键字，如果找到以await关键字声明的方法，就会自动生成一些代码，这些代码负责<strong>启动后台线程，尝试找到空闲的CPU内核运行以await声明的方法（即以异步方式运行）</strong>，完成这一切后调用者线程从异步方法返回。后台线程在运行完以await声明的方法后会结束，此时await关键字生成的代码还负责提取方法的返回结果，所以干活的都是await，async实际上只是提醒编译器”你看到有async关键字的方法时进去方法内部是不是有个await关键字，有的话就干活”。</li>
<li>C#中可以用<code>async</code>标识方法，表示这个方法是异步的。异步方法的返回值必须是<code>void</code>、<code>Task</code>或者<code>Task&lt;T&gt;</code>。</li>
</ul>
</blockquote>
<ul>
<li>Method 1和Method 2不相互依赖, 并且俩个方法一起执行</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">{  </span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    {  </span><br><span class="line">        Method1();</span><br><span class="line">        Method2();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    public static async Task Method1()</span><br><span class="line">    {  </span><br><span class="line">        await Task.Run(() =&gt;</span><br><span class="line">                       {  </span><br><span class="line">                           for (int i = 0; i &lt; 100; i++)</span><br><span class="line">                           {  </span><br><span class="line">                               Console.WriteLine(" Method 1");  </span><br><span class="line">                           }  </span><br><span class="line">                       });  </span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void Method2()</span><br><span class="line">    {  </span><br><span class="line">        for (int i = 0; i &lt; 25; i++)</span><br><span class="line">        {  </span><br><span class="line">            Console.WriteLine(" Method 2");  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>Method 1将总长度作为整数值返回，我们在Method 3中以长度的形式传递一个参数，它来自Method 1，在控制台应用程序的Main方法中，因为不能使用async关键字而不能使用await 关键字</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">{  </span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    {  </span><br><span class="line">        callMethod();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    public static async void callMethod()</span><br><span class="line">    {  </span><br><span class="line">        Task&lt;int&gt; task = Method1();</span><br><span class="line">        Method2();</span><br><span class="line">        int count = await task;</span><br><span class="line">        Method3(count);</span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    public static async Task&lt;int&gt; Method1()</span><br><span class="line">    {  </span><br><span class="line">        int count = 0;</span><br><span class="line">        await Task.Run(() =&gt;</span><br><span class="line">                       {  </span><br><span class="line">                           for (int i = 0; i &lt; 100; i++)</span><br><span class="line">                           {  </span><br><span class="line">                               Console.WriteLine(" Method 1");  </span><br><span class="line">                               count += 1;</span><br><span class="line">                           }  </span><br><span class="line">                       });  </span><br><span class="line">        return count;</span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    public static void Method2()</span><br><span class="line">    {  </span><br><span class="line">        for (int i = 0; i &lt; 25; i++)</span><br><span class="line">        {  </span><br><span class="line">            Console.WriteLine(" Method 2");  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    public static void Method3(int count)</span><br><span class="line">    {  </span><br><span class="line">        Console.WriteLine("Total count is " + count);</span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>demo</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">{  </span><br><span class="line">    static void Main()</span><br><span class="line">    {  </span><br><span class="line">        Task task = new Task(CallMethod);</span><br><span class="line">        task.Start();</span><br><span class="line">        task.Wait();</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    static async void CallMethod()</span><br><span class="line">    {  </span><br><span class="line">        string filePath = "E:\\sampleFile.txt";  </span><br><span class="line">        Task&lt;int&gt; task = ReadFile(filePath);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(" Other Work 1");  </span><br><span class="line">        Console.WriteLine(" Other Work 2");  </span><br><span class="line">        Console.WriteLine(" Other Work 3");  </span><br><span class="line"></span><br><span class="line">        int length = await task;</span><br><span class="line">        Console.WriteLine(" Total length: " + length);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(" After work 1");  </span><br><span class="line">        Console.WriteLine(" After work 2");  </span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    static async Task&lt;int&gt; ReadFile(string file)</span><br><span class="line">    {  </span><br><span class="line">        int length = 0;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(" File reading is stating");  </span><br><span class="line">        using (StreamReader reader = new StreamReader(file))</span><br><span class="line">        {  </span><br><span class="line">            // Reads all characters from the current position to the end of the stream asynchronously   </span><br><span class="line">            // and returns them as one string.   </span><br><span class="line">            string s = await reader.ReadToEndAsync();</span><br><span class="line"></span><br><span class="line">            length = s.Length;</span><br><span class="line">        }  </span><br><span class="line">        Console.WriteLine(" File reading is completed");  </span><br><span class="line">        return length;</span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210701093301230.png" alt=""></p>
<h4 id="2-lambda-表达式"><a href="#2-lambda-表达式" class="headerlink" title=".2. lambda 表达式"></a>.2. lambda 表达式</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210703182502755.png" alt=""></h4><h3 id="6-并发集合"><a href="#6-并发集合" class="headerlink" title="6. 并发集合"></a>6. 并发集合</h3><blockquote>
<p>线程安全：多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的.</p>
<p>线程不安全：不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据<br> 举例：购票系统有1000张票。A线程和B线程同时抢票，有时候会抢到同一张票。这是就是线程不安全。两个线程可能同时抢一个数据。这时候就要用到锁了.</p>
</blockquote>
<h4 id="1-ConcurrentQueue"><a href="#1-ConcurrentQueue" class="headerlink" title=".1. ConcurrentQueue"></a>.1. <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentqueue-1?view=net-5.0" target="_blank" rel="noopener">ConcurrentQueue</a></h4><blockquote>
<p>ConcurrentQueue<t>队列是一个高效的线程安全的队列，是.Net Framework 4.0,System.Collections.Concurrent 命名空间下的一个数据结构.</t></p>
</blockquote>
<h4 id="2-ConcurrentDictionary"><a href="#2-ConcurrentDictionary" class="headerlink" title=".2. ConcurrentDictionary"></a>.2. ConcurrentDictionary</h4><h4 id="3-ConcurrentStack"><a href="#3-ConcurrentStack" class="headerlink" title=".3. ConcurrentStack"></a>.3. ConcurrentStack</h4><h4 id="4-ConcurrentBag"><a href="#4-ConcurrentBag" class="headerlink" title=".4. ConcurrentBag"></a>.4. <a href="https://www.cnblogs.com/taisenki/p/7699667.html" target="_blank" rel="noopener">ConcurrentBag</a></h4><blockquote>
<p>ConcurrentBag是一个专门的并发包裹，在连接池（多线程数据交互）的实现上具有比LinkedBlockingQueue和LinkedTransferQueue更优越的性能。<br>ConcurrentBag通过拆分 <code>CopyOnWriteArrayList、ThreadLocal和SynchronousQueue</code><br>进行并发数据交互。</p>
<ul>
<li>CopyOnWriteArrayList：负责存放ConcurrentBag中全部用于出借的资源</li>
<li>ThreadLocal：用于加速线程本地化资源访问</li>
<li>SynchronousQueue：用于存在资源等待线程时的第一手资源交接</li>
<li>ConcurrentBag中全部的资源均只能通过add方法进行添加，只能通过remove方法进行移出。</li>
</ul>
</blockquote>
<h4 id="5-BlockingCollection"><a href="#5-BlockingCollection" class="headerlink" title=".5. BlockingCollection"></a>.5. BlockingCollection</h4><h3 id="7-PLINQ"><a href="#7-PLINQ" class="headerlink" title="7. PLINQ"></a>7. PLINQ</h3><blockquote>
<p>任务并行库 (TPL) 是 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading" target="_blank" rel="noopener">System.Threading</a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks" target="_blank" rel="noopener">System.Threading.Tasks</a> 空间中的一组公共类型和 API。 TPL 的目的是通过简化将并行和并发添加到应用程序的过程来提高开发人员的工作效率。 Parallel类提供<strong>数据和任务</strong>的并行性；</p>
</blockquote>
<h4 id="1-数据并行"><a href="#1-数据并行" class="headerlink" title=".1. 数据并行"></a>.1. 数据并行</h4><blockquote>
<p><em>数据并行</em> 指的是对源集合或数组的元素同时（即，并行）执行相同操作的场景。 在数据并行操作中，对源集合进行分区，以便多个线程能够同时在不同的网段上操作。</p>
</blockquote>
<h5 id="1-Foreach"><a href="#1-Foreach" class="headerlink" title=".1.  Foreach"></a>.1.  Foreach</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Sequential version</span><br><span class="line">foreach (var item in sourceCollection)</span><br><span class="line">{</span><br><span class="line">    Process(item);</span><br><span class="line">}</span><br><span class="line">// Parallel equivalent</span><br><span class="line">Parallel.ForEach(sourceCollection, item =&gt; Process(item));</span><br><span class="line">//自定义数组， 可以解决ForEach中参数传递问题</span><br><span class="line">List&lt;Kinectenv&gt; kinectenvs = convertFromeEnv(e);</span><br><span class="line">_ = Parallel.ForEach(kinectenvs, (pair) =&gt;</span><br><span class="line">                     {</span><br><span class="line">                         HandleSingSkeleton(pair.kinectId,pair.skeleton,pair.image, rtime);</span><br><span class="line">                     });</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-For"><a href="#2-For" class="headerlink" title=".2. For"></a>.2. For</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">namespace ConsoleApp1</span><br><span class="line">{</span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            int[] nums = new int[] { , , , , , , , , , , ,  };</span><br><span class="line">            Parallel.For(, nums.Length, (i) =&gt;</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine("针对数组索引{0}对应的那个元素{1}的一些工作代码……ThreadId={2}", i, nums[i], Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            });</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-退出"><a href="#3-退出" class="headerlink" title=".3. 退出"></a>.3. 退出</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    ConcurrentBag&lt;int&gt; bag = new ConcurrentBag&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">    Parallel.For(, , (i, state) =&gt;</span><br><span class="line">                 {</span><br><span class="line">                     if (bag.Count == )</span><br><span class="line">                     {</span><br><span class="line">                         //state.Break();</span><br><span class="line">                         state.Stop();</span><br><span class="line">                         return;</span><br><span class="line">                     }</span><br><span class="line">                     bag.Add(i);</span><br><span class="line">                 });</span><br><span class="line"></span><br><span class="line">    Console.WriteLine("当前集合有{0}个元素。", bag.Count);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title=".4. 异常处理"></a>.4. 异常处理</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static void ProcessDataInParallel(byte[] data)</span><br><span class="line">{</span><br><span class="line">    // Use ConcurrentQueue to enable safe enqueueing from multiple threads.</span><br><span class="line">    var exceptions = new ConcurrentQueue&lt;Exception&gt;();</span><br><span class="line"></span><br><span class="line">    // Execute the complete loop and capture all exceptions.</span><br><span class="line">    Parallel.ForEach(data, d =&gt;</span><br><span class="line">                     {</span><br><span class="line">                         try</span><br><span class="line">                         {</span><br><span class="line">                             // Cause a few exceptions, but not too many.</span><br><span class="line">                             if (d &lt; 3)</span><br><span class="line">                                 throw new ArgumentException($"Value is {d}. Value must be greater than or equal to 3.");</span><br><span class="line">                             else</span><br><span class="line">                                 Console.Write(d + " ");</span><br><span class="line">                         }</span><br><span class="line">                         // Store the exception and continue with the loop.</span><br><span class="line">                         catch (Exception e)</span><br><span class="line">                         {</span><br><span class="line">                             exceptions.Enqueue(e);</span><br><span class="line">                         }</span><br><span class="line">                     });</span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    // Throw the exceptions here after the loop completes.</span><br><span class="line">    if (exceptions.Count &gt; 0) throw new AggregateException(exceptions);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-任务并行"><a href="#2-任务并行" class="headerlink" title=".2. 任务并行"></a>.2. 任务并行</h4><blockquote>
<p>任务并行库 (TPL) 以“任务”的概念为基础，后者表示异步操作。 在某些方面，任务类似于线程或 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool" target="_blank" rel="noopener">ThreadPool</a> 工作项，但是抽象级别更高。 术语“任务并行”是指一个或多个独立的任务同时运行。</p>
</blockquote>
<h5 id="1-Invoke-隐式创建"><a href="#1-Invoke-隐式创建" class="headerlink" title=".1. Invoke 隐式创建"></a>.1. Invoke 隐式创建</h5><blockquote>
<p>这个函数的功能和Task有些相似，就是<code>并发执行一系列任务，然后等待所有完成</code>。和Task比起来，省略了Task.WaitAll这一步，自然也缺少了Task的相关管理功能。它有两种形式:</p>
<ul>
<li>Parallel.Invoke( params Action[] actions);</li>
<li>Parallel.Invoke(Action[] actions,TaskManager manager,TaskCreationOptions options);</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">namespace ConsoleApp1</span><br><span class="line">{</span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            var actions = new Action[]</span><br><span class="line">            {</span><br><span class="line">                () =&gt; ActionTest("test 1"),</span><br><span class="line">                () =&gt; ActionTest("test 2"),</span><br><span class="line">                () =&gt; ActionTest("test 3"),</span><br><span class="line">                () =&gt; ActionTest("test 4")</span><br><span class="line">            };</span><br><span class="line"> </span><br><span class="line">            Console.WriteLine("Parallel.Invoke 1 Test");</span><br><span class="line">            Parallel.Invoke(actions);</span><br><span class="line"> </span><br><span class="line">            Console.WriteLine("结束！");</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        static void ActionTest(object value)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine("&gt;&gt;&gt; thread:{0}, value:{1}",</span><br><span class="line">            Thread.CurrentThread.ManagedThreadId, value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-Task-显示创建"><a href="#2-Task-显示创建" class="headerlink" title=".2. Task 显示创建"></a>.2. Task 显示创建</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">class CustomData</span><br><span class="line">{</span><br><span class="line">   public long CreationTime;</span><br><span class="line">   public int Name;</span><br><span class="line">   public int ThreadNum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class Example</span><br><span class="line">{</span><br><span class="line">   public static void Main()</span><br><span class="line">   {</span><br><span class="line">      Task[] taskArray = new Task[10];</span><br><span class="line">      for (int i = 0; i &lt; taskArray.Length; i++) {</span><br><span class="line">         taskArray[i] = Task.Factory.StartNew( (Object obj ) =&gt; {</span><br><span class="line">                                                  CustomData data = obj as CustomData;</span><br><span class="line">                                                  if (data == null)</span><br><span class="line">                                                     return;</span><br><span class="line"></span><br><span class="line">                                                  data.ThreadNum = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">                                               },</span><br><span class="line">                                               new CustomData() {Name = i, CreationTime = DateTime.Now.Ticks} );</span><br><span class="line">      }</span><br><span class="line">      Task.WaitAll(taskArray);</span><br><span class="line">      foreach (var task in taskArray) {</span><br><span class="line">         var data = task.AsyncState as CustomData;</span><br><span class="line">         if (data != null)</span><br><span class="line">            Console.WriteLine("Task #{0} created at {1}, ran on thread #{2}.",</span><br><span class="line">                              data.Name, data.CreationTime, data.ThreadNum);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-任务延续"><a href="#3-任务延续" class="headerlink" title=".3. 任务延续"></a>.3. 任务延续</h5><blockquote>
<p>使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.continuewith" target="_blank" rel="noopener">Task.ContinueWith</a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.continuewith" target="_blank" rel="noopener">Task<tresult>.ContinueWith</tresult></a> 方法，可以<code>指定要在先行任务完成时启动的任务</code>。 延续任务的委托已传递了对先行任务的引用，因此它可以检查先行任务的状态，并通过检索 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result" target="_blank" rel="noopener">Task.Result</a> 属性的值<code>将先行任务的输出用作延续任务的输入</code>。</p>
<p>在下面的示例中，<code>getData</code> 任务通过调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.startnew#system-threading-tasks-taskfactory-startnew-1(system-func((-0)))" target="_blank" rel="noopener">TaskFactory.StartNew(Func)</a> 方法来启动。 当 <code>processData</code> 完成时，<code>getData</code> 任务自动启动，当 <code>displayData</code> 完成时，<code>processData</code> 启动。 <code>getData</code> 产生一个整数数组，通过 <code>processData</code> 任务的 <code>getData</code> 属性，<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result" target="_blank" rel="noopener">Task.Result</a> 任务可访问该数组。 <code>processData</code> 任务处理该数组并返回结果，结果的类型从传递到 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.continuewith#system-threading-tasks-task-1-continuewith-1(system-func((system-threading-tasks-task((-0))-0)))" target="_blank" rel="noopener">Task.ContinueWith(Func,TNewResult&gt;)</a> 方法的 Lambda 表达式的返回类型推断而来。 <code>displayData</code> 完成时，<code>processData</code> 任务自动执行，而 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.tuple-3" target="_blank" rel="noopener">Tuple</a> 任务可通过 <code>processData</code> 任务的 <code>displayData</code> 属性访问由 <code>processData</code> lambda 表达式返回的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result" target="_blank" rel="noopener">Task.Result</a> 对象。 <code>displayData</code> 任务采用 <code>processData</code> 任务的结果，继而得出自己的结果，其类型以相似方式推断而来，且可由程序中的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result" target="_blank" rel="noopener">Result</a> 属性使用。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">public class Example</span><br><span class="line">{</span><br><span class="line">    public static void Main()</span><br><span class="line">    {</span><br><span class="line">        var getData = Task.Factory.StartNew(() =&gt; {</span><br><span class="line">            Random rnd = new Random();</span><br><span class="line">            int[] values = new int[100];</span><br><span class="line">            for (int ctr = 0; ctr &lt;= values.GetUpperBound(0); ctr++)</span><br><span class="line">                values[ctr] = rnd.Next();</span><br><span class="line">            return values;</span><br><span class="line">        } );</span><br><span class="line">        var processData = getData.ContinueWith((x) =&gt; {</span><br><span class="line">            int n = x.Result.Length;</span><br><span class="line">            long sum = 0;</span><br><span class="line">            double mean;</span><br><span class="line"></span><br><span class="line">            for (int ctr = 0; ctr &lt;= x.Result.GetUpperBound(0); ctr++)</span><br><span class="line">                sum += x.Result[ctr];</span><br><span class="line"></span><br><span class="line">            mean = sum / (double) n;</span><br><span class="line">            return Tuple.Create(n, sum, mean);</span><br><span class="line">        } );</span><br><span class="line">        var displayData = processData.ContinueWith((x) =&gt; {</span><br><span class="line">            return String.Format("N={0:N0}, Total = {1:N0}, Mean = {2:N2}",</span><br><span class="line">                                 x.Result.Item1, x.Result.Item2,</span><br><span class="line">                                 x.Result.Item3);</span><br><span class="line">        } );</span><br><span class="line">        Console.WriteLine(displayData.Result);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">// The example displays output similar to the following:</span><br><span class="line">// N=100, Total = 110,081,653,682, Mean = 1,100,816,536.82</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">public class Example</span><br><span class="line">{</span><br><span class="line">    public static void Main()</span><br><span class="line">    {</span><br><span class="line">        var displayData = Task.Factory.StartNew(() =&gt; {</span><br><span class="line">            Random rnd = new Random();</span><br><span class="line">            int[] values = new int[100];</span><br><span class="line">            for (int ctr = 0; ctr &lt;= values.GetUpperBound(0); ctr++)</span><br><span class="line">                values[ctr] = rnd.Next();</span><br><span class="line"></span><br><span class="line">            return values;</span><br><span class="line">        } ).</span><br><span class="line">            ContinueWith((x) =&gt; {</span><br><span class="line">                int n = x.Result.Length;</span><br><span class="line">                long sum = 0;</span><br><span class="line">                double mean;</span><br><span class="line"></span><br><span class="line">                for (int ctr = 0; ctr &lt;= x.Result.GetUpperBound(0); ctr++)</span><br><span class="line">                    sum += x.Result[ctr];</span><br><span class="line"></span><br><span class="line">                mean = sum / (double) n;</span><br><span class="line">                return Tuple.Create(n, sum, mean);</span><br><span class="line">            } ).</span><br><span class="line">            ContinueWith((x) =&gt; {</span><br><span class="line">                return String.Format("N={0:N0}, Total = {1:N0}, Mean = {2:N2}",</span><br><span class="line">                                     x.Result.Item1, x.Result.Item2,</span><br><span class="line">                                     x.Result.Item3);</span><br><span class="line">            } );</span><br><span class="line">        Console.WriteLine(displayData.Result);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">// The example displays output similar to the following:</span><br><span class="line">//    N=100, Total = 110,081,653,682, Mean = 1,100,816,536.82</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-创建分离的子任务"><a href="#4-创建分离的子任务" class="headerlink" title=".4. 创建分离的子任务"></a>.4. 创建分离的子任务</h5><blockquote>
<p>父任务不会等待分离子任务完成。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var outer = Task.Factory.StartNew(() =&gt;</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("Outer task beginning.");</span><br><span class="line">    var child = Task.Factory.StartNew(() =&gt;</span><br><span class="line">    {</span><br><span class="line">        Thread.SpinWait(5000000);</span><br><span class="line">        Console.WriteLine("Detached task completed.");</span><br><span class="line">    });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">outer.Wait();</span><br><span class="line">Console.WriteLine("Outer task completed.");</span><br><span class="line">// The example displays the following output:</span><br><span class="line">//    Outer task beginning.</span><br><span class="line">//    Outer task completed.</span><br><span class="line">//    Detached task completed.</span><br></pre></td></tr></tbody></table></figure>

<h5 id="5-创建子任务"><a href="#5-创建子任务" class="headerlink" title=".5. 创建子任务"></a>.5. 创建子任务</h5><blockquote>
<p>如果任务中运行的用户代码在创建任务时指定了 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#system-threading-tasks-taskcreationoptions-attachedtoparent" target="_blank" rel="noopener">AttachedToParent</a> 选项，新任务就称为父任务的附加子任务。 </p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">public class Example</span><br><span class="line">{</span><br><span class="line">    public static void Main()</span><br><span class="line">    {</span><br><span class="line">        var parent = Task.Factory.StartNew(() =&gt; {</span><br><span class="line">            Console.WriteLine("Parent task beginning.");</span><br><span class="line">            for (int ctr = 0; ctr &lt; 10; ctr++) {</span><br><span class="line">                int taskNo = ctr;</span><br><span class="line">                Task.Factory.StartNew((x) =&gt; {</span><br><span class="line">                    Thread.SpinWait(5000000);</span><br><span class="line">                    Console.WriteLine("Attached child #{0} completed.",</span><br><span class="line">                                      x);</span><br><span class="line">                },taskNo, TaskCreationOptions.AttachedToParent);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        parent.Wait();   // 等待子任务的完成</span><br><span class="line">        Console.WriteLine("Parent task completed.");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>创建多个子任务，并保持关联</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    var parentTask = new Task&lt;int[]&gt;(() =&gt;</span><br><span class="line">                                     {</span><br><span class="line">                                         //开启多个子任务</span><br><span class="line">                                         var results = new int[2];</span><br><span class="line"></span><br><span class="line">                                         //创建子任务,并将子任务的值赋给results变量,并通过TaskCreationOptions.AttachedToParent,将其关联到父任务,如果不指定,该任务将独立于父任务单独执行</span><br><span class="line">                                         //这里有个奇怪的问题,只能使用new Task的方式去创建关联到父任务的子任务,因为Task.Run没有提供这个方法,可以通过扩展方法解决这个问题</span><br><span class="line">                                         new Task(() =&gt; results[0] = ChildThreadOne(), TaskCreationOptions.AttachedToParent).Start();</span><br><span class="line">                                         new Task(() =&gt; results[1] = ChildThreadTwo(), TaskCreationOptions.AttachedToParent).Start();</span><br><span class="line"></span><br><span class="line">                                         return results;</span><br><span class="line">                                     });</span><br><span class="line">    parentTask.Start();</span><br><span class="line">    parentTask.ContinueWith(x =&gt;</span><br><span class="line">                            {</span><br><span class="line">                                Console.WriteLine("当父任务执行完毕时,CLR会唤起一个新线程,将父任务的返回值(子任务的返回值)输出,所以这里不会有任何的线程发生阻塞");</span><br><span class="line">                                foreach (var re in parentTask.Result)</span><br><span class="line">                                {</span><br><span class="line">                                    Console.WriteLine("子任务的返回值分别为:{0}", re);</span><br><span class="line">                                }</span><br><span class="line">                            });</span><br><span class="line">    Console.WriteLine("主线程不会阻塞,它会继续执行");</span><br><span class="line">    Console.ReadKey();//必须加这行代码,因为Task时线程池线程,属于后台线程</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 子任务一</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">static int ChildThreadOne()</span><br><span class="line">{</span><br><span class="line">    Thread.Sleep(2000);//模拟长时间计算操作</span><br><span class="line">    Console.WriteLine("子任务一完成了计算任务,并返回值:{0}", 6);</span><br><span class="line">    return 6;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 子任务一</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">static int ChildThreadTwo()</span><br><span class="line">{</span><br><span class="line">    Thread.Sleep(2000);//模拟长时间计算操作</span><br><span class="line">    Console.WriteLine("子任务二完成了计算任务,并返回值:{0}", 6);</span><br><span class="line">    return 6;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-等待任务的完成"><a href="#6-等待任务的完成" class="headerlink" title=".6.  等待任务的完成"></a>.6.  等待任务的完成</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Task[] tasks = new Task[3]</span><br><span class="line">{</span><br><span class="line">    Task.Factory.StartNew(() =&gt; MethodA()),</span><br><span class="line">    Task.Factory.StartNew(() =&gt; MethodB()),</span><br><span class="line">    Task.Factory.StartNew(() =&gt; MethodC())</span><br><span class="line">};</span><br><span class="line">//Block until all tasks complete.</span><br><span class="line">Task.WaitAll(tasks);</span><br><span class="line">// Continue on this thread...   ?? 这里是指代 主线程不会等待 task线程吗？  是的</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-Rx"><a href="#8-Rx" class="headerlink" title="8. Rx"></a>8. Rx</h3><blockquote>
<p>Rx最显著的特性是使用<code>可观察集合(Observable Collection)</code>来达到集成<code>异步(composing asynchronous)</code>和<code>基于事件(event-based)的编程</code>的效果。Rx有一些几个特性。 <code>类似UI中的触发控件</code></p>
<ul>
<li><code>组合(Composing)</code>: Reactive Extension的首要目标之一就是将多种异步操作组合起来是的代码更加简单。要做到这一点，数据流必须定义清楚，这样代码就很清晰集中，使得异步操作代码异步处理代码不会充斥整个应用程序。</li>
<li><code>异步(Asynchronous)</code>: 虽然Rx不仅仅能处理异步操作，但是使用Rx，大大简化了异步操作的实现，并且代码容易理解进而容易维护。</li>
<li><code>基于事件(Event-based)</code>: Rx简化了传统的异步编程方式</li>
<li><code>可观察集合(Observable collections)</code>: Obervable Collection是Rx的核心，它是一种集合，集合的元素在第一次访问的时候肯能还没有填充。它对与Rx的重要性类始于enumerable集合对LINQ的重要性。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Reactive.Linq;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">namespace RxDemo</span><br><span class="line">{</span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            //使用Range方法返回Observable集合</span><br><span class="line">            IObservable&lt;Int32&gt; input = Observable.Range(1, 15);</span><br><span class="line">            input.Where(i =&gt; i % 2 == 0).Subscribe(x =&gt; Console.Write("{0} ", x));</span><br><span class="line">            Console.WriteLine();</span><br><span class="line"></span><br><span class="line">            //使用Array返回Observabale集合</span><br><span class="line">            var myArray = new[] { 1, 3, 5, 7, 9 };</span><br><span class="line">            IObservable&lt;Int32&gt; varmyObservable = myArray.ToObservable();</span><br><span class="line">            varmyObservable.Subscribe(x =&gt; Console.WriteLine("Integer:{0}", x));</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            //Take操作符，用来指定获取集合中的前几项</span><br><span class="line">            var take = new[] { 1, 2, 3, 4, 5, 4, 3, 2, 1 }.ToObservable();</span><br><span class="line">            take.Take(5).Select(x =&gt; x * 10).Subscribe(x =&gt; Console.WriteLine(x));</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            //Skip操作符表示跳过集合中的n条记录。</span><br><span class="line">            var skip = new[] { 1, 2, 3, 4, 5, 4, 3, 2, 1 }.ToObservable();</span><br><span class="line">            skip.Skip(6).Select(x =&gt; x * 10).Subscribe(x =&gt; Console.WriteLine(x));</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            //Distinct操作符用来去除集合中的非重复数据。</span><br><span class="line">            var distinct = new[] { 1, 2, 3, 4, 5, 4, 3, 2, 1 }.ToObservable();</span><br><span class="line">            distinct.Distinct().Select(x =&gt; x * 10).Subscribe(x =&gt; Console.WriteLine(x));</span><br><span class="line">            //Rx也需要释放资源</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            var ObservableStrings = Observable.Using&lt;char, StreamReader&gt;(</span><br><span class="line">                () =&gt; new StreamReader(new FileStream("randomtext.txt", FileMode.Open)),</span><br><span class="line">                streamReader =&gt; (streamReader.ReadToEnd().Select(str =&gt; str)).ToObservable()</span><br><span class="line">                );</span><br><span class="line">            ObservableStrings.Subscribe(Console.Write);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            //在Rx中Zip是将两个Observable对象合并为一个新的Observable对象。</span><br><span class="line">            var numberCitys = varmyObservable.Zip(input, (range, array) =&gt; range + ":" + array);</span><br><span class="line">            numberCitys.Subscribe(Console.WriteLine);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-并行-顺序执行"><a href="#9-并行-顺序执行" class="headerlink" title="9. 并行/顺序执行"></a>9. 并行/顺序执行</h3><blockquote>
<ul>
<li><strong>串行：</strong>A和B两个任务运行在一个CPU线程上，在A任务执行完之前不可以执行B。即，在整个程序的运行过程中，仅存在一个运行上下文，即一个调用栈一个堆。程序会按顺序执行每个指令。</li>
<li><strong>并发：</strong>并发指<code>多个线程在宏观(相对于较长的时间区间而言)上表现为同时执行</code>，而<code>实际上是轮流穿插着执行</code>，并发的实质是一个物理CPU在若干道程序之间多路复用，其目的是提高有限物理资源的运行效率。 并发与并行串行并不是互斥的概念，如果是在一个CPU线程上启用并发，那么自然就还是串行的，而如果在多个线程上启用并发，那么程序的执行就可以是既并发又并行的。</li>
<li><strong>并行：</strong>并行性指<code>两个或两个以上事件或活动在同一时刻发生</code>。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。比如，A和B两个任务可以同时运行在不同的CPU线程上，效率较高，但受限于CPU线程数，如果任务数量超过了CPU线程数，那么每个线程上的任务仍然是顺序执行的。</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210703190726586.png" alt=""></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Main {</span><br><span class="line">    //判断是否为质数</span><br><span class="line">    private static boolean isPrime(int n) {</span><br><span class="line">        if(n &lt; 2) return false;</span><br><span class="line">        if(n == 2) return true;</span><br><span class="line">        if(n%2==0) return false;</span><br><span class="line">        for(int i = 3; i &lt; n; i += 2)</span><br><span class="line">            if(n%i == 0) return false;</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    //串行计算</span><br><span class="line">private static void serial() {</span><br><span class="line">        long time1 = System.currentTimeMillis(), time2,time3;</span><br><span class="line">        long count = 0;</span><br><span class="line">        for(int i=1;i&lt;=100000;++i){</span><br><span class="line">            if(isPrime(i)) count+=i;</span><br><span class="line">        }</span><br><span class="line">        time2=System.currentTimeMillis();</span><br><span class="line">        System.out.println("1-100000之间质数和为"+count+" 耗时："+(time2- time1) + "毫秒");</span><br><span class="line">        count = 0;</span><br><span class="line">        for(int i=100001;i&lt;=200000;++i){</span><br><span class="line">            if(isPrime(i))</span><br><span class="line">                count+=i;</span><br><span class="line">        }</span><br><span class="line">        time3 = System.currentTimeMillis();</span><br><span class="line">        System.out.println("100001-200000之间质数和为"+count+" 耗时："+(time3 - time2) + "毫秒");</span><br><span class="line">        System.out.println("总耗时："+ (time3 - time1) + "毫秒");</span><br><span class="line">    }</span><br><span class="line">    //主函数</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        serial();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Main{</span><br><span class="line">    private static boolean isPrime(int n) {</span><br><span class="line">        if(n &lt; 2) return false;</span><br><span class="line">        if(n == 2) return true;</span><br><span class="line">        if(n%2==0) return false;</span><br><span class="line">        for(int i = 3; i &lt; n; i += 2)</span><br><span class="line">            if(n%i == 0) return false;</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        serialConcurrency();</span><br><span class="line">    }</span><br><span class="line">    private static void serialConcurrency() {</span><br><span class="line">        long time = System.currentTimeMillis();</span><br><span class="line">        //任务切换标识，1代表A任务，2代表B任务</span><br><span class="line">        int task = 1;</span><br><span class="line">        //计数器</span><br><span class="line">        long count1 = 0, count2 = 0;</span><br><span class="line">        int i=1,j=100001;</span><br><span class="line">        while (true)</span><br><span class="line">        {</span><br><span class="line">            if(task == 1 &amp;&amp; i++&lt;=100000) {</span><br><span class="line">                if(isPrime(i)) count1+=i;</span><br><span class="line">                task = 2;</span><br><span class="line">            }</span><br><span class="line">            else if(task == 2 &amp;&amp; j++&lt;=200000) {</span><br><span class="line">                if(isPrime(j)) count2+=j;</span><br><span class="line">                task = 1;</span><br><span class="line">            }</span><br><span class="line">            else{</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println("1-100000之间质数和为"+count1);</span><br><span class="line">        System.out.println("100001-200000之间质数和为"+count2);</span><br><span class="line">        System.out.println("总耗时："+(System.currentTimeMillis() - time) + "毫秒");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Main {</span><br><span class="line">    public static boolean isPrime(int n) {</span><br><span class="line">        if(n &lt; 2) return false;</span><br><span class="line">        if(n == 2) return true;</span><br><span class="line">        if(n%2==0) return false;</span><br><span class="line">        for(int i = 3; i &lt; n; i += 2)</span><br><span class="line">            if(n%i == 0) return false;</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        long time1 = System.currentTimeMillis(),time2;</span><br><span class="line">        Task task1 = new Task(1,100000);</span><br><span class="line">        Task task2 = new Task(100001,200000);</span><br><span class="line">        Thread thread1 = new Thread(task1);</span><br><span class="line">        Thread thread2 = new Thread(task2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        while (thread1.isAlive() || thread2.isAlive()){</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">        }</span><br><span class="line">        time2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println("总耗时："+(time2 - time1)+"毫秒");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">class Task implements Runnable{</span><br><span class="line">    private int start;</span><br><span class="line">    private int end;</span><br><span class="line">    Task(int start, int end) {</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    }</span><br><span class="line">    public void run() {</span><br><span class="line">        long time = System.currentTimeMillis();</span><br><span class="line">        long count = 0;</span><br><span class="line">        for(int i=start;i&lt;=end;++i){</span><br><span class="line">            if(Main.isPrime(i)) count+=i;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(String.format("%d-%d之间质数和为%d，耗时：%d毫秒",start,end,count,(System.currentTimeMillis()- time)));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-异步IO"><a href="#10-异步IO" class="headerlink" title="10. 异步IO"></a>10. 异步IO</h3><h4 id="1-FileStream"><a href="#1-FileStream" class="headerlink" title=".1. FileStream"></a>.1. FileStream</h4><h4 id="2-Http"><a href="#2-Http" class="headerlink" title=".2. Http"></a>.2. Http</h4><h4 id="3-数据库"><a href="#3-数据库" class="headerlink" title=".3. 数据库"></a>.3. 数据库</h4><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><ul>
<li><a href="https://cloud.tencent.com/developer/article/1793724" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1793724</a></li>
<li><a href="https://www.cnblogs.com/wyt007/p/9486752.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyt007/p/9486752.html</a></li>
<li><a href="https://www.cnblogs.com/jackson0714/p/5125808.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackson0714/p/5125808.html</a></li>
<li><a href="https://www.huaweicloud.com/articles/cfc1249c1ea36c04c429703a9f150d52.html" target="_blank" rel="noopener">https://www.huaweicloud.com/articles/cfc1249c1ea36c04c429703a9f150d52.html</a></li>
<li><a href="https://www.shuzhiduo.com/A/gVdnPZaaJW/" target="_blank" rel="noopener">https://www.shuzhiduo.com/A/gVdnPZaaJW/</a></li>
<li><a href="https://www.jianshu.com/p/deae44fcc6b3" target="_blank" rel="noopener">https://www.jianshu.com/p/deae44fcc6b3</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://liudongdong1.github.io" rel="external nofollow noreferrer">liudongdong1</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://liudongdong1.github.io/2021/04/02/yu-yan-kuang-jia/c/threadrelative/">https://liudongdong1.github.io/2021/04/02/yu-yan-kuang-jia/c/threadrelative/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="https://liudongdong1.github.io" target="_blank">liudongdong1</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/java/">
                                    <span class="chip bg-color">java</span>
                                </a>
                            
                                <a href="/tags/c/">
                                    <span class="chip bg-color">c#</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2021/04/05/writing/relation/">
                    <div class="card-image">
                        
                        <img src="https://cdn.pixabay.com/photo/2015/07/27/20/27/mockup-863469__340.jpg" class="responsive-img" alt="Relation">
                        
                        <span class="card-title">Relation</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1. 明确几种好的心态
无论做研究还是做工程，不要期待导师给你太多的指导，这点全世界都一样，不要抱怨，独立解决问题的能力就是这样锻炼出来的。好的导师能够在大方向上给一些意见，但具体的工作是需要自己去做的。
别人没有义务来帮助你，不管是师兄或
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-04-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%94%9F%E6%B4%BB/" class="post-category">
                                    生活
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/skill/">
                        <span class="chip bg-color">skill</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/03/31/web/websiterecord/">
                    <div class="card-image">
                        
                        <img src="https://gitee.com/github-25970295/blogImage/raw/master/img/20210501112815.png" class="responsive-img" alt="WebSiteRecord">
                        
                        <span class="card-title">WebSiteRecord</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1. 公司介绍网页

https://e.huawei.com/cn/solutions/industries/transportation


        document.querySelectorAll('.github-emoj
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-03-31
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AF%AD%E8%A8%80%E6%A1%86%E6%9E%B6/" class="post-category">
                                    语言框架
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/pytorch/">
                        <span class="chip bg-color">pytorch</span>
                    </a>
                    
                    <a href="/tags/AI/">
                        <span class="chip bg-color">AI</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <!-- <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="463294659"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://liudongdong1.github.io" target="_blank">liudongdong</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">1206.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/liudongdong1/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:3463264078@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>














    <a href="https://blog.csdn.net/liudongdong19/" class="tooltipped" target="_blank" data-tooltip="关注我的CSDN: https://blog.csdn.net/liudongdong19/" data-position="top" data-delay="50">
        <i class="fab fa-csdn">C</i>
    </a>





</div>
    </div>
</footer>

<div class="progress-bar"></div>
 -->

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script type="text/javascript" src="/js/CFS.Snow.min.js"></script>
    <!-- 点击爆灯效果 -->
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <!--动态线条背景-->
    <script type="text/javascript"
        color="122 103 238" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
    </script>
    <!-- 天气 -->
    <!-- weather -->
    <!-- weather -->
    <script type="text/javascript">
         WIDGET = {FID: 'knAMQaFanP'}
    </script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>
    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
    <!-- {% include '_custom/custom.swig' %} -->

</body>

</html>
