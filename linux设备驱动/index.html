<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Linux Operation - DAY By DAY</title><meta name="author" content="LiuDongdong">
<meta name="author-link" content="https://liudongdong1.github.io/">
<meta name="description" content="1. 内核划分 .1. 字符设备 文本控制台( /dev/console )和串口( /dev/ttyS0 及其友 )是字符设备的例子 .2.块设备 .3. 网络接口： 内核与网络设备驱动间的通讯与字符和块设备驱动所" /><meta name="keywords" content='Linux, Embed' /><meta itemprop="name" content="Linux Operation">
<meta itemprop="description" content="1. 内核划分 .1. 字符设备 文本控制台( /dev/console )和串口( /dev/ttyS0 及其友 )是字符设备的例子 .2.块设备 .3. 网络接口： 内核与网络设备驱动间的通讯与字符和块设备驱动所"><meta itemprop="datePublished" content="2022-03-16T22:21:29+00:00" />
<meta itemprop="dateModified" content="2023-09-28T23:04:34+08:00" />
<meta itemprop="wordCount" content="10770"><meta itemprop="image" content="https://liudongdong1.github.io/logo.png"/>
<meta itemprop="keywords" content="Linux,Embed," /><meta property="og:title" content="Linux Operation" />
<meta property="og:description" content="1. 内核划分 .1. 字符设备 文本控制台( /dev/console )和串口( /dev/ttyS0 及其友 )是字符设备的例子 .2.块设备 .3. 网络接口： 内核与网络设备驱动间的通讯与字符和块设备驱动所" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liudongdong1.github.io/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" /><meta property="og:image" content="https://liudongdong1.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-16T22:21:29+00:00" />
<meta property="article:modified_time" content="2023-09-28T23:04:34+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://liudongdong1.github.io/logo.png"/>

<meta name="twitter:title" content="Linux Operation"/>
<meta name="twitter:description" content="1. 内核划分 .1. 字符设备 文本控制台( /dev/console )和串口( /dev/ttyS0 及其友 )是字符设备的例子 .2.块设备 .3. 网络接口： 内核与网络设备驱动间的通讯与字符和块设备驱动所"/>
<meta name="application-name" content="DAY By DAY">
<meta name="apple-mobile-web-app-title" content="DAY By DAY"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://liudongdong1.github.io/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" /><link rel="prev" href="https://liudongdong1.github.io/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%8C%91%E6%88%98/" /><link rel="next" href="https://liudongdong1.github.io/makefile/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Linux Operation",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/liudongdong1.github.io\/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8\/"
    },"genre": "posts","keywords": "Linux, Embed","wordcount":  10770 ,
    "url": "https:\/\/liudongdong1.github.io\/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8\/","datePublished": "2022-03-16T22:21:29+00:00","dateModified": "2023-09-28T23:04:34+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
      "@type": "Organization",
      "name": "LiuDongdong","logo": "https:\/\/liudongdong1.github.io\/images\/person.png"},"author": {
        "@type": "Person",
        "name": "liudongdong1"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="auto" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper"><script type="text/javascript"
        async
        src="https://cdnjs.cloudflare.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
<header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper" data-github-corner="right">
    <div class="header-title">
      <a href="/" title="DAY By DAY"><img
    class="lazyload logo"
    src="/svg/loading.min.svg"
    data-src="/fixit.min.svg"
    data-srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x"
    data-sizes="auto"
    alt="DAY By DAY"
    title="DAY By DAY"/><span class="header-title-text"></span></a><span id="typeit-header-subtitle-desktop" class="typeit header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 所有文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/friends/"
                title="友情链接"
                
              ><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden="true"></i> 友链</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/about/"
                
                
              ><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden="true"></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item language">
            <span role="button" aria-label="选择语言" title="选择语言">简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden="true"></i>
            </span>
            <ul class="sub-menu"><li class="menu-item">没有更多翻译</li></ul>
          </li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容 ..." id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li>
      </ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="DAY By DAY"><img
    class="lazyload logo"
    src="/svg/loading.min.svg"
    data-src="/fixit.min.svg"
    data-srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x"
    data-sizes="auto"
    alt="/fixit.min.svg"
    title="/fixit.min.svg"/><span class="header-title-text"></span></a><span id="typeit-header-subtitle-mobile" class="typeit header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容 ..." id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 所有文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/friends/"
                  title="友情链接"
                  
                ><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden="true"></i> 友链</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/about/"
                  
                  
                ><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden="true"></i> 关于</a></li><li
              class="menu-item text-center"
            ><a
                  class="menu-link"
                  href="/"
                  title="GitHub"
                  
                ><i class='fa-brands fa-github fa-fw' aria-hidden='true'></i> </a></li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li><li class="menu-item language">
            <span role="button" aria-label="选择语言" title="选择语言">简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden="true"></i>
            </span>
            <select class="language-select" onchange="location = this.value;"><option disabled>没有更多翻译</option></select>
          </li></ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container" data-page-style="normal"><aside class="toc" id="toc-auto"><h2 class="toc-title">目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom" id="aside-sakana">
    

<div class="sakana-widget">
  <div class="sakana-item" id="takina-widget"></div>
  <div class="sakana-item" id="chisato-widget"></div>
</div>
<script>
  function initSakanaWidget() {
    const takina = SakanaWidget.getCharacter('takina')
    SakanaWidget.registerCharacter('takina-slow', takina);
    new SakanaWidget({
      character: 'takina-slow',
      controls: false,
      autoFit: true,
      stroke: {
        color: "#b4b4b4",
        width: 2
      }
    }).mount('#takina-widget');

    const chisato = SakanaWidget.getCharacter('chisato')
    SakanaWidget.registerCharacter('chisato-slow', chisato);
    new SakanaWidget({
      character: 'chisato-slow',
      controls: false,
      autoFit: true,
      stroke: {
        color: "#b4b4b4",
        width: 2
      }
    }).mount('#chisato-widget');
  }
</script>
<script async onload="initSakanaWidget()" src="https://cdn.jsdelivr.net/npm/sakana-widget@2.3.0/lib/sakana.min.js">
</script></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX">
        <span>Linux Operation</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><i class="fa-solid fa-user-circle" aria-hidden="true"></i>
      liudongdong1</span></span>
          <span class="post-category">收录于 <a href="/categories/linux/"><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Linux</a></span></div>
      <div class="post-meta-line"><span title=2022-03-16&#32;22:21:29>
            <i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-03-16" >2022-03-16</time>
          </span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 10770 字&nbsp;
        <i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 22 分钟&nbsp;<span id="busuanzi_container_page_pv" class="busuanzi_visitors comment-visitors" data-flag-title="Linux Operation">
            <i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv">-</span>&nbsp;次阅读
          </span>&nbsp;</div>
    </div><div class="featured-image"><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://gitee.com/github-25970295/blogImage/raw/master/img/petal-5044428.png"
    data-srcset="https://gitee.com/github-25970295/blogImage/raw/master/img/petal-5044428.png, https://gitee.com/github-25970295/blogImage/raw/master/img/petal-5044428.png 1.5x, https://gitee.com/github-25970295/blogImage/raw/master/img/petal-5044428.png 2x"
    data-sizes="auto"
    alt="https://gitee.com/github-25970295/blogImage/raw/master/img/petal-5044428.png"
    title="https://gitee.com/github-25970295/blogImage/raw/master/img/petal-5044428.png"/></div><div class="details toc" id="toc-static" kept="true">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-内核划分">1. 内核划分</a></li>
        <li><a href="#2-字符设备">2. 字符设备</a></li>
        <li><a href="#3-字符设备驱动">3. 字符设备驱动</a></li>
        <li><a href="#4-打印调试">4. 打印调试</a></li>
        <li><a href="#5-并发和竞争情况">5. 并发和竞争情况</a></li>
        <li><a href="#6-时间延迟延后工作">6. 时间&amp;延迟&amp;延后工作</a></li>
        <li><a href="#7-分配内存">7. 分配内存</a></li>
        <li><a href="#8-与硬件设备通讯">8. 与硬件设备通讯</a></li>
        <li><a href="#9-中断处理">9. 中断处理</a></li>
        <li><a href="#10-标准c类型使用移植问题">10. 标准C类型使用&amp;移植问题</a></li>
        <li><a href="#11-pci-驱动-todo">11. PCI 驱动 todo</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div
      class="content"
      id="content"
      
      
    ><h3 id="1-内核划分">1. 内核划分</h3>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108144636379.png"
    data-srcset="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108144636379.png, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108144636379.png 1.5x, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108144636379.png 2x"
    data-sizes="auto"
    alt="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108144636379.png"
    title="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108144636379.png"/></p>
<p>.1. 字符设备</p>
<ul>
<li>文本控制台( /dev/console )和串口( /dev/ttyS0 及其友 )是字符设备的例子</li>
</ul>
<p>.2.块设备</p>
<p>.3. 网络接口： 内核与网络设备驱动间的通讯与字符和块设备驱动所用的完全不同. 不用 read 和 write, 内核调用和报文传递相关的函数.</p>
<h4 id="连接一个模块到内核">连接一个模块到内核</h4>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108151129740.png"
    data-srcset="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108151129740.png, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108151129740.png 1.5x, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108151129740.png 2x"
    data-sizes="auto"
    alt="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108151129740.png"
    title="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108151129740.png"/></p>
<ul>
<li>应用程序存在于虚拟内存中, 有一个非常大的堆栈区，堆栈。</li>
<li>内核, 相反, 有一个非常小的堆栈; 它可能小到一个, 4096 字节的页.</li>
</ul>
<h4 id="堆叠模块">堆叠模块</h4>
<ul>
<li>modprobe工具使用</li>
</ul>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108154002563.png"
    data-srcset="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108154002563.png, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108154002563.png 1.5x, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221108154002563.png 2x"
    data-sizes="auto"
    alt="image-20221108154002563"
    title="image-20221108154002563"/></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>moudle.h <span style="color:#960050;background-color:#1e0010">包含了大量加载模块需要的函数和符号的定义</span>
</span></span><span style="display:flex;"><span>init.h <span style="color:#960050;background-color:#1e0010">来指定你的初始化和清理函数</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> __init <span style="color:#a6e22e">initialization_function</span>(<span style="color:#66d9ef">void</span>) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/* Initialization code here */</span> 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_init</span>(initialization_function);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 给定的函数只是在初始化使用. 模块加载者在模块加载后会丢掉这个初始化函数, 使它的内存可做其他用途.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//moudle_init 是强制的. 这个宏定义增加了特别的段到模块目标代码中, 表明在哪里找到模块的初始化函数.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> __exit <span style="color:#a6e22e">cleanup_function</span>(<span style="color:#66d9ef">void</span>) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/* Cleanup code here */</span> 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_exit</span>(cleanup_function);
</span></span></code></pre></div><h4 id="内核初始化错误处理">内核初始化错误处理</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> __init <span style="color:#a6e22e">my_init_function</span>(<span style="color:#66d9ef">void</span>) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> err; 
</span></span><span style="display:flex;"><span>    err <span style="color:#f92672">=</span> <span style="color:#a6e22e">register_this</span>(ptr1, <span style="color:#e6db74">&#34;skull&#34;</span>); <span style="color:#75715e">/* registration takes a pointer and a name */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (err) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> fail_this; 
</span></span><span style="display:flex;"><span>    err <span style="color:#f92672">=</span> <span style="color:#a6e22e">register_that</span>(ptr2, <span style="color:#e6db74">&#34;skull&#34;</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (err) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> fail_that; 
</span></span><span style="display:flex;"><span>    err <span style="color:#f92672">=</span> <span style="color:#a6e22e">register_those</span>(ptr3, <span style="color:#e6db74">&#34;skull&#34;</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (err) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> fail_those; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">/* success */</span> 
</span></span><span style="display:flex;"><span>    fail_those: 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unregister_that</span>(ptr2, <span style="color:#e6db74">&#34;skull&#34;</span>); 
</span></span><span style="display:flex;"><span>    fail_that: 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unregister_this</span>(ptr1, <span style="color:#e6db74">&#34;skull&#34;</span>); 
</span></span><span style="display:flex;"><span>    fail_this: 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> err; <span style="color:#75715e">/* propagate the error */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> __exit <span style="color:#a6e22e">my_cleanup_function</span>(<span style="color:#66d9ef">void</span>) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unregister_those</span>(ptr3, <span style="color:#e6db74">&#34;skull&#34;</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unregister_that</span>(ptr2, <span style="color:#e6db74">&#34;skull&#34;</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unregister_this</span>(ptr1, <span style="color:#e6db74">&#34;skull&#34;</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> something <span style="color:#f92672">*</span>item1; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> somethingelse <span style="color:#f92672">*</span>item2; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> stuff_ok; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">my_cleanup</span>(<span style="color:#66d9ef">void</span>) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (item1) 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">release_thing</span>(item1); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (item2) 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">release_thing2</span>(item2); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (stuff_ok) 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">unregister_stuff</span>(); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>; 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> __init <span style="color:#a6e22e">my_init</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ENOMEM; 
</span></span><span style="display:flex;"><span>    item1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">allocate_thing</span>(arguments); 
</span></span><span style="display:flex;"><span>    item2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">allocate_thing2</span>(arguments2); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>item2 <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>item2) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> fail; 
</span></span><span style="display:flex;"><span>    err <span style="color:#f92672">=</span> <span style="color:#a6e22e">register_stuff</span>(item1, item2); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>err) 
</span></span><span style="display:flex;"><span>        stuff_ok <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> fail; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">/* success */</span> 
</span></span><span style="display:flex;"><span>    fail: 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">my_cleanup</span>(); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> err; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="模块加载竞争参数">模块加载竞争&amp;参数</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>whom <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;world&#34;</span>; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> howmany <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_param</span>(howmany, <span style="color:#66d9ef">int</span>, S_IRUGO); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_param</span>(whom, charp, S_IRUGO);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_param_array</span>(name,type,num,perm);
</span></span></code></pre></div><h3 id="2-字符设备">2. 字符设备</h3>
<h4 id="分配释放设备号">分配释放设备号</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">register_chrdev_region</span>(<span style="color:#66d9ef">dev_t</span> first, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//first 是你要分配的起始设备编号. first 的次编号部分常常是 0, name 是应当连接到这个编号范围的设备的名子; 它会出现在 /proc/devices 和 sysfs 中.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//动态分配编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">alloc_chrdev_region</span>(<span style="color:#66d9ef">dev_t</span> <span style="color:#f92672">*</span>dev, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> firstminor, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count, 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// dev 是一个只输出的参数, 它在函数成功完成时持有你的分配范围的第一个数. fisetminor 应当是请求的第一个要用的次编号; 它常常是 0. count 和 name 参数如同给 request_chrdev_region 的一样.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unregister_chrdev_region</span>(<span style="color:#66d9ef">dev_t</span> first, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count);
</span></span></code></pre></div><blockquote>
<p>file_operations 结构持有一个字符驱动的方法; struct file 代表一个打开的文件, struct inode 代表磁盘上的一个文件.</p>
</blockquote>
<h4 id="文件操作">文件操作</h4>
<ul>
<li>file_operation 结构是一个字符驱动如何建立这个连接</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> file_operations scull_fops <span style="color:#f92672">=</span> { 
</span></span><span style="display:flex;"><span> .owner <span style="color:#f92672">=</span> THIS_MODULE, 
</span></span><span style="display:flex;"><span> .llseek <span style="color:#f92672">=</span> scull_llseek, 
</span></span><span style="display:flex;"><span> .read <span style="color:#f92672">=</span> scull_read, 
</span></span><span style="display:flex;"><span> .write <span style="color:#f92672">=</span> scull_write, 
</span></span><span style="display:flex;"><span> .ioctl <span style="color:#f92672">=</span> scull_ioctl, 
</span></span><span style="display:flex;"><span> .open <span style="color:#f92672">=</span> scull_open, 
</span></span><span style="display:flex;"><span> .release <span style="color:#f92672">=</span> scull_release, 
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">module</span> <span style="color:#f92672">*</span>owner; <span style="color:#75715e">//它是一个指向拥有这个结构的模块的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>loff_t (<span style="color:#f92672">*</span>llseek) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, loff_t, <span style="color:#66d9ef">int</span>); <span style="color:#75715e">//用作改变文件中的当前读/写位置, 并且新位置作为(正的)返回值.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ssize_t (<span style="color:#f92672">*</span>read) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>, size_t, loff_t <span style="color:#f92672">*</span>); <span style="color:#75715e">//用来从设备中获取数据, 一个非负返回值代表了成功读取的字节数( 返回值是一个 &#34;signed size&#34; 类型, 常常是目标平台本地的整数类型).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ssize_t (<span style="color:#f92672">*</span>aio_read)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">kiocb</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>, size_t, loff_t); <span style="color:#75715e">//初始化一个异步读 -- 可能在函数返回前不结束的读操作.     
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ssize_t (<span style="color:#f92672">*</span>write) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>, size_t, loff_t <span style="color:#f92672">*</span>); <span style="color:#75715e">//发送数据给设备. 如果 NULL, -EINVAL 返回给调用 write 系统调用的程序. 如果非负, 返回值代表成功写的字节数.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ssize_t (<span style="color:#f92672">*</span>aio_write)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">kiocb</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>, size_t, loff_t <span style="color:#f92672">*</span>); <span style="color:#75715e">//初始化设备上的一个异步写.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>readdir) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, filldir_t);<span style="color:#75715e">//来读取目录, 并且仅对文件系统有用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>poll) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">poll_table_struct</span> <span style="color:#f92672">*</span>); <span style="color:#75715e">//poll 方法是 3 个系统调用的后端: poll, epoll, 和 select, 都用作查询对一个或多个文件描述符的读或写是否会阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>ioctl) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">inode</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>); <span style="color:#75715e">// 系统调用提供了发出设备特定命令的方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>mmap) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">vm_area_struct</span> <span style="color:#f92672">*</span>); <span style="color:#75715e">//用来请求将设备内存映射到进程的地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>open) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">inode</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>); <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>flush) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>); <span style="color:#75715e">//在进程关闭它的设备文件描述符的拷贝时调用; 它应当执行(并且等待)设备的任何未完成的操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>release) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">inode</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>);  <span style="color:#75715e">//在文件结构被释放时引用这个操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>fsync) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dentry</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>); <span style="color:#75715e">//用户调用来刷新任何挂着的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>aio_fsync)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">kiocb</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>fasync) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>); <span style="color:#75715e">//通知设备它的 FASYNC 标志的改变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>lock) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file_lock</span> <span style="color:#f92672">*</span>); <span style="color:#75715e">//实现文件加锁;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ssize_t (<span style="color:#f92672">*</span>readv) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">iovec</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>, loff_t <span style="color:#f92672">*</span>); 
</span></span><span style="display:flex;"><span>ssize_t (<span style="color:#f92672">*</span>writev) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">iovec</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>, loff_t <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>ssize_t (<span style="color:#f92672">*</span>sendfile)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, loff_t <span style="color:#f92672">*</span>, size_t, read_actor_t, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>); <span style="color:#75715e">//最少的拷贝从一个文件描述符搬移数据到另一个. 例如, 它被一个需要发送文件内容到一个网络连接的 web 服务器使用.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ssize_t (<span style="color:#f92672">*</span>sendpage) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">page</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>, size_t, loff_t <span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>); <span style="color:#75715e">//它由内核调用来发送数据, 一次一页, 到对应的文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">long</span> (<span style="color:#f92672">*</span>get_unmapped_area)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>, <span style="color:#66d9ef">unsigned</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>);  <span style="color:#75715e">//是在进程的地址空间找一个合适的位置来映射在底层设备上的内存段中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>check_flags)(<span style="color:#66d9ef">int</span>); <span style="color:#75715e">//允许模块检查传递给 fnctl(F_SETFL...) 调用的标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>dir_notify)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>);   <span style="color:#75715e">//在应用程序使用 fcntl 来请求目录改变通知时调用
</span></span></span></code></pre></div><h4 id="文件结构">文件结构</h4>
<p>文件结构代表一个打开的文件. (它不特定给设备驱动; 系统中每个打开的文件有一个关联的 struct file 在内核空间). 它由内核在 open 时创建, 并传递给在文件上操作的任何函数, 直到最后的关闭. 在文件的所有实例都关闭后, 内核释放这个数据结构。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>mode_t f_mode; <span style="color:#75715e">//文件模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>loff_t f_pos;  <span style="color:#75715e">//当前读写位置.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> f_flags;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file_operations</span> <span style="color:#f92672">*</span>f_op;  <span style="color:#75715e">//和文件关联的操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>private_data;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dentry</span> <span style="color:#f92672">*</span>f_dentry;  <span style="color:#75715e">//关联到文件的目录入口( dentry )结构, filp-&gt;f_dentry-&gt;d_inode 存取 inode 结构
</span></span></span></code></pre></div><h4 id="inode-结构">inode 结构</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>dev_t i_rdev;  <span style="color:#75715e">//代表设备文件的节点, 这个成员包含实际的设备编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cdev</span> <span style="color:#f92672">*</span>i_cdev;  <span style="color:#75715e">//是内核的内部结构, 代表字符设备; 这个成员包含一个指针, 指向这个结构, 当节点指的是一个字符设备文件时.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//可用来从一个 inode 中获取主次编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">iminor</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">inode</span> <span style="color:#f92672">*</span>inode); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">imajor</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">inode</span> <span style="color:#f92672">*</span>inode);
</span></span></code></pre></div><h4 id="字符设备注册">字符设备注册</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cdev_init</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cdev</span> <span style="color:#f92672">*</span>cdev, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file_operations</span> <span style="color:#f92672">*</span>fops);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cdev_add</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cdev</span> <span style="color:#f92672">*</span>dev, dev_t num, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cdev_del</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cdev</span> <span style="color:#f92672">*</span>dev);
</span></span></code></pre></div><h5 id="scull-设备注册">scull 设备注册</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">scull_dev</span> { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">scull_qset</span> <span style="color:#f92672">*</span>data; <span style="color:#75715e">/* Pointer to first quantum set */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> quantum; <span style="color:#75715e">/* the current quantum size */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> qset; <span style="color:#75715e">/* the current array size */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size; <span style="color:#75715e">/* amount of data stored here */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> access_key; <span style="color:#75715e">/* used by sculluid and scullpriv */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">semaphore</span> sem; <span style="color:#75715e">/* mutual exclusion semaphore */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cdev</span> cdev; <span style="color:#75715e">/* Char device structure */</span> 
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">scull_setup_cdev</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">scull_dev</span> <span style="color:#f92672">*</span>dev, <span style="color:#66d9ef">int</span> index) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> err, devno <span style="color:#f92672">=</span> MKDEV(scull_major, scull_minor <span style="color:#f92672">+</span> index); 
</span></span><span style="display:flex;"><span>    cdev_init(<span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>cdev, <span style="color:#f92672">&amp;</span>scull_fops); 
</span></span><span style="display:flex;"><span>    dev<span style="color:#f92672">-&gt;</span>cdev.owner <span style="color:#f92672">=</span> THIS_MODULE; 
</span></span><span style="display:flex;"><span>    dev<span style="color:#f92672">-&gt;</span>cdev.ops <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>scull_fops; 
</span></span><span style="display:flex;"><span>    err <span style="color:#f92672">=</span> cdev_add (<span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>cdev, devno, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Fail gracefully if need be */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (err) 
</span></span><span style="display:flex;"><span>        printk(KERN_NOTICE <span style="color:#e6db74">&#34;Error %d adding scull%d&#34;</span>, err, index); 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="open函数">Open函数</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>container_of(pointer, container_type, container_field); <span style="color:#75715e">//这个宏使用一个指向 container_field 类型的成员的指针, 它在一个 container_type 类型的结构中, 并且返回一个指针指向包含结构.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">scull_open</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">inode</span> <span style="color:#f92672">*</span>inode, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>filp) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">scull_dev</span> <span style="color:#f92672">*</span>dev; <span style="color:#75715e">/* device information */</span> 
</span></span><span style="display:flex;"><span>    dev <span style="color:#f92672">=</span> container_of(inode<span style="color:#f92672">-&gt;</span>i_cdev, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">scull_dev</span>, cdev); 
</span></span><span style="display:flex;"><span>    filp<span style="color:#f92672">-&gt;</span>private_data <span style="color:#f92672">=</span> dev; <span style="color:#75715e">/* for other methods */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* now trim to 0 the length of the device if open was write-only */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( (filp<span style="color:#f92672">-&gt;</span>f_flags <span style="color:#f92672">&amp;</span> O_ACCMODE) <span style="color:#f92672">==</span> O_WRONLY) 
</span></span><span style="display:flex;"><span>    { 
</span></span><span style="display:flex;"><span>        scull_trim(dev); <span style="color:#75715e">/* ignore errors */</span> 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">/* success */</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="release-函数">release 函数</h5>
<ul>
<li>释放 open 分配在 filp-&gt;private_data 中的任何东西</li>
<li>在最后的 close 关闭设备</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">scull_release</span>(<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>inode, <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//fork 和 dup 都不创建新文件(只有 open 这样); 它们只递增正存在的结构中的计数. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//close 系统调用仅在文件结构计数掉到 0 时执行 release 方法
</span></span></span></code></pre></div><h5 id="scull-内存布局">scull 内存布局</h5>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109115252792.png"
    data-srcset="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109115252792.png, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109115252792.png 1.5x, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109115252792.png 2x"
    data-sizes="auto"
    alt="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109115252792.png"
    title="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109115252792.png"/></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> scull_qset { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>data; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> scull_qset <span style="color:#f92672">*</span>next; 
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">scull_trim</span>(<span style="color:#66d9ef">struct</span> scull_dev <span style="color:#f92672">*</span>dev) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> scull_qset <span style="color:#f92672">*</span>next, <span style="color:#f92672">*</span>dptr; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> qset <span style="color:#f92672">=</span> dev<span style="color:#f92672">-&gt;</span>qset; <span style="color:#75715e">/* &#34;dev&#34; is not-null */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (dptr <span style="color:#f92672">=</span> dev<span style="color:#f92672">-&gt;</span>data; dptr; dptr <span style="color:#f92672">=</span> next) 
</span></span><span style="display:flex;"><span>    { <span style="color:#75715e">/* all the list items */</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (dptr<span style="color:#f92672">-&gt;</span>data) { 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> qset; i<span style="color:#f92672">++</span>) 
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">kfree</span>(dptr<span style="color:#f92672">-&gt;</span>data[i]); 
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">kfree</span>(dptr<span style="color:#f92672">-&gt;</span>data); 
</span></span><span style="display:flex;"><span>            dptr<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> NULL; 
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        next <span style="color:#f92672">=</span> dptr<span style="color:#f92672">-&gt;</span>next; 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">kfree</span>(dptr); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dev<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>    dev<span style="color:#f92672">-&gt;</span>quantum <span style="color:#f92672">=</span> scull_quantum; 
</span></span><span style="display:flex;"><span>    dev<span style="color:#f92672">-&gt;</span>qset <span style="color:#f92672">=</span> scull_qset; 
</span></span><span style="display:flex;"><span>    dev<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> NULL; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="读写readwrite">读写read&amp;write</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>ssize_t <span style="color:#a6e22e">read</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buff, size_t count, loff_t <span style="color:#f92672">*</span>offp); 
</span></span><span style="display:flex;"><span>ssize_t <span style="color:#a6e22e">write</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buff, size_t count, loff_t <span style="color:#f92672">*</span>offp);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 用户和内核空间数据拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">copy_from_user</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">copy_to_user</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count);
</span></span></code></pre></div><p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109120002014.png"
    data-srcset="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109120002014.png, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109120002014.png 1.5x, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109120002014.png 2x"
    data-sizes="auto"
    alt="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109120002014.png"
    title="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221109120002014.png"/></p>
<ul>
<li>todo ？ 这里read代码没有完全看明白， quantum这个有什么作用</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">scull_read</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> count, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>f_pos)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> scull_dev <span style="color:#f92672">*</span>dev <span style="color:#f92672">=</span> filp<span style="color:#f92672">-&gt;</span>private_data; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> scull_qset <span style="color:#f92672">*</span>dptr; <span style="color:#75715e">/* the first listitem */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> quantum <span style="color:#f92672">=</span> dev<span style="color:#f92672">-&gt;</span>quantum, qset <span style="color:#f92672">=</span> dev<span style="color:#f92672">-&gt;</span>qset; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> itemsize <span style="color:#f92672">=</span> quantum <span style="color:#f92672">*</span> qset; <span style="color:#75715e">/* how many bytes in the listitem */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> item, s_pos, q_pos, rest; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ssize_t</span> retval <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">down_interruptible</span>(<span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>sem))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ERESTARTSYS; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>f_pos <span style="color:#f92672">&gt;=</span> dev<span style="color:#f92672">-&gt;</span>size) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> out; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>f_pos <span style="color:#f92672">+</span> count <span style="color:#f92672">&gt;</span> dev<span style="color:#f92672">-&gt;</span>size) 
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">=</span> dev<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">-</span> <span style="color:#f92672">*</span>f_pos; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* find listitem, qset index, and offset in the quantum */</span> 
</span></span><span style="display:flex;"><span>    item <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)<span style="color:#f92672">*</span>f_pos <span style="color:#f92672">/</span> itemsize; 
</span></span><span style="display:flex;"><span>    rest <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)<span style="color:#f92672">*</span>f_pos <span style="color:#f92672">%</span> itemsize; 
</span></span><span style="display:flex;"><span>    s_pos <span style="color:#f92672">=</span> rest <span style="color:#f92672">/</span> quantum; 
</span></span><span style="display:flex;"><span>    q_pos <span style="color:#f92672">=</span> rest <span style="color:#f92672">%</span> quantum; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* follow the list up to the right position (defined elsewhere) */</span> 
</span></span><span style="display:flex;"><span>    dptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">scull_follow</span>(dev, item); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dptr <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">||</span> <span style="color:#f92672">!</span> dptr<span style="color:#f92672">-&gt;</span>data[s_pos])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> out; <span style="color:#75715e">/* don&#39;t fill holes */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* read only up to the end of this quantum */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">&gt;</span> quantum <span style="color:#f92672">-</span> q_pos) 
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">=</span> quantum <span style="color:#f92672">-</span> q_pos; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">copy_to_user</span>(buf, dptr<span style="color:#f92672">-&gt;</span>data[s_pos] <span style="color:#f92672">+</span> q_pos, count)) 
</span></span><span style="display:flex;"><span>    { 
</span></span><span style="display:flex;"><span>        retval <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EFAULT; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> out; 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>f_pos <span style="color:#f92672">+=</span> count; 
</span></span><span style="display:flex;"><span>    retval <span style="color:#f92672">=</span> count; 
</span></span><span style="display:flex;"><span>    out: 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">up</span>(<span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>sem); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> retval; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">scull_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> count, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>f_pos) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> scull_dev <span style="color:#f92672">*</span>dev <span style="color:#f92672">=</span> filp<span style="color:#f92672">-&gt;</span>private_data; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> scull_qset <span style="color:#f92672">*</span>dptr; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> quantum <span style="color:#f92672">=</span> dev<span style="color:#f92672">-&gt;</span>quantum, qset <span style="color:#f92672">=</span> dev<span style="color:#f92672">-&gt;</span>qset; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> itemsize <span style="color:#f92672">=</span> quantum <span style="color:#f92672">*</span> qset; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> item, s_pos, q_pos, rest; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ssize_t</span> retval <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ENOMEM; <span style="color:#75715e">/* value used in &#34;goto out&#34; statements */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">down_interruptible</span>(<span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>sem)) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ERESTARTSYS; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* find listitem, qset index and offset in the quantum */</span> 
</span></span><span style="display:flex;"><span>    item <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)<span style="color:#f92672">*</span>f_pos <span style="color:#f92672">/</span> itemsize; 
</span></span><span style="display:flex;"><span>    rest <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)<span style="color:#f92672">*</span>f_pos <span style="color:#f92672">%</span> itemsize; 
</span></span><span style="display:flex;"><span>    s_pos <span style="color:#f92672">=</span> rest <span style="color:#f92672">/</span> quantum; 
</span></span><span style="display:flex;"><span>    q_pos <span style="color:#f92672">=</span> rest <span style="color:#f92672">%</span> quantum; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* follow the list up to the right position */</span> 
</span></span><span style="display:flex;"><span>    dptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">scull_follow</span>(dev, item); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dptr <span style="color:#f92672">==</span> NULL) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> out; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data) 
</span></span><span style="display:flex;"><span>    { 
</span></span><span style="display:flex;"><span>        dptr<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmalloc</span>(qset <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>), GFP_KERNEL); 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data) 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> out; 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memset</span>(dptr<span style="color:#f92672">-&gt;</span>data, <span style="color:#ae81ff">0</span>, qset <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)); 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data[s_pos]) 
</span></span><span style="display:flex;"><span>    { 
</span></span><span style="display:flex;"><span>        dptr<span style="color:#f92672">-&gt;</span>data[s_pos] <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmalloc</span>(quantum, GFP_KERNEL); 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data[s_pos]) 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> out; 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* write only up to the end of this quantum */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">&gt;</span> quantum <span style="color:#f92672">-</span> q_pos) 
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">=</span> quantum <span style="color:#f92672">-</span> q_pos; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">copy_from_user</span>(dptr<span style="color:#f92672">-&gt;</span>data[s_pos]<span style="color:#f92672">+</span>q_pos, buf, count)) 
</span></span><span style="display:flex;"><span>    { 
</span></span><span style="display:flex;"><span>        retval <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EFAULT; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> out; 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>f_pos <span style="color:#f92672">+=</span> count; 
</span></span><span style="display:flex;"><span>    retval <span style="color:#f92672">=</span> count; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* update the size */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dev<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>f_pos) 
</span></span><span style="display:flex;"><span>        dev<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>f_pos; 
</span></span><span style="display:flex;"><span>    out: 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">up</span>(<span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>sem); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> retval; 
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><h5 id="读写矢量-readvwritev">读写矢量 readv&amp;writev</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>ssize_t (<span style="color:#f92672">*</span>readv) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">iovec</span> <span style="color:#f92672">*</span>iov, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count, loff_t 
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>ppos); 
</span></span><span style="display:flex;"><span>ssize_t (<span style="color:#f92672">*</span>writev) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">iovec</span> <span style="color:#f92672">*</span>iov, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count, loff_t 
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span>ppos);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> iovec 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>iov_base; __kernel_size_t iov_len; 
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://gitee.com/github-25970295/blogimgv2022/raw/master/v2-e14e59d101071b1ff39d9854bd248d9b_720w.webp"
    data-srcset="https://gitee.com/github-25970295/blogimgv2022/raw/master/v2-e14e59d101071b1ff39d9854bd248d9b_720w.webp, https://gitee.com/github-25970295/blogimgv2022/raw/master/v2-e14e59d101071b1ff39d9854bd248d9b_720w.webp 1.5x, https://gitee.com/github-25970295/blogimgv2022/raw/master/v2-e14e59d101071b1ff39d9854bd248d9b_720w.webp 2x"
    data-sizes="auto"
    alt="https://gitee.com/github-25970295/blogimgv2022/raw/master/v2-e14e59d101071b1ff39d9854bd248d9b_720w.webp"
    title="https://gitee.com/github-25970295/blogimgv2022/raw/master/v2-e14e59d101071b1ff39d9854bd248d9b_720w.webp"/></p>
<h3 id="3-字符设备驱动">3. 字符设备驱动</h3>
<ul>
<li>在Linux内核中，使用cdev结构体来描述一个字符设备，cdev结构体在/include/linux/cdev.h中定义。</li>
<li>dev_t定义了设备号，一共32位，主设备号高12位，次设备号低20位。主设备号用来区分设备类型，次设备号用来区分同类型的不同设备。</li>
</ul>
<h4 id="1-设备驱动结构">.1. 设备驱动结构</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cdev</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">kobject</span> kobj;  <span style="color:#75715e">/* 内嵌的内核对象 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">module</span> <span style="color:#f92672">*</span>owner;  <span style="color:#75715e">/* 模块所有者，一般为THIS OWNER */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file_operations</span> <span style="color:#f92672">*</span>ops;  <span style="color:#75715e">/* 文件操作结构体 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">list_head</span> list;  <span style="color:#75715e">/* 把所有向内核注册的字符设备形成链表 */</span>
</span></span><span style="display:flex;"><span>        dev_t dev;  <span style="color:#75715e">/* 设备号，由主设备号和次设备号构成 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count;  <span style="color:#75715e">/* 属于同主设备号的次设备号的个数 */</span>
</span></span><span style="display:flex;"><span>} __randomize_layout;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">MAJOR</span>(dev)  <span style="color:#75715e">/* 从dev_t中获取主设备号 */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MINOR</span>(dev)  <span style="color:#75715e">/* 从dev_t中获取次设备号 */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MKDEV</span>(ma,mi)  <span style="color:#75715e">/* 通过主设备号ma和次设备号mi生成dev_t */</span>
</span></span></code></pre></div><h4 id="2-模块加载函数和模块卸载函数">.2. 模块加载函数和模块卸载函数</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* 设备驱动模块加载函数 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> _ _init <span style="color:#a6e22e">xxx_init</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cdev_init</span>(<span style="color:#f92672">&amp;</span>xxx_dev.cdev, <span style="color:#f92672">&amp;</span>xxx_fops);  <span style="color:#75715e">/* 初始化 cdev */</span>
</span></span><span style="display:flex;"><span>    xxx_dev.cdev.owner <span style="color:#f92672">=</span> THIS_MODULE;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 获取字符设备号 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (xxx_major) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">register_chrdev_region</span>(xxx_dev_no, <span style="color:#ae81ff">1</span>, DEV_NAME);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">alloc_chrdev_region</span>(<span style="color:#f92672">&amp;</span>xxx_dev_no, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, DEV_NAME);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">cdev_add</span>(<span style="color:#f92672">&amp;</span>xxx_dev.cdev, xxx_dev_no, <span style="color:#ae81ff">1</span>); <span style="color:#75715e">/* 注册设备 */</span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 设备驱动模块卸载函数 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> _ _exit <span style="color:#a6e22e">xxx_exit</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unregister_chrdev_region</span>(xxx_dev_no, <span style="color:#ae81ff">1</span>);  <span style="color:#75715e">/* 释放占用的设备号 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cdev_del</span>(<span style="color:#f92672">&amp;</span>xxx_dev.cdev);  <span style="color:#75715e">/* 注销设备 */</span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3-file_operations结构体的成员函数">.3. file_operations结构体的成员函数</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* 打开设备 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">xxx_open</span>(<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>inode, <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 释放设备 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">xxx_release</span>(<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>inode, <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* ioctl */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">xxx_ioctl</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...   
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (cmd) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> XXX_CMD1:
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> XXX_CMD2:
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 不能支持的命令 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span> ENOTTY;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 读 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * filp:文件结构体指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * buf：读取的内存地址 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * size:字节大小 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * ppos:对文件操作的起始位置 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">xxx_read</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span> buf, <span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span> ppos)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">copy_to_user</span>(buf, ..., ...);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* filp:文件结构体指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * buf：写入的内存地址 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * size:字节大小 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * ppos:对文件操作的起始位置 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">xxx_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>ppos)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">copy_from_user</span>(..., buf, ...);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 文件操作结构体 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> file_operations test_fops <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    .owner <span style="color:#f92672">=</span> THIS_MODULE,
</span></span><span style="display:flex;"><span>    .open <span style="color:#f92672">=</span> xxx_open,
</span></span><span style="display:flex;"><span>    .release <span style="color:#f92672">=</span> xxx_release,
</span></span><span style="display:flex;"><span>    .read <span style="color:#f92672">=</span> xxx_read,
</span></span><span style="display:flex;"><span>    .write <span style="color:#f92672">=</span> xxx_write,
</span></span><span style="display:flex;"><span>    .unlocked_ioctl <span style="color:#f92672">=</span> xxx_ioctl,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="4-ioctl-接口">.4. ioctl 接口</h4>
<p>大部分设备可进行超出简单的数据传输之外的操作; 用户空间必须常常能够请求, 例如, 设备锁上它的门, 弹出它的介质, 报告错误信息, 改变波特率, 或者自我销毁.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>ioctl) (<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>inode, <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">switch</span>(cmd) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> SCULL_IOCRESET: 
</span></span><span style="display:flex;"><span>        scull_quantum <span style="color:#f92672">=</span> SCULL_QUANTUM; 
</span></span><span style="display:flex;"><span>        scull_qset <span style="color:#f92672">=</span> SCULL_QSET; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> SCULL_IOCSQUANTUM: <span style="color:#75715e">/* Set: arg points to the value */</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> <span style="color:#a6e22e">capable</span> (CAP_SYS_ADMIN)) 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EPERM; 
</span></span><span style="display:flex;"><span>        retval <span style="color:#f92672">=</span> <span style="color:#a6e22e">__get_user</span>(scull_quantum, (<span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>)arg); 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> SCULL_IOCTQUANTUM: <span style="color:#75715e">/* Tell: arg is the value */</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> <span style="color:#a6e22e">capable</span> (CAP_SYS_ADMIN)) 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EPERM; 
</span></span><span style="display:flex;"><span>        scull_quantum <span style="color:#f92672">=</span> arg; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> SCULL_IOCGQUANTUM: <span style="color:#75715e">/* Get: arg is pointer to result */</span> 
</span></span><span style="display:flex;"><span>        retval <span style="color:#f92672">=</span> <span style="color:#a6e22e">__put_user</span>(scull_quantum, (<span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>)arg); 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> SCULL_IOCQQUANTUM: <span style="color:#75715e">/* Query: return it (it&#39;s positive) */</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> scull_quantum; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> SCULL_IOCXQUANTUM: <span style="color:#75715e">/* eXchange: use arg as pointer */</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> <span style="color:#a6e22e">capable</span> (CAP_SYS_ADMIN)) 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EPERM; 
</span></span><span style="display:flex;"><span>        tmp <span style="color:#f92672">=</span> scull_quantum; 
</span></span><span style="display:flex;"><span>        retval <span style="color:#f92672">=</span> <span style="color:#a6e22e">__get_user</span>(scull_quantum, (<span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>)arg); 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (retval <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span>            retval <span style="color:#f92672">=</span> <span style="color:#a6e22e">__put_user</span>(tmp, (<span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>)arg); 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> SCULL_IOCHQUANTUM: <span style="color:#75715e">/* sHift: like Tell + Query */</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> <span style="color:#a6e22e">capable</span> (CAP_SYS_ADMIN)) 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EPERM; 
</span></span><span style="display:flex;"><span>        tmp <span style="color:#f92672">=</span> scull_quantum; 
</span></span><span style="display:flex;"><span>        scull_quantum <span style="color:#f92672">=</span> arg; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> tmp; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> <span style="color:#75715e">/* redundant, as cmd was checked against MAXNR */</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOTTY; 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> retval;
</span></span></code></pre></div><h4 id="5-阻塞io">.5. 阻塞IO</h4>
<ul>
<li>一个对 read 的调用可能当没有数据时到来, 而以后会期待更多的数据. 或者一个进程可能试图写, 但是你的设备没有准备好接受数据, 因为你的输出缓冲满了。</li>
<li>当一个进程被置为睡眠, 它被标识为处于一个特殊的状态并且从调度器的运行队列中去除. 直到发生某些事情改变了那个状态, 这个进程将不被在任何 CPU 上调度, 并且, 因此, 将不会运行</li>
<li>当你运行在原子上下文时不能睡眠，对于睡眠, 是你的驱动在持有一个自旋锁, seqlock, 或者 RCU 锁时不能睡眠. 如果你已关闭中断你也不能睡眠</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">wait_event</span>(queue, condition) 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wait_event_interruptible</span>(queue, condition); <span style="color:#75715e">// 一个非零值意味着你的睡眠被某些信号打断, 并且你的驱动可能应当返回 -ERESTARTSYS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">wait_event_timeout</span>(queue, condition, timeout) ; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wait_event_interruptible_timeout</span>(queue, condition, timeout);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wake_up</span>(<span style="color:#66d9ef">wait_queue_head_t</span> <span style="color:#f92672">*</span>queue); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wake_up_interruptible</span>(<span style="color:#66d9ef">wait_queue_head_t</span> <span style="color:#f92672">*</span>queue);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#a6e22e">DECLARE_WAIT_QUEUE_HEAD</span>(wq); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">sleepy_read</span> (<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> count, <span style="color:#66d9ef">loff_t</span> 
</span></span><span style="display:flex;"><span>                     <span style="color:#f92672">*</span>pos) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;process %i (%s) going to sleep</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
</span></span><span style="display:flex;"><span>           current<span style="color:#f92672">-&gt;</span>pid, current<span style="color:#f92672">-&gt;</span>comm); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wait_event_interruptible</span>(wq, flag <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>); 
</span></span><span style="display:flex;"><span>    flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;awoken %i (%s)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, current<span style="color:#f92672">-&gt;</span>pid, current<span style="color:#f92672">-&gt;</span>comm); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">/* EOF */</span> 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">sleepy_write</span> (<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> count, 
</span></span><span style="display:flex;"><span>                      <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>pos) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;process %i (%s) awakening the readers...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
</span></span><span style="display:flex;"><span>           current<span style="color:#f92672">-&gt;</span>pid, current<span style="color:#f92672">-&gt;</span>comm); 
</span></span><span style="display:flex;"><span>    flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wake_up_interruptible</span>(<span style="color:#f92672">&amp;</span>wq); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> count; <span style="color:#75715e">/* succeed, to avoid retrial */</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="6-poll-和-select">.6. poll 和 select</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>poll) (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>filp, poll_table <span style="color:#f92672">*</span>wait);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">poll_wait</span> (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">file</span> <span style="color:#f92672">*</span>, wait_queue_head_t <span style="color:#f92672">*</span>, poll_table <span style="color:#f92672">*</span>);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">scull_p_poll</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, poll_table <span style="color:#f92672">*</span>wait) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> scull_pipe <span style="color:#f92672">*</span>dev <span style="color:#f92672">=</span> filp<span style="color:#f92672">-&gt;</span>private_data; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> mask <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The buffer is circular; it is considered full 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * if &#34;wp&#34; is right behind &#34;rp&#34; and empty if the 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * two are equal. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">down</span>(<span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>sem); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">poll_wait</span>(filp, <span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>inq, wait); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">poll_wait</span>(filp, <span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>outq, wait); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dev<span style="color:#f92672">-&gt;</span>rp <span style="color:#f92672">!=</span> dev<span style="color:#f92672">-&gt;</span>wp) 
</span></span><span style="display:flex;"><span>        mask <span style="color:#f92672">|=</span> POLLIN <span style="color:#f92672">|</span> POLLRDNORM; <span style="color:#75715e">/* readable */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">spacefree</span>(dev)) 
</span></span><span style="display:flex;"><span>        mask <span style="color:#f92672">|=</span> POLLOUT <span style="color:#f92672">|</span> POLLWRNORM; <span style="color:#75715e">/* writable */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">up</span>(<span style="color:#f92672">&amp;</span>dev<span style="color:#f92672">-&gt;</span>sem); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> mask; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="7-异步通知">.7. 异步通知</h4>
<ul>
<li>首先, 它们指定一个进程作为文件的拥有者. 当一个进程使用 fcntl 系统调用发出 F_SETOWN 命令, 这个拥有者进程的 ID 被保存在 filp-&gt;f_owner 给以后使用.</li>
<li>用户程序必须设置 FASYNC 标志在设备中, 通过 F_SETFL fcntl 命令，输入文件可请求递交一个 SIGIO 信号, 无论何时新数据到达. 信号被发送给存储于 filp-&gt;f_owner 中的进程(或者进程组, 如果值为负值).</li>
<li>当 F_SETFL 被执行来打开 FASYNC, 驱动的 fasync 方法被调用. 这个方法被调用无论何时 FASYNC 的值在 filp-&gt;f_flags 中被改变来通知驱动这个变化, 因此它可正确地响应. 这个标志在文件被打开时缺省地被清除.</li>
<li>当数据到达, 所有的注册异步通知的进程必须被发出一个 SIGIO 信号</li>
</ul>
<h5 id="1设备驱动如何实现异步信号">1.设备驱动如何实现异步信号</h5>
<blockquote>
<ol>
<li>当发出 F_SETOWN, 什么都没发生, 除了一个值被赋值给 filp-&gt;f_owner.</li>
<li>当 F_SETFL 被执行来打开 FASYNC, 驱动的 fasync 方法被调用. 这个方法被调用无论何时 FASYNC 的值在 filp-&gt;f_flags 中被改变来通知驱动这个变化, 因此它可正确地响应.</li>
<li>当数据到达, 所有的注册异步通知的进程必须被发出一个 SIGIO 信号.   todo?</li>
</ol>
</blockquote>
<h4 id="8-移位一个设备">.8. 移位一个设备</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">loff_t</span> <span style="color:#a6e22e">scull_llseek</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">loff_t</span> off, <span style="color:#66d9ef">int</span> whence) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> scull_dev <span style="color:#f92672">*</span>dev <span style="color:#f92672">=</span> filp<span style="color:#f92672">-&gt;</span>private_data; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loff_t</span> newpos; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span>(whence) 
</span></span><span style="display:flex;"><span>    { 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> <span style="color:#75715e">/* SEEK_SET */</span> 
</span></span><span style="display:flex;"><span>            newpos <span style="color:#f92672">=</span> off; 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> <span style="color:#75715e">/* SEEK_CUR */</span> 
</span></span><span style="display:flex;"><span>            newpos <span style="color:#f92672">=</span> filp<span style="color:#f92672">-&gt;</span>f_pos <span style="color:#f92672">+</span> off; 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span> <span style="color:#75715e">/* SEEK_END */</span> 
</span></span><span style="display:flex;"><span>            newpos <span style="color:#f92672">=</span> dev<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">+</span> off; 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> <span style="color:#75715e">/* can&#39;t happen */</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL; 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (newpos <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL; 
</span></span><span style="display:flex;"><span>    filp<span style="color:#f92672">-&gt;</span>f_pos <span style="color:#f92672">=</span> newpos; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> newpos; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://www.tiandeng.xyz/posts/Linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/#%E8%AE%BE%E5%A4%87%E5%8F%B7"target="_blank" rel="external nofollow noopener noreferrer">字符驱动程序案例<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;linux/export.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;linux/gfp.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;linux/kern_levels.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;linux/printk.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;linux/types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/kernel.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/init.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/module.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/kdev_t.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/fs.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/cdev.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/device.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/slab.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/uaccess.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MEM_SIZE 1024
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEV_TYPE                &#39;k&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEV_SET_VALUE           _IOR(DEV_TYPE, 1, int32_t*)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEV_GET_VALUE           _IOW(DEV_TYPE, 2, int32_t*)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int32_t</span> val <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">dev_t</span> dev <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> cdev my_cdev;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> class<span style="color:#f92672">*</span> dev_class;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> kernel_buffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> __init <span style="color:#a6e22e">chr_driver_init</span>(<span style="color:#66d9ef">void</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> __exit <span style="color:#a6e22e">chr_driver_exit</span>(<span style="color:#66d9ef">void</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">my_open</span>(<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>_inode, <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>_file);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">my_release</span>(<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>_inode, <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>_file);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">my_read</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>off);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">my_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>off);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">my_ioctl</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> file_operations fops <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        .owner          <span style="color:#f92672">=</span> THIS_MODULE,
</span></span><span style="display:flex;"><span>        .read           <span style="color:#f92672">=</span> my_read,
</span></span><span style="display:flex;"><span>        .write          <span style="color:#f92672">=</span> my_write,
</span></span><span style="display:flex;"><span>        .open           <span style="color:#f92672">=</span> my_open,
</span></span><span style="display:flex;"><span>        .unlocked_ioctl <span style="color:#f92672">=</span> my_ioctl,
</span></span><span style="display:flex;"><span>        .release        <span style="color:#f92672">=</span> my_release,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">my_open</span>(<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>_inode, <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>_file)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Creating Physical Memory */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>((kernel_buffer <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmalloc</span>(MEM_SIZE, GFP_KERNEL)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Cannot allocate memory to the kernel.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Device File opened.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">my_release</span>(<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>_inode, <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>_file)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">kfree</span>(kernel_buffer);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Device File closed.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">my_read</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>off)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">ssize_t</span> re;
</span></span><span style="display:flex;"><span>        re <span style="color:#f92672">=</span> <span style="color:#a6e22e">copy_to_user</span>(buf, kernel_buffer, MEM_SIZE);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Data read : Done.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> re;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">my_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>off)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">ssize_t</span> re;
</span></span><span style="display:flex;"><span>        re <span style="color:#f92672">=</span> <span style="color:#a6e22e">copy_from_user</span>(kernel_buffer, buf, len);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Data write : successful.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> re;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if 0</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">static long my_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        long re;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        switch (cmd) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        case DEV_SET_VALUE:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                re = copy_from_user(&amp;val, (int32_t*)arg, sizeof(val));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                break;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        case DEV_GET_VALUE:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                re = copy_to_user((int32_t*)arg, &amp;val, sizeof(val));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                break;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        default:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                return -EINVAL;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        return re;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">my_ioctl</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>argp <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> __user<span style="color:#f92672">*</span>)arg;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int32_t</span> __user <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> argp;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (cmd) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> DEV_SET_VALUE:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_user</span>(val, p);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> DEV_GET_VALUE:
</span></span><span style="display:flex;"><span>                re <span style="color:#f92672">=</span> <span style="color:#a6e22e">put_user</span>(val, p);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> re;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> __init <span style="color:#a6e22e">chr_driver_init</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Allocating Major number */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">alloc_chrdev_region</span>(<span style="color:#f92672">&amp;</span>dev, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> , <span style="color:#e6db74">&#34;my_Dev&#34;</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Cannot allocate major number.&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Major = %d Minor = %d.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">MAJOR</span>(dev), <span style="color:#a6e22e">MINOR</span>(dev));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* creating cdev structure */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cdev_init</span>(<span style="color:#f92672">&amp;</span>my_cdev, <span style="color:#f92672">&amp;</span>fops);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Adding character device to the system */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cdev_add</span>(<span style="color:#f92672">&amp;</span>my_cdev, dev, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Cannot add the device to the system.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">goto</span> r_class;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* creating struct class */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((dev_class <span style="color:#f92672">=</span> <span style="color:#a6e22e">class_create</span>(THIS_MODULE, <span style="color:#e6db74">&#34;my_class&#34;</span>)) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Cannot create the struct class.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">goto</span> r_class;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* creating device */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">device_create</span>(dev_class, NULL, dev, NULL, <span style="color:#e6db74">&#34;my_device&#34;</span>) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Cannot create the device.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">goto</span> r_device;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Device driver insert done.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>r_device:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">class_destroy</span>(dev_class);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>r_class:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">unregister_chrdev_region</span>(dev, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> __exit <span style="color:#a6e22e">chr_driver_exit</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">device_destroy</span>(dev_class, dev);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">class_destroy</span>(dev_class);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cdev_del</span>(<span style="color:#f92672">&amp;</span>my_cdev);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">unregister_chrdev_region</span>(dev, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Device driver is removed successfully.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_init</span>(chr_driver_init);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_exit</span>(chr_driver_exit);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_LICENSE</span>(<span style="color:#e6db74">&#34;GPL&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_AUTHOR</span>(<span style="color:#e6db74">&#34;tiandeng &lt;tiandengzbc@gmail.com&gt;&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_DESCRIPTION</span>(<span style="color:#e6db74">&#34;A simple character device driver example&#34;</span>);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">u_int8_t</span> write_buf[<span style="color:#ae81ff">1024</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">u_int8_t</span> read_buf[<span style="color:#ae81ff">1024</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> fd;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> options;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Welcome to the demo of character device driver.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;/dev/my_device&#34;</span>, O_RDWR);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;failed to open device: &#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;**************please enter your option***************** </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;                1. Write                                </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;                2. Read                                 </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;                3. Exit                                 </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34; %c&#34;</span>, <span style="color:#f92672">&amp;</span>options);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Your options = %c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, options);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">switch</span> (options) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;1&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Enter the string to write into the driver:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34; %[^</span><span style="color:#ae81ff">\t\n</span><span style="color:#e6db74">]s&#34;</span>, write_buf);
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Data written .....</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">write</span>(fd, write_buf, <span style="color:#a6e22e">strlen</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)write_buf) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Done...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;2&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Data is Reading...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">read</span>(fd, read_buf, <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Done...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Data = %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, read_buf);
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;3&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Enter valid option = %c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, options);
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/ioctl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEV_TYPE                &#39;k&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEV_SET_VALUE           _IOR(DEV_TYPE, 1, int32_t*)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEV_GET_VALUE           _IOW(DEV_TYPE, 2, int32_t*)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> fd;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int32_t</span> val, num;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74"> IOCTL based Character device driver operation from user space.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;/dev/my_device&#34;</span>, O_RDWR);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;Cannot open the device file.:&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Enter the data to set.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>num);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Writing value to the driver.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ioctl</span>(fd, DEV_SET_VALUE, <span style="color:#f92672">&amp;</span>num);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Reading value from driver.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ioctl</span>(fd, DEV_GET_VALUE, <span style="color:#f92672">&amp;</span>val);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;get value is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, val);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Closed device</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="4-打印调试">4. 打印调试</h3>
<ul>
<li>todo</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;Here I am: %s:%i</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, __FILE__, __LINE__); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printk</span>(KERN_CRIT <span style="color:#e6db74">&#34;I&#39;m trashed; giving up on %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ptr);
</span></span></code></pre></div><h3 id="5-并发和竞争情况">5. 并发和竞争情况</h3>
<h4 id="1-旗标和互斥体">.1. <strong>旗标和互斥体</strong></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">down_write</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">down_write_trylock</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">up_write</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">downgrade_write</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem);
</span></span></code></pre></div><h4 id="2-completions-机制">.2. Completions 机制</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> completion my_completion;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">init_completion</span>(<span style="color:#f92672">&amp;</span>my_completion); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wait_for_completion</span>(<span style="color:#66d9ef">struct</span> completion <span style="color:#f92672">*</span>c); <span style="color:#75715e">//进行一个不可打断的等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">complete</span>(<span style="color:#66d9ef">struct</span> completion <span style="color:#f92672">*</span>c); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">complete_all</span>(<span style="color:#66d9ef">struct</span> completion <span style="color:#f92672">*</span>c);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">complete_and_exit</span>(<span style="color:#66d9ef">struct</span> completion <span style="color:#f92672">*</span>c, <span style="color:#66d9ef">long</span> retval);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">DECLARE_COMPLETION</span>(comp); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">complete_read</span> (<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> count, 
</span></span><span style="display:flex;"><span>                       <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>pos) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;process %i (%s) going to sleep</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,current<span style="color:#f92672">-&gt;</span>pid, 
</span></span><span style="display:flex;"><span>           current<span style="color:#f92672">-&gt;</span>comm); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wait_for_completion</span>(<span style="color:#f92672">&amp;</span>comp); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;awoken %i (%s)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, current<span style="color:#f92672">-&gt;</span>pid, current<span style="color:#f92672">-&gt;</span>comm); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">/* EOF */</span> 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">complete_write</span> (<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> 
</span></span><span style="display:flex;"><span>                        count, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>pos) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;process %i (%s) awakening the readers...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, current<span style="color:#f92672">-</span>
</span></span><span style="display:flex;"><span>           <span style="color:#f92672">&gt;</span>pid, current<span style="color:#f92672">-&gt;</span>comm); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">complete</span>(<span style="color:#f92672">&amp;</span>comp); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> count; <span style="color:#75715e">/* succeed, to avoid retrial */</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3-自旋锁">.3. 自旋锁</h4>
<ul>
<li>自旋锁的核心规则是任何代码必须, 在持有自旋锁时, 是原子性的. 它不能睡眠; 事实上, 它不能因为任何原因放弃处理器, 除了服务中断(并且有时即便此时也不行)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_lock_init</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock); <span style="color:#75715e">//初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_lock</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock); <span style="color:#75715e">//在进入一个临界区前, 你的代码必须获得需要的 lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_unlock</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock);  <span style="color:#75715e">// 取消自旋
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_lock</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_lock_irqsave</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_lock_irq</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_lock_bh</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_unlock</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_unlock_irqrestore</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_unlock_irq</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_unlock_bh</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">rwlock_t</span> my_rwlock <span style="color:#f92672">=</span> RW_LOCK_UNLOCKED; <span style="color:#75715e">/* Static way */</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">rwlock_t</span> my_rwlock; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rwlock_init</span>(<span style="color:#f92672">&amp;</span>my_rwlock); <span style="color:#75715e">/* Dynamic way */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_lock</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_lock_irqsave</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_lock_irq</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_lock_bh</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_unlock</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_unlock_irqrestore</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_unlock_irq</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_unlock_bh</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_lock</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_lock_irqsave</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_lock_irq</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_lock_bh</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">write_trylock</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_unlock</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_unlock_irqrestore</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_unlock_irq</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_unlock_bh</span>(<span style="color:#66d9ef">rwlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span></code></pre></div><h4 id="4-锁陷阱">.4. 锁陷阱</h4>
<ul>
<li>如果一个函数需要一个锁并且接着调用另一个函数也试图请求这个锁, 你的代码死锁.</li>
<li>不论旗标还是自旋锁都不允许一个持锁者第 2 次请求锁;</li>
<li>当多个锁必须获得时, 它们应当一直以同样顺序获得；</li>
<li>你可以用一个锁来涵盖你做的所有东西, 或者你可以给你管理的每个设备创建一个锁.</li>
</ul>
<h4 id="5-加锁的选择">.5. 加锁的选择</h4>
<h5 id="1-不加锁算法">1. 不加锁算法</h5>
<ul>
<li>todo 无锁环形缓冲区</li>
</ul>
<h5 id="2-原子变量">2. 原子变量</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">atomic_set</span>(<span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v, <span style="color:#66d9ef">int</span> i); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">atomic_t</span> v <span style="color:#f92672">=</span> <span style="color:#a6e22e">ATOMIC_INIT</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">atomic_read</span>(<span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">atomic_add</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">atomic_sub</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">atomic_inc</span>(<span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">atomic_dec</span>(<span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">atomic_inc_and_test</span>(<span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">atomic_dec_and_test</span>(<span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">atomic_sub_and_test</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">atomic_add_negative</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v);
</span></span></code></pre></div><h5 id="3-位操作">3. 位操作</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_bit</span>(nr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);  <span style="color:#75715e">//设置第 nr 位在 addr 指向的数据项中.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clear_bit</span>(nr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">change_bit</span>(nr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr); <span style="color:#75715e">//翻转这个位.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">test_bit</span>(nr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">test_and_set_bit</span>(nr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">test_and_clear_bit</span>(nr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">test_and_change_bit</span>(nr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* try to set lock */</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">test_and_set_bit</span>(nr, addr) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">wait_for_a_while</span>(); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* do your work */</span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* release lock, and check... */</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">test_and_clear_bit</span>(nr, addr) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">something_went_wrong</span>(); <span style="color:#75715e">/* already released: error */</span>
</span></span></code></pre></div><h5 id="4--seqlock-锁">4.  <strong>seqlock 锁</strong></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> seq; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">do</span> { 
</span></span><span style="display:flex;"><span>    seq <span style="color:#f92672">=</span> <span style="color:#a6e22e">read_seqbegin</span>(<span style="color:#f92672">&amp;</span>the_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Do what you need to do */</span> 
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">while</span> <span style="color:#a6e22e">read_seqretry</span>(<span style="color:#f92672">&amp;</span>the_lock, seq);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_seqlock_irqsave</span>(<span style="color:#66d9ef">seqlock_t</span> <span style="color:#f92672">*</span>lock, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_seqlock_irq</span>(<span style="color:#66d9ef">seqlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_seqlock_bh</span>(<span style="color:#66d9ef">seqlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_sequnlock_irqrestore</span>(<span style="color:#66d9ef">seqlock_t</span> <span style="color:#f92672">*</span>lock, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_sequnlock_irq</span>(<span style="color:#66d9ef">seqlock_t</span> <span style="color:#f92672">*</span>lock); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_sequnlock_bh</span>(<span style="color:#66d9ef">seqlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span></code></pre></div><h5 id="5-读取-拷贝-更新">5. <strong>读取-拷贝-更新</strong></h5>
<ul>
<li>当数据结构需要改变, 写线程做一个拷贝, 改变这个拷贝, 接着使相关的指针对准新的版本</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> my_stuff <span style="color:#f92672">*</span>stuff; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rcu_read_lock</span>(); 
</span></span><span style="display:flex;"><span>stuff <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_the_stuff</span>(args...); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">do_something_with</span>(stuff); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rcu_read_unlock</span>();
</span></span></code></pre></div><h3 id="6-时间延迟延后工作">6. 时间&amp;延迟&amp;延后工作</h3>
<h4 id="1-获取当前时间">.1. 获取当前时间</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/time.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">mktime</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> year, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> mon, 
</span></span><span style="display:flex;"><span>                      <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> day, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> hour, 
</span></span><span style="display:flex;"><span>                      <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> min, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> sec);
</span></span></code></pre></div><h4 id="2-延后执行">.2. 延后执行</h4>
<h5 id="1-长延时">1. 长延时</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//忙等待严重地降低了系统性能. 如果你不配置你的内核为抢占操作, 这个循环在延时期间完全锁住了处理器; 调度器永远不会抢占一个在内核中运行的进程, 并且计算机看起来完全死掉直到时间 j1 到时.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//当你进入循环时如果中断碰巧被禁止, jiffies 将不会被更新, 并且 while 条件永远保持真
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">time_before</span>(jiffies, j1)) 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cpu_relax</span>();  <span style="color:#75715e">//忙等待强加了一个重负载给系统总体;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//当前进程除了释放 CPU 不作任何事情, 但是它保留在运行队列中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">time_before</span>(jiffies, j1)) { 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">schedule</span>();    <span style="color:#75715e">//随着系统变忙会变得越来越坏, 并且驱动可能结束于等待长于期望的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//------------------ 推荐方式 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//驱动使用一个等待队列来等待某些其他事件, 但是你也想确保它在一个确定时间段内运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/wait.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">wait_event_timeout</span>(<span style="color:#66d9ef">wait_queue_head_t</span> q, condition, <span style="color:#66d9ef">long</span> timeout); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">wait_event_interruptible_timeout</span>(<span style="color:#66d9ef">wait_queue_head_t</span> q, condition, <span style="color:#66d9ef">long</span> 
</span></span><span style="display:flex;"><span>timeout);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//如果超时到, 这些函数返回 0; 如果这个进程被其他事件唤醒, 它返回以 jiffies 表示的剩余超时值. 返回值从不会是负值, 甚至如果延时由于系统负载而比期望的值大.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wait_queue_head_t</span> wait; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">init_waitqueue_head</span> (<span style="color:#f92672">&amp;</span>wait); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wait_event_interruptible_timeout</span>(wait, <span style="color:#ae81ff">0</span>, delay);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//第一行调用 set_current_state 来设定一些东西以便调度器不会再次运行当前进程, 直到超时将它置回 TASK_RUNNING 状态. 为获得一个不可中断的延时, 使用 TASK_UNINTERRUPTIBLE 代替
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">set_current_state</span>(TASK_INTERRUPTIBLE); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">schedule_timeout</span> (delay);
</span></span></code></pre></div><h5 id="2-短延时">.2. 短延时</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//这 3 个延时函数是忙等待; 其他任务在时间流失时不能运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/delay.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ndelay</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> nsecs); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">udelay</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> usecs); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mdelay</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> msecs);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//获得毫秒(和更长)延时而不用涉及到忙等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">msleep</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> millisecs); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">msleep_interruptible</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> millisecs); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ssleep</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> seconds)
</span></span></code></pre></div><h4 id="3-内核定时器">.3. 内核定时器</h4>
<ul>
<li>一个内核定时器是一个数据结构, 它指导内核执行一个用户定义的函数使用一个用户定义的参数在一个用户定义的时间</li>
<li>被调度运行的函数几乎确定不会在注册它们的进程在运行时运行. 它们是, 相反, 异步运行.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/timer.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> timer_list 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ... */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> expires; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>function)(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> data; 
</span></span><span style="display:flex;"><span>}; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init_timer</span>(<span style="color:#66d9ef">struct</span> timer_list <span style="color:#f92672">*</span>timer); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> timer_list <span style="color:#a6e22e">TIMER_INITIALIZER</span>(_function, _expires, _data); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_timer</span>(<span style="color:#66d9ef">struct</span> timer_list <span style="color:#f92672">*</span> timer); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">del_timer</span>(<span style="color:#66d9ef">struct</span> timer_list <span style="color:#f92672">*</span> timer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> j <span style="color:#f92672">=</span> jiffies; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* fill the data for our timer function */</span> 
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">-&gt;</span>prevjiffies <span style="color:#f92672">=</span> j; 
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">-&gt;</span>buf <span style="color:#f92672">=</span> buf2; 
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">-&gt;</span>loops <span style="color:#f92672">=</span> JIT_ASYNC_LOOPS; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* register the timer */</span> 
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">-&gt;</span>timer.data <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)data; 
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">-&gt;</span>timer.function <span style="color:#f92672">=</span> jit_timer_fn; 
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">-&gt;</span>timer.expires <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> tdelay; <span style="color:#75715e">/* parameter */</span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add_timer</span>(<span style="color:#f92672">&amp;</span>data<span style="color:#f92672">-&gt;</span>timer); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* wait for the buffer to fill */</span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wait_event_interruptible</span>(data<span style="color:#f92672">-&gt;</span>wait, <span style="color:#f92672">!</span>data<span style="color:#f92672">-&gt;</span>loops); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//The actual timer function looks like this: 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">jit_timer_fn</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> jit_data <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> jit_data <span style="color:#f92672">*</span>)arg; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> j <span style="color:#f92672">=</span> jiffies; 
</span></span><span style="display:flex;"><span>    data<span style="color:#f92672">-&gt;</span>buf <span style="color:#f92672">+=</span> <span style="color:#a6e22e">sprintf</span>(data<span style="color:#f92672">-&gt;</span>buf, <span style="color:#e6db74">&#34;%9li %3li %i %6i %i %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
</span></span><span style="display:flex;"><span>                         j, j <span style="color:#f92672">-</span> data<span style="color:#f92672">-&gt;</span>prevjiffies, <span style="color:#a6e22e">in_interrupt</span>() <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>                         current<span style="color:#f92672">-&gt;</span>pid, <span style="color:#a6e22e">smp_processor_id</span>(), current<span style="color:#f92672">-&gt;</span>comm); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>data<span style="color:#f92672">-&gt;</span>loops) { 
</span></span><span style="display:flex;"><span>        data<span style="color:#f92672">-&gt;</span>timer.expires <span style="color:#f92672">+=</span> tdelay; 
</span></span><span style="display:flex;"><span>        data<span style="color:#f92672">-&gt;</span>prevjiffies <span style="color:#f92672">=</span> j; 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">add_timer</span>(<span style="color:#f92672">&amp;</span>data<span style="color:#f92672">-&gt;</span>timer); 
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> { 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wake_up_interruptible</span>(<span style="color:#f92672">&amp;</span>data<span style="color:#f92672">-&gt;</span>wait); 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4-tasklets">.4. Tasklets</h4>
<ul>
<li>一个 tasklet 能够被禁止并且之后被重新使能; 它不会执行直到它被使能与被禁止相同的的次数</li>
<li>如同定时器, 一个 tasklet 可以注册它自己.</li>
<li>一个 tasklet 能被调度来执行以正常的优先级或者高优先级. 后一组一直是首先执行</li>
<li>taslet 可能立刻运行, 如果系统不在重载下, 但是从不会晚于下一个时钟嘀哒.</li>
<li>一个 tasklet 可能和其他 tasklet 并发, 但是对它自己是严格地串行的 &ndash; 同样的 tasklet 从不同时运行在超过一个处理器上. 同样, 如已经提到的, 一个 tasklet 常常在调度它的同一个 CPU 上运行.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/interrupt.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">DECLARE_TASKLET</span>(name, func, data); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">DECLARE_TASKLET_DISABLED</span>(name, func, data);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tasklet_init</span>(<span style="color:#66d9ef">struct</span> tasklet_struct <span style="color:#f92672">*</span>t, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>func)(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>), 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tasklet_disable</span>(<span style="color:#66d9ef">struct</span> tasklet_struct <span style="color:#f92672">*</span>t); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tasklet_disable_nosync</span>(<span style="color:#66d9ef">struct</span> tasklet_struct <span style="color:#f92672">*</span>t); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tasklet_enable</span>(<span style="color:#66d9ef">struct</span> tasklet_struct <span style="color:#f92672">*</span>t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tasklet_schedule</span>(<span style="color:#66d9ef">struct</span> tasklet_struct <span style="color:#f92672">*</span>t); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tasklet_hi_schedule</span>(<span style="color:#66d9ef">struct</span> tasklet_struct <span style="color:#f92672">*</span>t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tasklet_kill</span>(<span style="color:#66d9ef">struct</span> tasklet_struct <span style="color:#f92672">*</span>t);
</span></span></code></pre></div><h4 id="5-工作队列--共享队列">.5. 工作队列&ndash;共享队列</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> work_struct jiq_work; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* this line is in jiq_init() */</span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">INIT_WORK</span>(<span style="color:#f92672">&amp;</span>jiq_work, jiq_print_wq, <span style="color:#f92672">&amp;</span>jiq_data);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">schedule_work</span>(<span style="color:#66d9ef">struct</span> work_struct <span style="color:#f92672">*</span>work);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">prepare_to_wait</span>(<span style="color:#f92672">&amp;</span>jiq_wait, <span style="color:#f92672">&amp;</span>wait, TASK_INTERRUPTIBLE); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">schedule_work</span>(<span style="color:#f92672">&amp;</span>jiq_work); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">schedule</span>(); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">finish_wait</span>(<span style="color:#f92672">&amp;</span>jiq_wait, <span style="color:#f92672">&amp;</span>wait);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">jiq_print_wq</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> clientdata <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> clientdata <span style="color:#f92672">*</span>) ptr; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> <span style="color:#a6e22e">jiq_print</span> (ptr)) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (data<span style="color:#f92672">-&gt;</span>delay) 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">schedule_delayed_work</span>(<span style="color:#f92672">&amp;</span>jiq_work, data<span style="color:#f92672">-&gt;</span>delay);   <span style="color:#75715e">//重新提交它自己在延后的模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">schedule_work</span>(<span style="color:#f92672">&amp;</span>jiq_work); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flush_scheduled_work</span>(<span style="color:#66d9ef">void</span>);
</span></span></code></pre></div><h3 id="7-分配内存">7. 分配内存</h3>
<h4 id="1-kmalloc">.1. kmalloc</h4>
<ul>
<li>不清零它获得的内存; 分配的区仍然持有它原来的内容, 分配的区也是在物理内存中连续</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/slab.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">kmalloc</span>(<span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">int</span> flags);
</span></span></code></pre></div><ul>
<li>GFP_KENRL: 内核内存的正常分配. 可能睡眠. 意味着 kmalloc 能够使当前进程在少内存的情况下睡眠来等待一页,是可重入的并且不能在原子上下文中运行. 当当前进程睡眠, 内核采取正确的动作来定位一些空闲内存, 或者通过刷新缓存到磁盘或者交换出去一个用户进程的内存</li>
<li>GFP_ATOMIC : 用来从中断处理和进程上下文之外的其他代码中分配内存. 从不睡眠.</li>
<li>GFP_USER :用来为用户空间页来分配内存; 它可能睡眠.</li>
<li>Linux 内核知道最少 3 个内存区: DMA-能够 内存, 普通内存, 和高端内存</li>
<li>Linux 处理内存分配通过创建一套固定大小的内存对象池. 分配请求被这样来处理, 进入   一个持有足够大的对象的池子并且将整个内存块递交给请求者.</li>
</ul>
<h4 id="2-后备缓存">.2. 后备缓存</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>kmem_cache_t <span style="color:#f92672">*</span><span style="color:#a6e22e">kmem_cache_create</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name, size_t size, 
</span></span><span style="display:flex;"><span>                                size_t offset, 
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, 
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>constructor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, kmem_cache_t <span style="color:#f92672">*</span>, 
</span></span><span style="display:flex;"><span>                                                    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags), <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>destructor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, kmem_cache_t <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> 
</span></span><span style="display:flex;"><span>                                                                                             <span style="color:#66d9ef">long</span> flags));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">kmem_cache_alloc</span>(kmem_cache_t <span style="color:#f92672">*</span>cache, <span style="color:#66d9ef">int</span> flags);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kmem_cache_free</span>(kmem_cache_t <span style="color:#f92672">*</span>cache, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>obj);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kmem_cache_destroy</span>(kmem_cache_t <span style="color:#f92672">*</span>cache);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* declare one cache pointer: use it for all devices */</span> 
</span></span><span style="display:flex;"><span>kmem_cache_t <span style="color:#f92672">*</span>scullc_cache;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* scullc_init: create a cache for our quanta */</span> 
</span></span><span style="display:flex;"><span>scullc_cache <span style="color:#f92672">=</span> kmem_cache_create(<span style="color:#e6db74">&#34;scullc&#34;</span>, scullc_quantum, 
</span></span><span style="display:flex;"><span>                                 <span style="color:#ae81ff">0</span>, SLAB_HWCACHE_ALIGN, NULL, NULL); <span style="color:#75715e">/* no 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">ctor/dtor */</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>scullc_cache) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    scullc_cleanup(); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM; 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Allocate a quantum using the memory cache */</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data[s_pos]) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    dptr<span style="color:#f92672">-&gt;</span>data[s_pos] <span style="color:#f92672">=</span> kmem_cache_alloc(scullc_cache, GFP_KERNEL); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data[s_pos]) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> nomem; 
</span></span><span style="display:flex;"><span>    memset(dptr<span style="color:#f92672">-&gt;</span>data[s_pos], <span style="color:#ae81ff">0</span>, scullc_quantum); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> qset; i<span style="color:#f92672">++</span>) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dptr<span style="color:#f92672">-&gt;</span>data[i]) 
</span></span><span style="display:flex;"><span>        kmem_cache_free(scullc_cache, dptr<span style="color:#f92672">-&gt;</span>data[i]);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* scullc_cleanup: release the cache of our quanta */</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (scullc_cache) 
</span></span><span style="display:flex;"><span>    kmem_cache_destroy(scullc_cache);
</span></span></code></pre></div><h5 id="2-内存池">.2. 内存池</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// min_nr: 内存池应当保留的最小数量的分配的对象. 实际的分配和释放对象由 alloc_fn 和 free_fn 处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">mempool_t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mempool_create</span>(<span style="color:#66d9ef">int</span> min_nr, 
</span></span><span style="display:flex;"><span>                          <span style="color:#66d9ef">mempool_alloc_t</span> <span style="color:#f92672">*</span>alloc_fn, 
</span></span><span style="display:flex;"><span>                          <span style="color:#66d9ef">mempool_free_t</span> <span style="color:#f92672">*</span>free_fn, 
</span></span><span style="display:flex;"><span>                          <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pool_data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cache <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmem_cache_create</span>(. . .); 
</span></span><span style="display:flex;"><span>pool <span style="color:#f92672">=</span> <span style="color:#a6e22e">mempool_create</span>(MY_POOL_MINIMUM,mempool_alloc_slab, mempool_free_slab, 
</span></span><span style="display:flex;"><span>cache);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mempool_alloc</span>(<span style="color:#66d9ef">mempool_t</span> <span style="color:#f92672">*</span>pool, <span style="color:#66d9ef">int</span> gfp_mask); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mempool_free</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>element, <span style="color:#66d9ef">mempool_t</span> <span style="color:#f92672">*</span>pool);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mempool_resize</span>(<span style="color:#66d9ef">mempool_t</span> <span style="color:#f92672">*</span>pool, <span style="color:#66d9ef">int</span> new_min_nr, <span style="color:#66d9ef">int</span> gfp_mask);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mempool_destroy</span>(<span style="color:#66d9ef">mempool_t</span> <span style="color:#f92672">*</span>pool);
</span></span></code></pre></div><h4 id="3-get_free_page-和其友">.3. <strong>get_free_page 和其友</strong></h4>
<ul>
<li>如果一个模块需要分配大块的内存, 它常常最好是使用一个面向页的技术.</li>
<li>kmalloc 和 _get_free_pages 返回的内存地址也是虚拟地址.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">get_zeroed_page</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags);  <span style="color:#75715e">//返回一个指向新页的指针并且用零填充了该页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__get_free_page</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags);  <span style="color:#75715e">//类似于 get_zeroed_page, 但是没有清零该页.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__get_free_pages</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order); <span style="color:#75715e">//分配并返回一个指向一个内存区第一个字节的指针, 内存区可能是几个(物理上连续)页长但是没有清零.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_page</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_pages</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> order);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Here&#39;s the allocation of a single quantum */</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data[s_pos]) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    dptr<span style="color:#f92672">-&gt;</span>data[s_pos] <span style="color:#f92672">=</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">__get_free_pages</span>(GFP_KERNEL, dptr<span style="color:#f92672">-&gt;</span>order); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data[s_pos]) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> nomem; 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(dptr<span style="color:#f92672">-&gt;</span>data[s_pos], <span style="color:#ae81ff">0</span>, PAGE_SIZE <span style="color:#f92672">&lt;&lt;</span> dptr<span style="color:#f92672">-&gt;</span>order);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* This code frees a whole quantum-set */</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> qset; i<span style="color:#f92672">++</span>) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dptr<span style="color:#f92672">-&gt;</span>data[i]) 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free_pages</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)(dptr<span style="color:#f92672">-&gt;</span>data[i]), dptr<span style="color:#f92672">-&gt;</span>order);
</span></span></code></pre></div><ul>
<li>alloc_pages 接口</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// nid 是要分配内存的 NUMA 节点 ID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// flags 是通常的 GFP_ 分配标志, 以及 order 是分配的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span><span style="color:#a6e22e">alloc_pages_node</span>(<span style="color:#66d9ef">int</span> nid, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags, 
</span></span><span style="display:flex;"><span>                              <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__free_page</span>(<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__free_pages</span>(<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_hot_page</span>(<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_cold_page</span>(<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page);
</span></span></code></pre></div><ul>
<li>
<p>vmalloc：</p>
</li>
<li>
<p>调用 vmalloc 的正确时机是当你在为一个大的只存在于软件中的顺序缓冲分配内存时；</p>
</li>
<li>
<p>vamlloc 比 __get_free_pages 有更多开销, 因为它必须获取内存并且建立页表</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//虚拟内存空间分配一块连续的内存区. 尽管这些页在物理内存中不连续
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/vmalloc.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">vmalloc</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vfree</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> addr); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ioremap</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> offset, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iounmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> addr);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Allocate a quantum using virtual addresses */</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data[s_pos]) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    dptr<span style="color:#f92672">-&gt;</span>data[s_pos] <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">vmalloc</span>(PAGE_SIZE <span style="color:#f92672">&lt;&lt;</span> dptr<span style="color:#f92672">-&gt;</span>order); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dptr<span style="color:#f92672">-&gt;</span>data[s_pos]) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> nomem; 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(dptr<span style="color:#f92672">-&gt;</span>data[s_pos], <span style="color:#ae81ff">0</span>, PAGE_SIZE <span style="color:#f92672">&lt;&lt;</span> dptr<span style="color:#f92672">-&gt;</span>order);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Release the quantum-set */</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> qset; i<span style="color:#f92672">++</span>) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dptr<span style="color:#f92672">-&gt;</span>data[i]) 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vfree</span>(dptr<span style="color:#f92672">-&gt;</span>data[i]);
</span></span></code></pre></div><h4 id="4-每一cpu变量">.4. 每一CPU变量</h4>
<ul>
<li>当你创建一个每-CPU 变量, 系统中每个处理器获得它自己的这个变量拷贝.</li>
<li>内核维护无结尾的计数器来跟踪有每种报文类型有多少被接收;</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">DEFINE_PER_CPU</span>(type, name);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">DEFINE_PER_CPU</span>(<span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">3</span>], my_percpu_array);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">get_cpu_var</span>(sockets_in_use)<span style="color:#f92672">++</span>;   <span style="color:#75715e">//get_cpu_var 宏来存取当前处理器的给定变量拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">put_cpu_var</span>(sockets_in_use);  <span style="color:#75715e">//调用 put_cpu_var. 对 get_cpu_var 的调用返回一个 lvalue 给当前处理器的变量版本并且禁止抢占
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">per_cpu</span>(variable, <span style="color:#66d9ef">int</span> cpu_id); <span style="color:#75715e">//存取另一个处理器的变量拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">alloc_percpu</span>(type);   <span style="color:#75715e">//动态分配每-CPU 变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">__alloc_percpu</span>(<span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">size_t</span> align);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">per_cpu_ptr</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>per_cpu_var, <span style="color:#66d9ef">int</span> cpu_id);  <span style="color:#75715e">//宏返回一个指针指向 per_cpu_var 对应于给定 cpu_id 的版本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> cpu; 
</span></span><span style="display:flex;"><span>cpu <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_cpu</span>() 
</span></span><span style="display:flex;"><span>ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">per_cpu_ptr</span>(per_cpu_var, cpu); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* work with ptr */</span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">put_cpu</span>();
</span></span></code></pre></div><h4 id="5-获取大量缓冲">.5. 获取大量缓冲</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/bootmem.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">alloc_bootmem</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">alloc_bootmem_low</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">alloc_bootmem_pages</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">alloc_bootmem_low_pages</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size);
</span></span></code></pre></div><h3 id="8-与硬件设备通讯">8. 与硬件设备通讯</h3>
<h4 id="1-io寄存器和常用内存内存屏障">.1. IO寄存器和常用内存（内存屏障）</h4>
<ul>
<li>I/O 寄存器和 RAM 的主要不同是 I/O 操作有边际效果, 而内存操作没有</li>
<li>一个内存写的唯一效果是存储一个值到一个位置, 并且一个内存读返回最近写到那里的值.</li>
<li>编译器能够缓存数据值到 CPU 寄存器而不写到内存, 并且即便它存储它们, 读和写操作都能够在缓冲内存中进行而不接触物理 RAM</li>
<li>一个驱动必须确保<code>没有进行缓冲并且在存取寄存器时没有发生读或写的重编排</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/kernel.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">barrier</span>(<span style="color:#66d9ef">void</span>) 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//这个函数告知编译器插入一个内存屏障但是对硬件没有影响. 编译的代码将所有的当前改变的并且驻留在 CPU 寄存器的值存储到内存, 并且后来重新读取它们当需要时. 对屏障的调用阻止编译器跨越屏障的优化, 而留给硬件自由做它的重编排. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/system.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rmb</span>(<span style="color:#66d9ef">void</span>); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_barrier_depends</span>(<span style="color:#66d9ef">void</span>); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wmb</span>(<span style="color:#66d9ef">void</span>); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mb</span>(<span style="color:#66d9ef">void</span>); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//这些函数插入硬件内存屏障在编译的指令流中; 它们的实际实例是平台相关的. 一个 rmb ( read memory barrier) 保证任何出现于屏障前的读在执行任何后续读之前完成. wmb 保证写操作中的顺序, 并且 mb 指令都保证. 每个这些指令是一个屏障的超集.read_barrier_depends 是读屏障的一个特殊的, 弱些的形式. 而 rmb 阻止所有跨越屏障的读的重编排, read_barrier_depends 只阻止依赖来自其他读的数据的读的重编排.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">smp_rmb</span>(<span style="color:#66d9ef">void</span>); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">smp_read_barrier_depends</span>(<span style="color:#66d9ef">void</span>); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">smp_wmb</span>(<span style="color:#66d9ef">void</span>); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">smp_mb</span>(<span style="color:#66d9ef">void</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writel</span>(dev<span style="color:#f92672">-&gt;</span>registers.addr, io_destination_address); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writel</span>(dev<span style="color:#f92672">-&gt;</span>registers.size, io_size); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writel</span>(dev<span style="color:#f92672">-&gt;</span>registers.operation, DEV_READ); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wmb</span>(); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writel</span>(dev<span style="color:#f92672">-&gt;</span>registers.control, DEV_GO);
</span></span></code></pre></div><h4 id="2-使用io端口">.2. 使用IO端口</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//IO端口分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/ioport.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> resource <span style="color:#f92672">*</span><span style="color:#a6e22e">request_region</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> first, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n, <span style="color:#66d9ef">const</span> 
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">release_region</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">check_region</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> first, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//操作IO端口，大部分硬件区别 8-位, 16-位, 和 32-位端口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">inb</span>(<span style="color:#66d9ef">unsigned</span> port); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outb</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> byte, <span style="color:#66d9ef">unsigned</span> port); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//读或写字节端口( 8 位宽 ). port 参数定义为 unsigned long 在某些平台以及 unsigned short 在其他的上. inb 的返回类型也是跨体系而不同的. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">inw</span>(<span style="color:#66d9ef">unsigned</span> port); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outw</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> word, <span style="color:#66d9ef">unsigned</span> port); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//这些函数存取 16-位 端口( 一个字宽 ); 在为 S390 平台编译时它们不可用, 它只支持字节 I/O. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">inl</span>(<span style="color:#66d9ef">unsigned</span> port); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outl</span>(<span style="color:#66d9ef">unsigned</span> longword, <span style="color:#66d9ef">unsigned</span> port); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//这些函数存取 32-位 端口. longword 声明为或者 unsigned long 或者 unsigned int, 根据平台. 如同字 I/O, &#34;Long&#34; I/O 在 S390 上不可用.
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insb</span>(<span style="color:#66d9ef">unsigned</span> port, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outsb</span>(<span style="color:#66d9ef">unsigned</span> port, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//读或写从内存地址 addr 开始的 count 字节. 数据读自或者写入单个 port 端口. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insw</span>(<span style="color:#66d9ef">unsigned</span> port, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outsw</span>(<span style="color:#66d9ef">unsigned</span> port, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//读或写 16-位 值到一个单个 16-位 端口. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insl</span>(<span style="color:#66d9ef">unsigned</span> port, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">outsl</span>(<span style="color:#66d9ef">unsigned</span> port, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//读或写 32-位 值到一个单个 32-位 端口.
</span></span></span></code></pre></div><ul>
<li>一个数字 I/O 端口, 在它的大部分的普通的化身中, 是一个字节宽的 I/O 位置, 或者内存映射的或者端口映射的</li>
</ul>
<h4 id="3-使用io内存">.3. 使用IO内存</h4>
<ul>
<li>从 ioremap 返回的地址不应当直接解引用,这样的使用不是可移植的; 相反, 应当使用内核提供的存取函数.</li>
<li>IO 内存分配</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//I/O 内存区必须在使用前分配. 分配内存区的接口是( 在 &lt;linux/ioport.h&gt; 定义)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> resource <span style="color:#f92672">*</span><span style="color:#a6e22e">request_mem_region</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">release_mem_region</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/io.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ioremap</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> phys_addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ioremap_nocache</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> phys_addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iounmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> addr);
</span></span></code></pre></div><ul>
<li>存取IO内存</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//从 I/O 内存读
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ioread8</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ioread16</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ioread32</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//来写 I/O 内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iowrite8</span>(u8 value, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iowrite16</span>(u16 value, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iowrite32</span>(u32 value, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ioread8_rep</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ioread16_rep</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ioread32_rep</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iowrite8_rep</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iowrite16_rep</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iowrite32_rep</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memset_io</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, u8 value, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memcpy_fromio</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dest, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>source, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">memcpy_toio</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dest, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>source, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count);
</span></span></code></pre></div><ul>
<li>作为IO内存端口</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ioport_map</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> port, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count); <span style="color:#75715e">//重映射 count I/O 端口和使它们出现为 I/O 内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ioport_unmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (count<span style="color:#f92672">--</span>) { 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">iowrite8</span>(<span style="color:#f92672">*</span>ptr<span style="color:#f92672">++</span>, address); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wmb</span>(); 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="9-中断处理">9. 中断处理</h3>
<ul>
<li>一个中断不过是一个硬件在它需要处理器的注意时能够发出的信号</li>
<li>一个驱动只需要为它的设备中断注册一个处理函数, 并且当它们到来时正确处理它们</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">request_irq</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq, 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">irqreturn_t</span> (<span style="color:#f92672">*</span>handler)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>), 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>dev_name, 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dev_id); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_irq</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dev_id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (short_irq <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> <span style="color:#a6e22e">request_irq</span>(short_irq, short_interrupt, 
</span></span><span style="display:flex;"><span>                         SA_INTERRUPT, <span style="color:#e6db74">&#34;short&#34;</span>, NULL); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (result) { 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;short: can&#39;t get assigned irq %i</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
</span></span><span style="display:flex;"><span>               short_irq); 
</span></span><span style="display:flex;"><span>        short_irq <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> { <span style="color:#75715e">/* actually enable it -- assume this *is* a parallel port */</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">outb</span>(<span style="color:#ae81ff">0x10</span>,short_base<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>); 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">short_incr_bp</span>(<span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>index, <span style="color:#66d9ef">int</span> delta) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> new <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>index <span style="color:#f92672">+</span> delta; 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">barrier</span>(); <span style="color:#75715e">/* Don&#39;t optimize these two together */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>index <span style="color:#f92672">=</span> (new <span style="color:#f92672">&gt;=</span> (short_buffer <span style="color:#f92672">+</span> PAGE_SIZE)) <span style="color:#f92672">?</span> short_buffer : new; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">disable_irq</span>(<span style="color:#66d9ef">int</span> irq); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">disable_irq_nosync</span>(<span style="color:#66d9ef">int</span> irq); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">enable_irq</span>(<span style="color:#66d9ef">int</span> irq);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">local_irq_save</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">local_irq_disable</span>(<span style="color:#66d9ef">void</span>);
</span></span></code></pre></div><h4 id="1-前和后半部">.1. 前和后半部</h4>
<ul>
<li>常常大量的工作必须响应一个设备中断来完成, 但是中断处理需要很快完成并且不使中断阻塞太长.</li>
<li>前半部保存设备数据到一个设备特定的缓存, 调度它的后半部, 并且退出: 这个操作非常快. 后半部接着进行任何其他需要的工作, 例如唤醒进程, 启动另一个 I/O 操作, 等等. 这种设置允许前半部来服务一个新中断而同时后半部仍然在工作。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">DECLARE_TASKLET</span>(name, function, data); <span style="color:#75715e">//name 是给 tasklet 的名子, function 是调用来执行 tasklet (它带一个 unsigned long 参数并且返回 void )的函数, 以及 data 是一个 unsigned long 值来传递给 tasklet 函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">short_do_tasklet</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">DECLARE_TASKLET</span>(short_tasklet, short_do_tasklet, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">irqreturn_t</span> <span style="color:#a6e22e">short_tl_interrupt</span>(<span style="color:#66d9ef">int</span> irq, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dev_id, <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">do_gettimeofday</span>((<span style="color:#66d9ef">struct</span> timeval <span style="color:#f92672">*</span>) tv_head); <span style="color:#75715e">/* cast to stop &#39;volatile&#39; warning */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">short_incr_tv</span>(<span style="color:#f92672">&amp;</span>tv_head); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tasklet_schedule</span>(<span style="color:#f92672">&amp;</span>short_tasklet); 
</span></span><span style="display:flex;"><span>    short_wq_count<span style="color:#f92672">++</span>; <span style="color:#75715e">/* record that an interrupt arrived */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> IRQ_HANDLED; 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">short_do_tasklet</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> unused) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> savecount <span style="color:#f92672">=</span> short_wq_count, written; 
</span></span><span style="display:flex;"><span>    short_wq_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">/* we have already been removed from the queue */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The bottom half reads the tv array, filled by the top half, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * and prints it to the circular text buffer, which is then consumed 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * by reading processes */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* First write the number of interrupts that occurred before this bh */</span> 
</span></span><span style="display:flex;"><span>    written <span style="color:#f92672">=</span> <span style="color:#a6e22e">sprintf</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)short_head,<span style="color:#e6db74">&#34;bh after %6i</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,savecount); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">short_incr_bp</span>(<span style="color:#f92672">&amp;</span>short_head, written); 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Then, write the time values. Write exactly 16 bytes at a time, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * so it aligns with PAGE_SIZE */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> { 
</span></span><span style="display:flex;"><span>        written <span style="color:#f92672">=</span> <span style="color:#a6e22e">sprintf</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)short_head,<span style="color:#e6db74">&#34;%08u.%06u</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
</span></span><span style="display:flex;"><span>                          (<span style="color:#66d9ef">int</span>)(tv_tail<span style="color:#f92672">-&gt;</span>tv_sec <span style="color:#f92672">%</span> <span style="color:#ae81ff">100000000</span>), 
</span></span><span style="display:flex;"><span>                          (<span style="color:#66d9ef">int</span>)(tv_tail<span style="color:#f92672">-&gt;</span>tv_usec)); 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">short_incr_bp</span>(<span style="color:#f92672">&amp;</span>short_head, written); 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">short_incr_tv</span>(<span style="color:#f92672">&amp;</span>tv_tail); 
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (tv_tail <span style="color:#f92672">!=</span> tv_head); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wake_up_interruptible</span>(<span style="color:#f92672">&amp;</span>short_queue); <span style="color:#75715e">/* awake any reading process */</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">irqreturn_t</span> <span style="color:#a6e22e">short_wq_interrupt</span>(<span style="color:#66d9ef">int</span> irq, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dev_id, <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Grab the current time information. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">do_gettimeofday</span>((<span style="color:#66d9ef">struct</span> timeval <span style="color:#f92672">*</span>) tv_head); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">short_incr_tv</span>(<span style="color:#f92672">&amp;</span>tv_head); 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Queue the bh. Don&#39;t worry about multiple enqueueing */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">schedule_work</span>(<span style="color:#f92672">&amp;</span>short_wq); 
</span></span><span style="display:flex;"><span>    short_wq_count<span style="color:#f92672">++</span>; <span style="color:#75715e">/* record that an interrupt arrived */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> IRQ_HANDLED; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>运行处理者</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">irqreturn_t</span> <span style="color:#a6e22e">short_sh_interrupt</span>(<span style="color:#66d9ef">int</span> irq, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dev_id, <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs) 
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> value, written; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> timeval tv; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* If it wasn&#39;t short, return immediately */</span> 
</span></span><span style="display:flex;"><span>    value <span style="color:#f92672">=</span> <span style="color:#a6e22e">inb</span>(short_base); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(value <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x80</span>)) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> IRQ_NONE; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* clear the interrupting bit */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outb</span>(value <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x7F</span>, short_base); 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* the rest is unchanged */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">do_gettimeofday</span>(<span style="color:#f92672">&amp;</span>tv); 
</span></span><span style="display:flex;"><span>    written <span style="color:#f92672">=</span> <span style="color:#a6e22e">sprintf</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)short_head,<span style="color:#e6db74">&#34;%08u.%06u</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
</span></span><span style="display:flex;"><span>                      (<span style="color:#66d9ef">int</span>)(tv.tv_sec <span style="color:#f92672">%</span> <span style="color:#ae81ff">100000000</span>), (<span style="color:#66d9ef">int</span>)(tv.tv_usec)); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">short_incr_bp</span>(<span style="color:#f92672">&amp;</span>short_head, written); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wake_up_interruptible</span>(<span style="color:#f92672">&amp;</span>short_queue); <span style="color:#75715e">/* awake any reading process */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> IRQ_HANDLED; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="10-标准c类型使用移植问题">10. 标准C类型使用&amp;移植问题</h3>
<ul>
<li>不同平台上C语言基本类型大小不一致</li>
</ul>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221112094746900.png"
    data-srcset="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221112094746900.png, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221112094746900.png 1.5x, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221112094746900.png 2x"
    data-sizes="auto"
    alt="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221112094746900.png"
    title="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20221112094746900.png"/></p>
<ul>
<li>时间间隔：不要假定每秒有 1000 个嘀哒. 尽管当前对 i386 体系是真实的, 不是每个 Linux 平台都以这个速度运行.</li>
<li>页大小： 记住一个内存页是 PAGE_SIZE 字节, 不是 4KB. 被支持的平台显示页大小从 4 KB 到 64 KB, 并且有时它们在相同平台上的不同的实现上不同</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/page.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> order <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_order</span>(<span style="color:#ae81ff">16</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1024</span>); 
</span></span><span style="display:flex;"><span>buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_free_pages</span>(GFP_KERNEL, order);
</span></span></code></pre></div><ul>
<li>字节序： 依赖处理器的字节序</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>u32 <span style="color:#a6e22e">cpu_to_le32</span> (u32); 
</span></span><span style="display:flex;"><span>u32 <span style="color:#a6e22e">le32_to_cpu</span> (u32);
</span></span></code></pre></div><ul>
<li>数据对齐： 编写可移植代码而值得考虑的最后一个问题是如何存取不对齐的数据</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/unaligned.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">get_unaligned</span>(ptr); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">put_unaligned</span>(val, ptr);
</span></span></code></pre></div><ul>
<li>指针&amp;错误值</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ERR_PTR</span>(<span style="color:#66d9ef">long</span> error);  <span style="color:#75715e">//个返回指针类型的函数可以返回一个错误值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">IS_ERR</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr); <span style="color:#75715e">//IS_ERR 来测试是否一个返回的指针是不是一个错误码
</span></span></span></code></pre></div><ul>
<li>dpdk 里面无锁队列&amp;环形链表  todo？</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/list.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">list_add</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>new, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>head); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_add_tail</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>new, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>head); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_del</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>entry); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_del_init</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>entry); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_empty</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>head); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_entry</span>(entry, type, member); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_move</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>entry, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>head); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_move_tail</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>entry, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>head); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_splice</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_for_each</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>cursor, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>list) 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_for_each_prev</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>cursor, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>list) 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_for_each_safe</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>cursor, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>next, <span style="color:#66d9ef">struct</span> 
</span></span><span style="display:flex;"><span>list_head <span style="color:#f92672">*</span>list) 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_for_each_entry</span>(type <span style="color:#f92672">*</span>cursor, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>list, member) 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">list_for_each_entry_safe</span>(type <span style="color:#f92672">*</span>cursor, type <span style="color:#f92672">*</span>next <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>list, 
</span></span><span style="display:flex;"><span>member)
</span></span></code></pre></div><h3 id="11-pci-驱动-todo">11. PCI 驱动 todo</h3>
</div>
<div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title=2023-09-28&#32;23:04:34>更新于 2023-09-28&nbsp;</span>
      </div><div class="post-info-license">
          <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
        </div></div>
    <div class="post-info-line">
      <div class="post-info-md"><span><a href="/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/index.md" title="阅读原始文档" class="link-to-markdown">阅读原始文档</a></span><span><a href="https://liudongdong1.github.io/edit/master/content/posts%5cLinux%5cLinux%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8.md" title="编辑此页"target="_blank" rel="external nofollow noopener noreferrer" class="link-to-edit">编辑此页</a></span></div>
      <div class="post-info-share">
        <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://liudongdong1.github.io/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" data-title="Linux Operation" data-hashtags="Linux,Embed"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://liudongdong1.github.io/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" data-hashtag="Linux"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://liudongdong1.github.io/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" data-title="Linux Operation" data-image="https://gitee.com/github-25970295/blogImage/raw/master/img/petal-5044428.png"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/linux/">Linux</a>,&nbsp;<a href="/tags/embed/">Embed</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%8C%91%E6%88%98/" class="prev" rel="prev" title="数据密集型应用系统设计笔记-分布式系统挑战"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>数据密集型应用系统设计笔记-分布式系统挑战</a>
      <a href="/makefile/" class="next" rel="next" title="Makefile">Makefile<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.118.2">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.2.17-RC"><img class="fixit-icon" src="/fixit.min.svg" alt="FixIt logo" />&nbsp;FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2020 - 2023</span><span class="author" itemprop="copyrightHolder">
              <a href="https://liudongdong1.github.io/"target="_blank" rel="external nofollow noopener noreferrer">LiuDongdong</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class="site-time" title='网站运行中 ...'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden="true"></i>&nbsp;<span class="run-times">网站运行中 ...</span></span></div><div class="footer-line ibruce">
          <span id="busuanzi_container_site_uv" title='总访客数'><i class="fa-regular fa-user fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span><span id="busuanzi_container_site_pv" class="footer-divider" title='总访问量'><i class="fa-regular fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span>
        </div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric">0%</span>
        </div></div><a href="https://liudongdong1.github.io/" title="在 GitHub 上查看源代码"target="_blank" rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;--bg-progress: #0076ff;--bg-progress-dark: #fff;"></div><noscript>
    <div class="noscript-warning">FixIt 主题在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/algoliasearch/algoliasearch-lite.umd.min.js" defer></script><script src="/lib/lazysizes/lazysizes.min.js" async defer></script><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/typeit/index.umd.js" defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="/lib/pangu/pangu.min.js" defer></script><script src="/lib/cell-watermark/watermark.min.js" defer></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":10},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"data":{"typeit-header-subtitle-desktop":"\u003cspan style='font-family: MMT,\"沐目体\";'\u003e吾日三省吾身\u003c/span\u003e","typeit-header-subtitle-mobile":"\u003cspan style='font-family: MMT,\"沐目体\";'\u003e吾日三省吾身\u003c/span\u003e"},"enablePWA":true,"enablePangu":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"2R1K9SKLQZ","algoliaIndex":"index.zh-cn","algoliaSearchKey":"4a226aa1c5c98d6859e4d1386adb2bc7","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"siteTime":"2020-12-18T16:15:22+08:00","typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"typeit-header-subtitle-desktop":["typeit-header-subtitle-desktop"],"typeit-header-subtitle-mobile":["typeit-header-subtitle-mobile"]},"duration":-1,"speed":100},"watermark":{"appendto":".wrapper\u003emain","colspacing":30,"content":"\u003cimg class=\"fixit-icon\" src=\"/fixit.min.svg\" alt=\"FixIt logo\" /\u003e FixIt 主题","enable":true,"fontfamily":"inherit","fontsize":0.85,"height":21,"opacity":0.0125,"rotate":15,"rowspacing":60,"width":150}};</script><script src="/js/theme.min.js" defer></script><script src="/js/custom.min.js" defer></script></body>
</html>
