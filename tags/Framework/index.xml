<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>Framework - 标签 - DAY By DAY</title>
    <link>liudongdong1.github.io/tags/framework/</link>
    <description>Framework - 标签 - DAY By DAY</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>3463264078@qq.cn (LiuDongdong)</managingEditor>
      <webMaster>3463264078@qq.cn (LiuDongdong)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 31 Jul 2022 16:00:04 &#43;0000</lastBuildDate><atom:link href="liudongdong1.github.io/tags/framework/" rel="self" type="application/rss+xml" /><item>
  <title>开源项目-Margo</title>
  <link>liudongdong1.github.io/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-margo/</link>
  <pubDate>Sun, 31 Jul 2022 16:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-margo/</guid>
  <description><![CDATA[Argobots pools with Margo RPCs #include &lt;assert.h&gt; #include &lt;stdio.h&gt; #include &lt;margo.h&gt; #include &lt;alpha-server.h&gt; static void finalize_xstream_cb(void* data); int main(int argc, char** argv) { margo_instance_id mid = margo_init(&#34;tcp&#34;, MARGO_SERVER_MODE, 0, 0); assert(mid); margo_set_log_level(mid, MARGO_LOG_INFO); hg_addr_t my_address; margo_addr_self(mid, &amp;my_address); char addr_str[128]; size_t addr_str_size = 128; margo_addr_to_string(mid, addr_str, &amp;addr_str_size, my_address); margo_addr_free(mid,my_address); margo_info(mid, &#34;Server running at address %s, with provider id 42&#34;, addr_str); ABT_pool pool; ABT_pool_create_basic( ABT_POOL_FIFO, ABT_POOL_ACCESS_SPSC, ABT_TRUE, &amp;pool); ABT_xstream xstream; ABT_xstream_create_basic( ABT_SCHED_DEFAULT,]]></description>
</item>
<item>
  <title>SPDK存储引擎-Blobstore&amp;BlobFs</title>
  <link>liudongdong1.github.io/spdk%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-blobstoreblobfs/</link>
  <pubDate>Sat, 30 Jul 2022 16:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/spdk%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-blobstoreblobfs/</guid>
  <description><![CDATA[Blobstore是位于SPDK bdev之上的Blob管理层，用于与用户态文件系统Blobstore Filesystem （BlobFS）集成，从而代替传统的文]]></description>
</item>
<item>
  <title>rpc框架-mercury</title>
  <link>liudongdong1.github.io/rpc%E6%A1%86%E6%9E%B6_mercury/</link>
  <pubDate>Mon, 25 Jul 2022 20:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/rpc%E6%A1%86%E6%9E%B6_mercury/</guid>
  <description><![CDATA[Mercury is a Remote Procedure Call (RPC) framework specifically designed for use in High-Performance Computing (HPC) systems with high-performance fabrics. Objective &amp; comparision Objective: Create a reusable RPC libraryfor use in HPC that can serve as a basis for services such as storage systems, I/O forwarding, analysis frameworks and other forms of inter-application communication 优势： takes advantage of low-level HPC network fabrics and facilitates the development of user-level]]></description>
</item>
<item>
  <title>argobots</title>
  <link>liudongdong1.github.io/argobots/</link>
  <pubDate>Sat, 23 Jul 2022 16:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/argobots/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://gitee.com/github-25970295/blogImage/raw/master/img/30.jpeg" referrerpolicy="no-referrer">
      </div>Condition Variable: a condition on which ULTs are waiting until it is signaled. Execution Stream (ES): a sequential instruction stream that contains one or more work units. Future: a mechanism for passing a value between work units, allowing a work unit to wait for a value that is set asynchronously. Handle: an opaque reference to an Argobots object. Mutex: a synchronization method to support mutual exclusion between work units. Object:]]></description>
</item>
<item>
  <title>argobots</title>
  <link>liudongdong1.github.io/argobots_paper/</link>
  <pubDate>Sat, 23 Jul 2022 16:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/argobots_paper/</guid>
  <description><![CDATA[Paper: argobots SM1 in ES1 has one associated private pool, PM11, and SM2 in ES2 has two private pools, PM21 and PM22. PS is shared between ES1 and ES2, and thus both SM1 in ES1 and SM2 in ES2 can access the pool to push or pop work units. PE denotes an event pool. The event pool is meant for lightweight notification. It is periodically checked by a scheduler to]]></description>
</item>
<item>
  <title>PMDK-libpmemlog教程</title>
  <link>liudongdong1.github.io/pmdk-libpmemlog%E6%A1%88%E4%BE%8B/</link>
  <pubDate>Thu, 30 Jun 2022 19:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/pmdk-libpmemlog%E6%A1%88%E4%BE%8B/</guid>
  <description><![CDATA[pmemlog_create() // 创建持久化的log内存 pmemlog_open() // 打开已创建的log内存 pmemlog_nbyte() // 获得某log内存内可以添加多少位的数据，而非多少条记录 pmemlog_append() // 向log内存中append]]></description>
</item>
<item>
  <title>PMDK-libpmemobj教程</title>
  <link>liudongdong1.github.io/pmdk-libpmemobj%E6%95%99%E7%A8%8B/</link>
  <pubDate>Thu, 30 Jun 2022 19:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/pmdk-libpmemobj%E6%95%99%E7%A8%8B/</guid>
  <description><![CDATA[Write &amp;Read PMEMobjpool pmemobj_create() // 创建持久化内存池 PMEMobjpool pmemobj_open() // 打开已创建的持久化内存池 PMEMoid pmemobj_root() // 得到持久化内存池的根节点 pmemobj_direct() // 得到根节点的指针 pmemobj_persist() // 将单变量进行持久化存储 pmemobj_memcpy_persist() // 将数]]></description>
</item>
<item>
  <title>RPC 框架的可靠性设计</title>
  <link>liudongdong1.github.io/rpc-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/</link>
  <pubDate>Sat, 25 Jun 2022 20:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/rpc-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/</guid>
  <description><![CDATA[https://www.infoq.cn/article/bzekar1wxqg-2dpare9o 1. 背景 1.1 分布式调用引入的故障 在传统的单体架构中，业务服务调用都是本地方法调用，不会涉及到网络通信、协议栈、消息序列化和反序列化等，当使用 RPC]]></description>
</item>
<item>
  <title>SPDK_IO 流程</title>
  <link>liudongdong1.github.io/spdk-io%E6%B5%81%E7%A8%8B/</link>
  <pubDate>Sun, 29 May 2022 20:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/spdk-io%E6%B5%81%E7%A8%8B/</guid>
  <description><![CDATA[首先，从虚拟机视角来说，它看到的是一个virtio-blk-pci设备，该pci设备内部包含一条virtio总线，其上又连接了virtio-]]></description>
</item>
<item>
  <title>SPDK_IO栈&amp;线程对比</title>
  <link>liudongdong1.github.io/spdk-io%E6%A0%88%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94/</link>
  <pubDate>Sun, 29 May 2022 16:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/spdk-io%E6%A0%88%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94/</guid>
  <description><![CDATA[IO栈对比 无论使用传统内核NVMe驱动，还是使用vhost，虚拟机内部的IO处理流程都是一样的：IO请求下发时需要从用户态应用程序中切换到内]]></description>
</item>
</channel>
</rss>
