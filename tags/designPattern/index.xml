<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>DesignPattern - 标签 - DAY By DAY</title>
    <link>liudongdong1.github.io/tags/designpattern/</link>
    <description>DesignPattern - 标签 - DAY By DAY</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>3463264078@qq.cn (LiuDongdong)</managingEditor>
      <webMaster>3463264078@qq.cn (LiuDongdong)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 15 Aug 2021 23:31:56 &#43;0000</lastBuildDate><atom:link href="liudongdong1.github.io/tags/designpattern/" rel="self" type="application/rss+xml" /><item>
  <title>微服务5种设计</title>
  <link>liudongdong1.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A15%E7%A7%8D%E8%AE%BE%E8%AE%A1/</link>
  <pubDate>Sun, 15 Aug 2021 23:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A15%E7%A7%8D%E8%AE%BE%E8%AE%A1/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.stocksnap.io/img-thumbs/280h/wheat-field_I10ZDYCG1P.jpg" referrerpolicy="no-referrer">
      </div>整个应用程序被拆分成相互独立但包含多个内部模块的子进程。 与模块化的单体应用（Modular Monoliths）或 SOA 相反，微服务应用程序根据业]]></description>
</item>
<item>
  <title>CompositeMode</title>
  <link>liudongdong1.github.io/compositemode/</link>
  <pubDate>Mon, 05 Jul 2021 11:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/compositemode/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://gitee.com/github-25970295/blogImage/raw/master/img/20210514222616.png" referrerpolicy="no-referrer">
      </div>组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有 &ldquo;整体—部分&rdquo; 关系的层次结构。组合模]]></description>
</item>
<item>
  <title>FlyweightMode</title>
  <link>liudongdong1.github.io/flyweightmode/</link>
  <pubDate>Sat, 03 Jul 2021 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/flyweightmode/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://gitee.com/github-25970295/blogImage/raw/master/img/20210514222616.png" referrerpolicy="no-referrer">
      </div>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求]]></description>
</item>
<item>
  <title>FactorMode</title>
  <link>liudongdong1.github.io/factormode/</link>
  <pubDate>Sun, 23 May 2021 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/factormode/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://gitee.com/github-25970295/blogImage/raw/master/img/20210514222616.png" referrerpolicy="no-referrer">
      </div>1. 工厂方法 在工厂方法模式中，抽象产品类Product负责定义产品的共性，事项对事物最抽象的定义，Creator为抽象创建类，也就是抽象工厂，]]></description>
</item>
<item>
  <title>MediatorMode</title>
  <link>liudongdong1.github.io/mediatormode/</link>
  <pubDate>Sun, 23 May 2021 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/mediatormode/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.stocksnap.io/img-thumbs/280h/purple-flowers_HFVKAB39RI.jpg" referrerpolicy="no-referrer">
      </div>提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。 中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代]]></description>
</item>
<item>
  <title>VisitorMode</title>
  <link>liudongdong1.github.io/visitormode/</link>
  <pubDate>Thu, 20 May 2021 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/visitormode/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.stocksnap.io/img-thumbs/280h/SOZ81WXDU1.jpg" referrerpolicy="no-referrer">
      </div>系统访问，同一套系统，有很多功能不同的人访问到的结果不一样，运营人员，只拥有运营相关的权限，销售只拥有有关销售相关的功能权限，财务只拥有财务]]></description>
</item>
<item>
  <title>BridgeMode</title>
  <link>liudongdong1.github.io/bridgemode/</link>
  <pubDate>Thu, 13 May 2021 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/bridgemode/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.stocksnap.io/img-thumbs/280h/RLPW5ERBK3.jpg" referrerpolicy="no-referrer">
      </div>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handl]]></description>
</item>
<item>
  <title>BuilderMode</title>
  <link>liudongdong1.github.io/buildermode/</link>
  <pubDate>Thu, 13 May 2021 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/buildermode/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://gitee.com/github-25970295/blogImage/raw/master/img/20210514222616.png" referrerpolicy="no-referrer">
      </div>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。在构建的对象需要很多配置的时候可以考虑Builder模式，可以避免]]></description>
</item>
<item>
  <title>CommandMode</title>
  <link>liudongdong1.github.io/commandmode/</link>
  <pubDate>Thu, 13 May 2021 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/commandmode/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.stocksnap.io/img-thumbs/280h/FGW3XGA04R.jpg" referrerpolicy="no-referrer">
      </div>将一个请求封装成一个对象，从而使你可用不同的请求把客户端参数化，对请求排队或者记录请求日志，以及支持可撤销和恢复操作。 系统需要将请求调用者和]]></description>
</item>
<item>
  <title>FacadeMode</title>
  <link>liudongdong1.github.io/facademode/</link>
  <pubDate>Thu, 13 May 2021 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>liudongdong1.github.io/facademode/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://gitee.com/github-25970295/blogImage/raw/master/img/20210514222616.png" referrerpolicy="no-referrer">
      </div>定义了一个高层、统一的接口，外部与通过这个统一的接口对子系统中的一群接口进行访问。通过创建一个统一的类，用来包装子系统中一个或多个复杂的类，]]></description>
</item>
</channel>
</rss>
