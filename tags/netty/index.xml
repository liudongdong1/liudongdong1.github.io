<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Netty - 标签 - DAY By DAY</title><link>liudongdong1.github.io/tags/netty/</link><description>Netty - 标签 - DAY By DAY</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>3463264078@qq.cn (LiuDongdong)</managingEditor><webMaster>3463264078@qq.cn (LiuDongdong)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 13 Oct 2021 11:56:09 +0000</lastBuildDate><atom:link href="liudongdong1.github.io/tags/netty/" rel="self" type="application/rss+xml"/><item><title>文件上传</title><link>liudongdong1.github.io/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</link><pubDate>Wed, 13 Oct 2021 11:56:09 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.stocksnap.io/img-thumbs/280h/IDMQ2QKTYR.jpg" referrerpolicy="no-referrer">
&lt;/div>构建高性能、低时延的各种 Java 中间件，例如 MQ、分布式服务框架、ESB 消息总线等，Netty 主要作为基础通信框架提供高性能、低时延的通信服务； 公</description></item><item><title>ByteBuf类</title><link>liudongdong1.github.io/bytebuf%E7%B1%BB/</link><pubDate>Mon, 11 Oct 2021 20:56:09 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/bytebuf%E7%B1%BB/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.stocksnap.io/img-thumbs/280h/SQSHKVYXVX.jpg" referrerpolicy="no-referrer">
&lt;/div>网络数据的基本单位总是字节。Java NIO 提供了ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。Netty 的B</description></item><item><title>EentLoopGroup</title><link>liudongdong1.github.io/eventloopgroup/</link><pubDate>Sat, 09 Oct 2021 11:56:09 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/eventloopgroup/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.stocksnap.io/img-thumbs/280h/8YJQ4BERC1.jpg" referrerpolicy="no-referrer">
&lt;/div>学习链接： https://juejin.cn/post/6999225608341291039#heading-6 还是得通过实战，自己来读一下代码，了解背后的实现机制。 1. Unsafe .1. Java JDK .2.netty Unsafe接口中定义了socket相关操作，包括Socket</description></item><item><title>Reactor模型</title><link>liudongdong1.github.io/reactor%E6%A8%A1%E5%9E%8B/</link><pubDate>Sun, 19 Sep 2021 11:56:09 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/reactor%E6%A8%A1%E5%9E%8B/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.stocksnap.io/img-thumbs/280h/H7IYNGONCI.jpg" referrerpolicy="no-referrer">
&lt;/div>同步的等待多个事件源到达（采用select()实现） 将事件多路分解以及分配相应的事件服务进行处理，这个分派采用server集中处理（disp</description></item><item><title>HTTP 服务</title><link>liudongdong1.github.io/http%E6%9C%8D%E5%8A%A1/</link><pubDate>Thu, 19 Aug 2021 07:56:09 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/http%E6%9C%8D%E5%8A%A1/</guid><description><![CDATA[<div class="featured-image">
        <img src="https://cdn.stocksnap.io/img-thumbs/280h/4PG8IOID4P.jpg" referrerpolicy="no-referrer">
      </div>1. NettyHTTP编解码器 public class HttpHelloWorldServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; { @Override public void initChannel(SocketChannel ch) { ChannelPipeline p = ch.pipeline(); /** * 或者使用HttpRequestDecoder &amp; HttpResponseEncoder *HttpRequestDecoder 即把 ByteBuf 解码到 HttpRequest 和 HttpC]]></description></item><item><title>netty component</title><link>liudongdong1.github.io/netty-component/</link><pubDate>Thu, 19 Aug 2021 07:56:09 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/netty-component/</guid><description><![CDATA[<div class="featured-image">
        <img src="https://cdn.stocksnap.io/img-thumbs/280h/EGNLM82WFY.jpg" referrerpolicy="no-referrer">
      </div>1. Netty 事件相应机制 public class NettyServer { private final int port; public NettyServer(int port) { this.port = port; } public static void main(String[] args) throws InterruptedException { int port = 9999; NettyServer echoServer = new NettyServer(port); System.out.println(&#34;服务器启动]]></description></item><item><title>telnet helloworld</title><link>liudongdong1.github.io/telnet-helloworld/</link><pubDate>Thu, 19 Aug 2021 07:56:09 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/telnet-helloworld/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.stocksnap.io/img-thumbs/280h/DPPD8ZTWJK.jpg" referrerpolicy="no-referrer">
&lt;/div>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。是一个NIO客户端服务器框架，可以快速轻松地开</description></item><item><title>EncoderDecoder</title><link>liudongdong1.github.io/encoderdecoder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/encoderdecoder/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.stocksnap.io/img-thumbs/280h/NG5BF9YWT1.jpg" referrerpolicy="no-referrer">
&lt;/div>1. 解码器 解码器是负责将入站数据从一种格式转换到另一种格式的，所以Netty 的解码器实现了ChannelInboundHandler。 .1. ByteToMessageDecoder 由于</description></item><item><title>粘包拆包</title><link>liudongdong1.github.io/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.stocksnap.io/img-thumbs/280h/95FPGAVFXJ.jpg" referrerpolicy="no-referrer">
&lt;/div>发送端为了将多个发给接收端的数据包，更有效地发送到接收端，会使用Nagle算法。Nagle算法会将多次时间间隔较小且数据量小的数据合并成一个</description></item></channel></rss>