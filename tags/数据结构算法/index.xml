<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>数据结构&amp;算法 - 标签 - DAY By DAY</title><link>liudongdong1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/</link><description>数据结构&amp;算法 - 标签 - DAY By DAY</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>3463264078@qq.cn (LiuDongdong)</managingEditor><webMaster>3463264078@qq.cn (LiuDongdong)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 13 Jul 2022 21:31:56 +0000</lastBuildDate><atom:link href="liudongdong1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml"/><item><title>存储结构--LSM树</title><link>liudongdong1.github.io/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84--lsm%E6%A0%91/</link><pubDate>Wed, 13 Jul 2022 21:31:56 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84--lsm%E6%A0%91/</guid><description>LSM树并不像B+树、红黑树一样是一颗严格的树状数据结构，它其实是一种存储结构，目前HBase,LevelDB,RocksDB这些NoSQL</description></item><item><title>DFS &amp; BFS系列</title><link>liudongdong1.github.io/dfs-bfs%E7%B3%BB%E5%88%97/</link><pubDate>Sat, 14 May 2022 21:31:56 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/dfs-bfs%E7%B3%BB%E5%88%97/</guid><description>1. 寻找重复的子树 1 / \ 2 3 / \ 4 5 例如上面这棵树序列化结果为 1,2,#,#,3,4,#,#,5,#,#。每棵不同子树的序列化结果都是唯一的。</description></item><item><title>几何类</title><link>liudongdong1.github.io/%E5%87%A0%E4%BD%95%E7%B1%BB/</link><pubDate>Tue, 10 May 2022 21:31:56 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/%E5%87%A0%E4%BD%95%E7%B1%BB/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.pixabay.com/photo/2022/02/25/22/59/pestle-7034940__340.jpg" referrerpolicy="no-referrer">
&lt;/div>1. 直线上最多的点数 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。先枚举两条点（确定一条线），然后检查其余</description></item><item><title>数组系列C++</title><link>liudongdong1.github.io/%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97c-/</link><pubDate>Sun, 10 Apr 2022 21:31:56 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97c-/</guid><description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2020/07/04/20/12/green-lizard-5370821__340.jpg" referrerpolicy="no-referrer">
      </div>1. Remove Duplicates from Sorted Array int removeDuplicates(vector&lt;int&gt;&amp; nums){ if(nums.empty()){ return 0; } int index=0; for(int i=1;i&lt;nums.size();i++){ if(nums[i]!=nums[index]){ nums[++index]=nums[i]; } } return index+1; } //STL return distance(nums.begin(),unique(nums.begin(),nums.end()); 2. Remove Duplicates from Sorted Array 2 int removeDuplicates(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt;= 2) return nums.size(); int index = 2; for (int i = 2; i &lt; nums.size(); i++){ if (nums[i] != nums[index - 2]) nums[index++] = nums[i]; } return index; }]]></description></item><item><title>ACM模式输入</title><link>liudongdong1.github.io/acm%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5/</link><pubDate>Sun, 13 Mar 2022 21:31:56 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/acm%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.pixabay.com/photo/2015/07/28/22/12/autumn-865157__340.jpg" referrerpolicy="no-referrer">
&lt;/div>Scanner 类是获取键盘输入的一个类，首先先创建 Scanner 对象Scanner sc = new Scanner(System.in); next() 方法：只能读取到空格之前的字符串； nextLine(): 可以读取空格的字符串, 表示第一行; 使</description></item><item><title>背包问题</title><link>liudongdong1.github.io/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link><pubDate>Thu, 10 Mar 2022 23:31:56 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.pixabay.com/photo/2022/02/22/17/25/stork-7029266__340.jpg" referrerpolicy="no-referrer">
&lt;/div>1. 01 背包问题 有 n 种物品，第 i 个物品的体积为 vi，价格为 wi，有一个体积限制 v，每种物品有一个，可以选或者不选 .1. 最值问题（最大或者最小值） 你有</description></item><item><title>位运算</title><link>liudongdong1.github.io/%E4%BD%8D%E8%BF%90%E7%AE%97/</link><pubDate>Thu, 10 Mar 2022 21:31:56 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/%E4%BD%8D%E8%BF%90%E7%AE%97/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.pixabay.com/photo/2021/11/15/21/39/rose-6799477__340.jpg" referrerpolicy="no-referrer">
&lt;/div>1. 数组中重复的数据 给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数</description></item><item><title>数组类</title><link>liudongdong1.github.io/%E6%95%B0%E7%BB%84%E7%B1%BB/</link><pubDate>Wed, 09 Mar 2022 21:31:56 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/%E6%95%B0%E7%BB%84%E7%B1%BB/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.pixabay.com/photo/2022/02/23/17/08/planets-7031048__340.jpg" referrerpolicy="no-referrer">
&lt;/div>1. 多数元素 public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length / 2]; } 2.递增的三元子序列 给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标</description></item><item><title>Arrays工具</title><link>liudongdong1.github.io/arrays%E5%B7%A5%E5%85%B7/</link><pubDate>Tue, 01 Mar 2022 21:31:56 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/arrays%E5%B7%A5%E5%85%B7/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.pixabay.com/photo/2022/03/08/13/42/flower-7055775__340.jpg" referrerpolicy="no-referrer">
&lt;/div>JDK 提供的 java.util.Arrays 类，包含了常用的数组操作。Arrays 类包含了：排序、查找、填充、打印内容等常见的操作。 1.Arrays.toString () 打印数组 public static void main(String args[]) { int[] a = { 1, 2 }; System.out.println(a); //</description></item><item><title>区间问题</title><link>liudongdong1.github.io/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 28 Feb 2022 22:31:56 +0000</pubDate><author>liudongdong1</author><guid>liudongdong1.github.io/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.pixabay.com/photo/2022/02/19/07/17/tree-blossoms-7022041__340.jpg" referrerpolicy="no-referrer">
&lt;/div>1. 区间合并问题 56 给出一堆区间，要求合并所有有交集的区间 （端点处相交也算有交集）。最后问合并之后的区间个数。 按照区间左端点从小到大排序: 维护前</description></item></channel></rss>