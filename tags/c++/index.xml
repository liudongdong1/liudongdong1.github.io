<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>C&#43;&#43; - 标签 - DAY By DAY</title>
    <link>https://liudongdong1.github.io/tags/c&#43;&#43;/</link>
    <description>C&#43;&#43; - 标签 - DAY By DAY</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>3463264078@qq.cn (LiuDongdong)</managingEditor>
      <webMaster>3463264078@qq.cn (LiuDongdong)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 10 May 2022 21:31:56 &#43;0000</lastBuildDate><atom:link href="https://liudongdong1.github.io/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
  <title>几何类</title>
  <link>https://liudongdong1.github.io/%E5%87%A0%E4%BD%95%E7%B1%BB/</link>
  <pubDate>Tue, 10 May 2022 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/%E5%87%A0%E4%BD%95%E7%B1%BB/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/02/25/22/59/pestle-7034940__340.jpg" referrerpolicy="no-referrer">
      </div>1. 直线上最多的点数 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。先枚举两条点（确定一条线），然后检查其余]]></description>
</item>
<item>
  <title>STL关联式容器-hashset</title>
  <link>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashset/</link>
  <pubDate>Fri, 15 Apr 2022 23:10:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashset/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/04/07/02/56/cottontail-rabbit-7116707__340.jpg" referrerpolicy="no-referrer">
      </div>STL 只规范复杂度与接口，并不规范实现方法，但是STL set多半以RB-tree为底层实现机制，SGI则是STL标准规定之外另又提供了一个所谓的]]></description>
</item>
<item>
  <title>STL关联式容器-hashtable</title>
  <link>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/</link>
  <pubDate>Thu, 14 Apr 2022 23:10:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/04/02/13/43/music-7107045__340.jpg" referrerpolicy="no-referrer">
      </div>1. 哈希冲突 .1. 线性探测 根据元素的值然后除以数组大小，然后插入指定的位置 .2. 二次探测 F(i)=i*i; 如果新元素起始插入位置为H，但是H已经被占用，则会尝试H+i]]></description>
</item>
<item>
  <title>STL关联式容器-hashmap</title>
  <link>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashmap/</link>
  <pubDate>Thu, 14 Apr 2022 20:10:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashmap/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2019/11/25/06/21/leaf-4651088__340.jpg" referrerpolicy="no-referrer">
      </div>hash_multimap 与 hash_map 使用起来相同，只是 hash_multimap 中允许键值重复 在源码中，hash_multimap 调用的是 insert_equal ()，而 hash_map 调用的是 insert_unique ()。 1. 数据结构 class hash_map { private: typedef hashtable&lt;pair&lt;const Key, T&gt;, Key,]]></description>
</item>
<item>
  <title>STL关联式容器-set</title>
  <link>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/</link>
  <pubDate>Tue, 12 Apr 2022 23:10:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-set/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2021/07/01/15/07/duckling-6379617__340.jpg" referrerpolicy="no-referrer">
      </div>所有元素根据键值自动排序，键值就是实值,实值就是键值，不允许重复键值。不可通过迭代器改变 set 元素值，是一种 constant iterators 与 list 相同，当客户端对它进行元素新]]></description>
</item>
<item>
  <title>string 函数</title>
  <link>https://liudongdong1.github.io/string%E5%87%BD%E6%95%B0/</link>
  <pubDate>Tue, 12 Apr 2022 16:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/string%E5%87%BD%E6%95%B0/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/01/21/15/32/subway-6955069__340.jpg" referrerpolicy="no-referrer">
      </div>字符串分布&amp;内存分配 https://www.jianshu.com/p/6469fad4d5d5 来自 #include &lt;stdio.h&gt; char *g=&#34;Hello&#34;; int main(int argc, char const *argv[]) { char s[]=&#34;Hello&#34;; char *c=&#34;Hello&#34;; printf(&#34;字符指针c的内存地址:%p\n&#34;,&amp;]]></description>
</item>
<item>
  <title>STL配接器</title>
  <link>https://liudongdong1.github.io/stl%E9%85%8D%E6%8E%A5%E5%99%A8/</link>
  <pubDate>Tue, 12 Apr 2022 12:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E9%85%8D%E6%8E%A5%E5%99%A8/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/04/04/14/40/flower-7111468__340.jpg" referrerpolicy="no-referrer">
      </div>配接器（Adapter）在 STL 组件的灵活组合运用功能上，扮演着轴承、转换器的角色，即将一个 class 的接口转换为另一个 class 的接口，使原本因接口不兼容而不]]></description>
</item>
<item>
  <title>STL仿函数</title>
  <link>https://liudongdong1.github.io/stl%E4%BB%BF%E5%87%BD%E6%95%B0/</link>
  <pubDate>Tue, 12 Apr 2022 09:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E4%BB%BF%E5%87%BD%E6%95%B0/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/04/08/06/36/rock-7118843__340.jpg" referrerpolicy="no-referrer">
      </div>所谓的仿函数 (functor)，是通过重载 () 运算符模拟函数形为的类。因此，这里需要明确两点： 仿函数不是函数，它是个类； 仿函数重载了 () 运算符，]]></description>
</item>
<item>
  <title>STL关联式容器-RB-tree</title>
  <link>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-rb-tree/</link>
  <pubDate>Mon, 11 Apr 2022 23:10:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-rb-tree/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/01/20/07/56/polar-bear-6951677__340.jpg" referrerpolicy="no-referrer">
      </div>左旋： 对节点 X 进行左旋，也就说让节点 X 成为左节点。 右旋： 对节点 X 进行右旋，也就说让节点 X 成为右节点。 1. 单旋转&amp;双旋转 2. RB-Tree 3. 节点插入 S]]></description>
</item>
<item>
  <title>STL序列容器-slist</title>
  <link>https://liudongdong1.github.io/stl%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8-slist/</link>
  <pubDate>Mon, 11 Apr 2022 23:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8-slist/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2021/11/11/09/12/lighthouse-6785763__340.jpg" referrerpolicy="no-referrer">
      </div>slist：迭代器属于单向的 Forward Iterator（可读写）。 list ：迭代器属于双向的 Bidirectional Iterator（可以双向读写）。 看起来 slist 的功能应该会不如 l]]></description>
</item>
</channel>
</rss>
