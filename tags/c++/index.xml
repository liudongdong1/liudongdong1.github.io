<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>C&#43;&#43; - 标签 - DAY By DAY</title>
    <link>https://liudongdong1.github.io/tags/c&#43;&#43;/</link>
    <description>C&#43;&#43; - 标签 - DAY By DAY</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>3463264078@qq.cn (LiuDongdong)</managingEditor>
      <webMaster>3463264078@qq.cn (LiuDongdong)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 10 May 2022 21:31:56 &#43;0000</lastBuildDate><atom:link href="https://liudongdong1.github.io/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
  <title>几何类</title>
  <link>https://liudongdong1.github.io/%E5%87%A0%E4%BD%95%E7%B1%BB/</link>
  <pubDate>Tue, 10 May 2022 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/%E5%87%A0%E4%BD%95%E7%B1%BB/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/02/25/22/59/pestle-7034940__340.jpg" referrerpolicy="no-referrer">
      </div>1. 直线上最多的点数 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。先枚举两条点（确定一条线），然后检查其余]]></description>
</item>
<item>
  <title>STL概述</title>
  <link>https://liudongdong1.github.io/stl%E6%A6%82%E8%BF%B0/</link>
  <pubDate>Wed, 06 Apr 2022 22:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E6%A6%82%E8%BF%B0/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/04/09/17/30/coffee-7121939__340.jpg" referrerpolicy="no-referrer">
      </div>STL(Standard Template Library，标准模板库)，是惠普实验室开发的一系列软件的统称。现主要出现在 C++ 中，STL 从广义上分为：容器 (container)、算法]]></description>
</item>
<item>
  <title>面经_C&#43;&#43;</title>
  <link>https://liudongdong1.github.io/%E9%9D%A2%E7%BB%8F_c-/</link>
  <pubDate>Thu, 24 Mar 2022 08:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/%E9%9D%A2%E7%BB%8F_c-/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2016/02/21/18/09/iceland-1214063__340.jpg" referrerpolicy="no-referrer">
      </div>.1. 构造函数和析构函数 C++ 中构造函数和析构函数只会在编译阶段运行一次，无论你定义了多少不同的构造函数，在一般情况下只会让编译器选择其中一个进行执]]></description>
</item>
<item>
  <title>C&#43;&#43;基础</title>
  <link>https://liudongdong1.github.io/c-%E5%9F%BA%E7%A1%80/</link>
  <pubDate>Sun, 13 Feb 2022 16:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/c-%E5%9F%BA%E7%A1%80/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/02/19/07/17/tree-blossoms-7022041__340.jpg" referrerpolicy="no-referrer">
      </div>旧的 C++ 头文件，如 iostream.h、fstream.h 等将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在命名空间 std 中。 新的 C++ 头]]></description>
</item>
<item>
  <title>C&#43;&#43;智能指针</title>
  <link>https://liudongdong1.github.io/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
  <pubDate>Thu, 20 Jan 2022 16:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/02/12/19/58/cat-7009836__340.jpg" referrerpolicy="no-referrer">
      </div>C++98 中引入 auto_ptr，但是实现有缺陷 (使用 copy 语义转移资源)，现已弃用，在实际项目中不应该使用。本文提到的三种智能指针主要指的得是 std:]]></description>
</item>
<item>
  <title>C&#43;&#43;</title>
  <link>https://liudongdong1.github.io/%E4%BC%98%E7%82%B9%E6%9D%82%E8%B0%88/</link>
  <pubDate>Thu, 13 Jan 2022 16:00:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/%E4%BC%98%E7%82%B9%E6%9D%82%E8%B0%88/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2021/12/17/17/00/butterfly-6876992__340.jpg" referrerpolicy="no-referrer">
      </div>C++具有某些现代语言的特征，同时又有传统语言（比如C）接近的效率，使其对运行效率和开发效率做了很好的折衷，这也是它在超大型项目中长盛不衰的]]></description>
</item>
<item>
  <title>STL关联式容器-hashset</title>
  <link>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashset/</link>
  <pubDate>Sun, 25 Apr 2021 23:10:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashset/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/04/07/02/56/cottontail-rabbit-7116707__340.jpg" referrerpolicy="no-referrer">
      </div>STL 只规范复杂度与接口，并不规范实现方法，但是STL set多半以RB-tree为底层实现机制，SGI则是STL标准规定之外另又提供了一个所谓的]]></description>
</item>
<item>
  <title>STL关联式容器-hashtable</title>
  <link>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/</link>
  <pubDate>Sat, 24 Apr 2021 23:10:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2022/04/02/13/43/music-7107045__340.jpg" referrerpolicy="no-referrer">
      </div>1. 哈希冲突 .1. 线性探测 根据元素的值然后除以数组大小，然后插入指定的位置 .2. 二次探测 F(i)=i*i; 如果新元素起始插入位置为H，但是H已经被占用，则会尝试H+i]]></description>
</item>
<item>
  <title>STL关联式容器-hashmap</title>
  <link>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashmap/</link>
  <pubDate>Sat, 24 Apr 2021 20:10:04 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashmap/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2019/11/25/06/21/leaf-4651088__340.jpg" referrerpolicy="no-referrer">
      </div>hash_multimap 与 hash_map 使用起来相同，只是 hash_multimap 中允许键值重复 在源码中，hash_multimap 调用的是 insert_equal ()，而 hash_map 调用的是 insert_unique ()。 1. 数据结构 class hash_map { private: typedef hashtable&lt;pair&lt;const Key, T&gt;, Key,]]></description>
</item>
<item>
  <title>数组系列C&#43;&#43;</title>
  <link>https://liudongdong1.github.io/%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97c-/</link>
  <pubDate>Tue, 20 Apr 2021 21:31:56 &#43;0000</pubDate>
  <author>liudongdong1</author>
  <guid>https://liudongdong1.github.io/%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97c-/</guid>
  <description><![CDATA[<div class="featured-image">
        <img src="https://cdn.pixabay.com/photo/2020/07/04/20/12/green-lizard-5370821__340.jpg" referrerpolicy="no-referrer">
      </div>1. Remove Duplicates from Sorted Array int removeDuplicates(vector&lt;int&gt;&amp; nums){ if(nums.empty()){ return 0; } int index=0; for(int i=1;i&lt;nums.size();i++){ if(nums[i]!=nums[index]){ nums[++index]=nums[i]; } } return index+1; } //STL return distance(nums.begin(),unique(nums.begin(),nums.end()); 2. Remove Duplicates from Sorted Array 2 int removeDuplicates(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt;= 2) return nums.size(); int index = 2; for (int i = 2; i &lt; nums.size(); i++){ if (nums[i] != nums[index - 2]) nums[index++] = nums[i]; } return index; }]]></description>
</item>
</channel>
</rss>
