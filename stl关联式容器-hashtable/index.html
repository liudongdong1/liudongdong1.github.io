<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>STL关联式容器-hashtable - DAY By DAY</title><meta name=author content="LiuDongdong"><meta name=author-link content="https://liudongdong1.github.io/"><meta name=description content="1. 哈希冲突 .1. 线性探测 根据元素的值然后除以数组大小，然后插入指定的位置 .2. 二次探测 F(i)=i*i; 如果新元素起始插入位置为H，但是H已经被占用，则会尝试H+i"><meta name=keywords content="C++"><meta itemprop=name content="STL关联式容器-hashtable"><meta itemprop=description content="1. 哈希冲突 .1. 线性探测 根据元素的值然后除以数组大小，然后插入指定的位置 .2. 二次探测 F(i)=i*i; 如果新元素起始插入位置为H，但是H已经被占用，则会尝试H+i"><meta itemprop=datePublished content="2022-04-14T23:10:04+00:00"><meta itemprop=dateModified content="2023-09-24T17:00:04+08:00"><meta itemprop=wordCount content="3467"><meta itemprop=image content="/logo.png"><meta itemprop=keywords content="C++,"><meta property="og:title" content="STL关联式容器-hashtable"><meta property="og:description" content="1. 哈希冲突 .1. 线性探测 根据元素的值然后除以数组大小，然后插入指定的位置 .2. 二次探测 F(i)=i*i; 如果新元素起始插入位置为H，但是H已经被占用，则会尝试H+i"><meta property="og:type" content="article"><meta property="og:url" content="liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/"><meta property="og:image" content="/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-14T23:10:04+00:00"><meta property="article:modified_time" content="2023-09-24T17:00:04+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo.png"><meta name=twitter:title content="STL关联式容器-hashtable"><meta name=twitter:description content="1. 哈希冲突 .1. 线性探测 根据元素的值然后除以数组大小，然后插入指定的位置 .2. 二次探测 F(i)=i*i; 如果新元素起始插入位置为H，但是H已经被占用，则会尝试H+i"><meta name=application-name content="DAY By DAY"><meta name=apple-mobile-web-app-title content="DAY By DAY"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/><link rel=prev href=liudongdong1.github.io/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/><link rel=next href=liudongdong1.github.io/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/><link rel=stylesheet href=/liudongdong1.github.io/css/style.min.css><link rel=stylesheet href=/liudongdong1.github.io/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/liudongdong1.github.io/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"STL关联式容器-hashtable","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"liudongdong1.github.io\/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable\/"},"genre":"posts","keywords":"C\u002b\u002b","wordcount":3467,"url":"liudongdong1.github.io\/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable\/","datePublished":"2022-04-14T23:10:04+00:00","dateModified":"2023-09-24T17:00:04+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"LiuDongdong","logo":"\/images\/person.png"},"author":{"@type":"Person","name":"liudongdong1"},"description":""}</script></head><body data-header-desktop=auto data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=liudongdong1.github.io/ title="DAY By DAY"><img class="lazyload logo" src=/liudongdong1.github.io/svg/loading.min.svg data-src=/fixit.min.svg data-srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x" data-sizes=auto alt="DAY By DAY" title="DAY By DAY"><span class=header-title-text></span></a><span id=typeit-header-subtitle-desktop class="typeit header-subtitle"></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item language"><span role=button aria-label=选择语言 title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item>没有更多翻译</li></ul></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=liudongdong1.github.io/ title="DAY By DAY"><img class="lazyload logo" src=/liudongdong1.github.io/svg/loading.min.svg data-src=/fixit.min.svg data-srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x" data-sizes=auto alt=/fixit.min.svg title=/fixit.min.svg><span class=header-title-text></span></a><span id=typeit-header-subtitle-mobile class="typeit header-subtitle"></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://liudongdong1.github.io/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li><li class="menu-item language"><span role=button aria-label=选择语言 title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span>
<select class=language-select onchange="location=this.value"><option disabled>没有更多翻译</option></select></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container data-page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom id=aside-sakana><div class=sakana-widget><div class=sakana-item id=takina-widget></div><div class=sakana-item id=chisato-widget></div></div><script>function initSakanaWidget(){const e=SakanaWidget.getCharacter("takina");SakanaWidget.registerCharacter("takina-slow",e),new SakanaWidget({character:"takina-slow",controls:!1,autoFit:!0,stroke:{color:"#b4b4b4",width:2}}).mount("#takina-widget");const t=SakanaWidget.getCharacter("chisato");SakanaWidget.registerCharacter("chisato-slow",t),new SakanaWidget({character:"chisato-slow",controls:!1,autoFit:!0,stroke:{color:"#b4b4b4",width:2}}).mount("#chisato-widget")}</script><script async onload=initSakanaWidget() src=https://cdn.jsdelivr.net/npm/sakana-widget@2.3.0/lib/sakana.min.js></script></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>STL关联式容器-hashtable</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
liudongdong1</span></span>
<span class=post-category>收录于 <a href=liudongdong1.github.io/categories/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Categories</a>&ensp;<a href=liudongdong1.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;编程语言</a></span></div><div class=post-meta-line><span title="2022-04-14 23:10:04"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-04-14>2022-04-14</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 3467 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 7 分钟&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=STL关联式容器-hashtable>
<i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class=featured-image><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://cdn.pixabay.com/photo/2022/04/02/13/43/music-7107045__340.jpg data-srcset="https://cdn.pixabay.com/photo/2022/04/02/13/43/music-7107045__340.jpg, https://cdn.pixabay.com/photo/2022/04/02/13/43/music-7107045__340.jpg 1.5x, https://cdn.pixabay.com/photo/2022/04/02/13/43/music-7107045__340.jpg 2x" data-sizes=auto alt=https://cdn.pixabay.com/photo/2022/04/02/13/43/music-7107045__340.jpg title=https://cdn.pixabay.com/photo/2022/04/02/13/43/music-7107045__340.jpg></div><div class="details toc" id=toc-static kept=true><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#1-哈希冲突>1. 哈希冲突</a></li><li><a href=#2-数据结构>2. 数据结构</a></li><li><a href=#3-内存管理>3. 内存管理</a></li><li><a href=#4-插入操作>4. 插入操作</a></li><li><a href=#5-hash-function>5. hash function</a></li><li><a href=#6-copy_fromclear>6. copy_from&amp;clear</a></li><li><a href=#7-find--count>7. find & count</a></li><li><a href=#8-demo>8. demo</a></li><li><a href=#resource>Resource</a></li></ul></li></ul></nav></div></div><div class=content id=content><h3 id=1-哈希冲突>1. 哈希冲突</h3><h4 id=1-线性探测>.1. 线性探测</h4><ul><li>根据元素的值然后除以数组大小，然后插入指定的位置</li></ul><h4 id=2-二次探测>.2. 二次探测</h4><ul><li>F(i)=i*i; 如果新元素起始插入位置为H，但是H已经被占用，则会尝试H+i^2; i=[1,n];</li></ul><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131138470.png data-srcset="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131138470.png, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131138470.png 1.5x, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131138470.png 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131138470.png title=https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131138470.png></p><h4 id=3-开链链地址法>.3. 开链（链地址法）</h4><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131821725.png data-srcset="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131821725.png, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131821725.png 1.5x, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131821725.png 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131821725.png title=https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412131821725.png></p><h3 id=2-数据结构>2. 数据结构</h3><h4 id=1-hash_table节点>.1. hash_table节点</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Val</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_Hashtable_node</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  _Hashtable_node<span style=color:#f92672>*</span> _M_next;
</span></span><span style=display:flex><span>  _Val _M_val;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=2-迭代器>.2. 迭代器</h4><blockquote><ul><li>迭代器没有后退操作（operator–），也没有定义所谓的你想迭代器（reverse iterator）</li><li>其前进操作时首先尝试从目前所知的节点出发，前进一个位置（节点），由于节点被安置于 list 内，所以利用节点的 next 指针即可轻易达到进行的目的</li><li>如果目前节点正巧是 list 的尾端，就跳到下一个 bucket 内，跳过之后指向下一个 list 的头节点</li></ul></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Val</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Key</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_HashFcn</span>,
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_ExtractKey</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_EqualKey</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Alloc</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_Hashtable_iterator</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typedef</span> hashtable<span style=color:#f92672>&lt;</span>_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>            _Hashtable;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typedef</span> _Hashtable_iterator<span style=color:#f92672>&lt;</span>_Val, _Key, _HashFcn, 
</span></span><span style=display:flex><span>        _ExtractKey, _EqualKey, _Alloc<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>            iterator;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typedef</span> _Hashtable_const_iterator<span style=color:#f92672>&lt;</span>_Val, _Key, _HashFcn, 
</span></span><span style=display:flex><span>        _ExtractKey, _EqualKey, _Alloc<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>            const_iterator;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typedef</span> _Hashtable_node<span style=color:#f92672>&lt;</span>_Val<span style=color:#f92672>&gt;</span> _Node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typedef</span> forward_iterator_tag iterator_category;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typedef</span> _Val value_type;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typedef</span> ptrdiff_t difference_type;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typedef</span> size_t size_type;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typedef</span> _Val<span style=color:#f92672>&amp;</span> reference;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typedef</span> _Val<span style=color:#f92672>*</span> pointer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _Node<span style=color:#f92672>*</span> _M_cur; <span style=color:#75715e>//迭代器目前所指节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _Hashtable<span style=color:#f92672>*</span> _M_ht;<span style=color:#75715e>//保持对容器的连结关系（因为可能需要从bucket跳到bucket）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        _Hashtable_iterator(_Node<span style=color:#f92672>*</span> __n, _Hashtable<span style=color:#f92672>*</span> __tab) 
</span></span><span style=display:flex><span>            <span style=color:#f92672>:</span> _M_cur(__n), _M_ht(__tab) {}
</span></span><span style=display:flex><span>        _Hashtable_iterator() {}
</span></span><span style=display:flex><span>        reference <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> _M_cur<span style=color:#f92672>-&gt;</span>_M_val; }
</span></span><span style=display:flex><span>        <span style=color:#75715e>#ifndef __SGI_STL_NO_ARROW_OPERATOR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        pointer <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span>(<span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>()); }
</span></span><span style=display:flex><span>        <span style=color:#75715e>#endif </span><span style=color:#75715e>/* __SGI_STL_NO_ARROW_OPERATOR */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        iterator<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>();
</span></span><span style=display:flex><span>        iterator <span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>==</span>(<span style=color:#66d9ef>const</span> iterator<span style=color:#f92672>&amp;</span> __it) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>        { <span style=color:#66d9ef>return</span> _M_cur <span style=color:#f92672>==</span> __it._M_cur; }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>!=</span>(<span style=color:#66d9ef>const</span> iterator<span style=color:#f92672>&amp;</span> __it) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>        { <span style=color:#66d9ef>return</span> _M_cur <span style=color:#f92672>!=</span> __it._M_cur; }
</span></span><span style=display:flex><span>    };
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Val</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Key</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_HF</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_ExK</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_EqK</span>, 
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_All</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    _Hashtable_iterator<span style=color:#f92672>&lt;</span>_Val,_Key,_HF,_ExK,_EqK,_All<span style=color:#f92672>&gt;&amp;</span>
</span></span><span style=display:flex><span>    _Hashtable_iterator<span style=color:#f92672>&lt;</span>_Val,_Key,_HF,_ExK,_EqK,_All<span style=color:#f92672>&gt;::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> _Node<span style=color:#f92672>*</span> __old <span style=color:#f92672>=</span> _M_cur;
</span></span><span style=display:flex><span>        _M_cur <span style=color:#f92672>=</span> _M_cur<span style=color:#f92672>-&gt;</span>_M_next; <span style=color:#75715e>//如果存在，就是它，否则进入if
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>_M_cur) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//根据元素值，定位出下一个bucket。其起头处就是我们的目的地
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            size_type __bucket <span style=color:#f92672>=</span> _M_ht<span style=color:#f92672>-&gt;</span>_M_bkt_num(__old<span style=color:#f92672>-&gt;</span>_M_val);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>_M_cur <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>++</span>__bucket <span style=color:#f92672>&lt;</span> _M_ht<span style=color:#f92672>-&gt;</span>_M_buckets.size())<span style=color:#75715e>//注意operator++
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                _M_cur <span style=color:#f92672>=</span> _M_ht<span style=color:#f92672>-&gt;</span>_M_buckets[__bucket];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Val</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Key</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_HF</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_ExK</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_EqK</span>, 
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_All</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>inline</span> _Hashtable_iterator<span style=color:#f92672>&lt;</span>_Val,_Key,_HF,_ExK,_EqK,_All<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    _Hashtable_iterator<span style=color:#f92672>&lt;</span>_Val,_Key,_HF,_ExK,_EqK,_All<span style=color:#f92672>&gt;::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        iterator __tmp <span style=color:#f92672>=</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>++*</span><span style=color:#66d9ef>this</span>; <span style=color:#75715e>//调用operator++()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> __tmp;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h4 id=3-hashtable结构>.3. hashtable结构</h4><blockquote><ul><li>_Val：节点的实值类型</li><li>_Key：节点的键值类型</li><li>_HF：hash function 的函数类型</li><li>_Ex：从节点取出键值的方法（函数或仿函数）</li><li>_Eq：判断键值相同与否的方法（函数或仿函数）</li><li>_All：空间配置器。缺省使用 std::alloc</li></ul></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Value</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Key</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashFcn</span>,
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ExtractKey</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EqualKey</span>,
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Alloc</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>hashtable</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> Key key_type;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> Value value_type;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> HashFcn hasher;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> EqualKey key_equal;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> size_t            size_type;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> ptrdiff_t         difference_type;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> value_type<span style=color:#f92672>*</span>       pointer;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>*</span> const_pointer;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> value_type<span style=color:#f92672>&amp;</span>       reference;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>&amp;</span> const_reference;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  hasher <span style=color:#a6e22e>hash_funct</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> hash; }
</span></span><span style=display:flex><span>  key_equal <span style=color:#a6e22e>key_eq</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> equals; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  hasher hash;
</span></span><span style=display:flex><span>  key_equal equals;
</span></span><span style=display:flex><span>  ExtractKey get_key;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> __hashtable_node<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span> node;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> simple_alloc<span style=color:#f92672>&lt;</span>node, Alloc<span style=color:#f92672>&gt;</span> node_allocator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span>node<span style=color:#f92672>*</span>,Alloc<span style=color:#f92672>&gt;</span> buckets;
</span></span><span style=display:flex><span>  size_type num_elements;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> __hashtable_iterator<span style=color:#f92672>&lt;</span>Value, Key, HashFcn, ExtractKey, EqualKey, 
</span></span><span style=display:flex><span>                               Alloc<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  iterator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typedef</span> __hashtable_const_iterator<span style=color:#f92672>&lt;</span>Value, Key, HashFcn, ExtractKey, EqualKey,
</span></span><span style=display:flex><span>                                     Alloc<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  const_iterator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__hashtable_iterator</span><span style=color:#f92672>&lt;</span>Value, Key, HashFcn, ExtractKey, EqualKey, Alloc<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__hashtable_const_iterator</span><span style=color:#f92672>&lt;</span>Value, Key, HashFcn, ExtractKey, EqualKey, Alloc<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  hashtable(size_type n,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> HashFcn<span style=color:#f92672>&amp;</span>    hf,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> EqualKey<span style=color:#f92672>&amp;</span>   eql,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> ExtractKey<span style=color:#f92672>&amp;</span> ext)
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> hash(hf), equals(eql), get_key(ext), num_elements(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    initialize_buckets(n);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  hashtable(size_type n,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> HashFcn<span style=color:#f92672>&amp;</span>    hf,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> EqualKey<span style=color:#f92672>&amp;</span>   eql)
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> hash(hf), equals(eql), get_key(ExtractKey()), num_elements(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    initialize_buckets(n);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  hashtable(<span style=color:#66d9ef>const</span> hashtable<span style=color:#f92672>&amp;</span> ht)
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> hash(ht.hash), equals(ht.equals), get_key(ht.get_key), num_elements(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    copy_from(ht);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  hashtable<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> hashtable<span style=color:#f92672>&amp;</span> ht)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>&amp;</span>ht <span style=color:#f92672>!=</span> <span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>      clear();
</span></span><span style=display:flex><span>      hash <span style=color:#f92672>=</span> ht.hash;
</span></span><span style=display:flex><span>      equals <span style=color:#f92672>=</span> ht.equals;
</span></span><span style=display:flex><span>      get_key <span style=color:#f92672>=</span> ht.get_key;
</span></span><span style=display:flex><span>      copy_from(ht);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-内存管理>3. 内存管理</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>_Node<span style=color:#f92672>*</span> <span style=color:#a6e22e>_M_new_node</span>(<span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>&amp;</span> __obj)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    _Node<span style=color:#f92672>*</span> __n <span style=color:#f92672>=</span> _M_get_node();
</span></span><span style=display:flex><span>    __n<span style=color:#f92672>-&gt;</span>_M_next <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    __STL_TRY {
</span></span><span style=display:flex><span>      construct(<span style=color:#f92672>&amp;</span>__n<span style=color:#f92672>-&gt;</span>_M_val, __obj);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> __n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    __STL_UNWIND(_M_put_node(__n));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>_M_delete_node</span>(_Node<span style=color:#f92672>*</span> __n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    destroy(<span style=color:#f92672>&amp;</span>__n<span style=color:#f92672>-&gt;</span>_M_val);
</span></span><span style=display:flex><span>    _M_put_node(__n);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>_M_put_node</span>(_Node<span style=color:#f92672>*</span> __p) { _M_node_allocator.deallocate(__p, <span style=color:#ae81ff>1</span>); }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Val</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Key</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_HashFcn</span>,
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_ExtractKey</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_EqualKey</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Alloc</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>hashtable</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  hashtable(size_type __n,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> _HashFcn<span style=color:#f92672>&amp;</span>    __hf,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> _EqualKey<span style=color:#f92672>&amp;</span>   __eql,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> _ExtractKey<span style=color:#f92672>&amp;</span> __ext,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> allocator_type<span style=color:#f92672>&amp;</span> __a <span style=color:#f92672>=</span> allocator_type())
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> __HASH_ALLOC_INIT(__a)
</span></span><span style=display:flex><span>      _M_hash(__hf),
</span></span><span style=display:flex><span>      _M_equals(__eql),
</span></span><span style=display:flex><span>      _M_get_key(__ext),
</span></span><span style=display:flex><span>      _M_buckets(__a),
</span></span><span style=display:flex><span>      _M_num_elements(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    _M_initialize_buckets(__n);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> _M_initialize_buckets(size_type __n)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> size_type __n_buckets <span style=color:#f92672>=</span> _M_next_size(__n);<span style=color:#75715e>//调用_M_next_size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>//举例：传入50，返回53.以下首先保留53个元素空间，然后将其全部填0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      _M_buckets.reserve(__n_buckets);
</span></span><span style=display:flex><span>      _M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node<span style=color:#f92672>*</span>) <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>      _M_num_elements <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>   <span style=color:#75715e>//该函数返回最近接n并大于n的质数。其中调用了我们上面介绍的__stl_next_prime函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   size_type <span style=color:#a6e22e>_M_next_size</span>(size_type __n) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>       { <span style=color:#66d9ef>return</span> __stl_next_prime(__n); }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=4-插入操作>4. 插入操作</h3><h4 id=1-insert_unique>.1. <strong>insert_unique()</strong></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>pair<span style=color:#f92672>&lt;</span>iterator, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> insert_unique(<span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>&amp;</span> __obj)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    resize(_M_num_elements <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);          <span style=color:#75715e>//判断是否需要重建表格
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>insert_unique_noresize</span>(__obj); <span style=color:#75715e>//在不需要重建表格的情况下插入节点，键值不允许重复
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>V</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>K</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HF</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ex</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Eq</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> hashtable<span style=color:#f92672>&lt;</span>V, K, HF, Ex, Eq, A<span style=color:#f92672>&gt;::</span>resize(size_type num_elements_hint)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> size_type old_n <span style=color:#f92672>=</span> buckets.size();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (num_elements_hint <span style=color:#f92672>&gt;</span> old_n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> size_type n <span style=color:#f92672>=</span> next_size(num_elements_hint);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&gt;</span> old_n) {
</span></span><span style=display:flex><span>            vector<span style=color:#f92672>&lt;</span>node<span style=color:#f92672>*</span>, A<span style=color:#f92672>&gt;</span> tmp(n, (node<span style=color:#f92672>*</span>) <span style=color:#ae81ff>0</span>);  <span style=color:#75715e>//设立新的buckets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            __STL_TRY {
</span></span><span style=display:flex><span>                <span style=color:#75715e>//处理每一个旧的buckets   todo这里还是没有看懂
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> (size_type bucket <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; bucket <span style=color:#f92672>&lt;</span> old_n; <span style=color:#f92672>++</span>bucket) {
</span></span><span style=display:flex><span>                    node<span style=color:#f92672>*</span> first <span style=color:#f92672>=</span> buckets[bucket];   <span style=color:#75715e>//指向节点所对应之串行的起始节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>//处理每一个就bucket中所含的每一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>while</span> (first) {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>//找出节点落在哪一个新bucket内
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        size_type new_bucket <span style=color:#f92672>=</span> bkt_num(first<span style=color:#f92672>-&gt;</span>val, n);
</span></span><span style=display:flex><span>                        <span style=color:#75715e>//令旧bucket指向其所对应串行的下一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        buckets[bucket] <span style=color:#f92672>=</span> first<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                        <span style=color:#75715e>//将当前节点插入到新bucket内，使其成为对应串行的第一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        first<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> tmp[new_bucket];
</span></span><span style=display:flex><span>                        tmp[new_bucket] <span style=color:#f92672>=</span> first;
</span></span><span style=display:flex><span>                        <span style=color:#75715e>//回到旧bucket所指的待处理行，准备处理下一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        first <span style=color:#f92672>=</span> buckets[bucket];          
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                buckets.swap(tmp);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>#         ifdef __STL_USE_EXCEPTIONS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>catch</span>(...) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (size_type bucket <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; bucket <span style=color:#f92672>&lt;</span> tmp.size(); <span style=color:#f92672>++</span>bucket) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> (tmp[bucket]) {
</span></span><span style=display:flex><span>                        node<span style=color:#f92672>*</span> next <span style=color:#f92672>=</span> tmp[bucket]<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                        delete_node(tmp[bucket]);
</span></span><span style=display:flex><span>                        tmp[bucket] <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>#         endif </span><span style=color:#75715e>/* __STL_USE_EXCEPTIONS */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412135623759.png data-srcset="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412135623759.png, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412135623759.png 1.5x, https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412135623759.png 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412135623759.png title=https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220412135623759.png></p><h4 id=2-insert_unique_noresize>.2. insert_unique_noresize</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>V</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>K</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HF</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ex</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Eq</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> hashtable<span style=color:#f92672>&lt;</span>V, K, HF, Ex, Eq, A<span style=color:#f92672>&gt;::</span>iterator, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> 
</span></span><span style=display:flex><span>hashtable<span style=color:#f92672>&lt;</span>V, K, HF, Ex, Eq, A<span style=color:#f92672>&gt;::</span>insert_unique_noresize(<span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>&amp;</span> obj)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> size_type n <span style=color:#f92672>=</span> bkt_num(obj); <span style=color:#75715e>//决定obj应位于 #n bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  node<span style=color:#f92672>*</span> first <span style=color:#f92672>=</span> buckets[n];   <span style=color:#75715e>//令first指向bucket对应的串行头部
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (node<span style=color:#f92672>*</span> cur <span style=color:#f92672>=</span> first; cur; cur <span style=color:#f92672>=</span> cur<span style=color:#f92672>-&gt;</span>next) 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (equals(get_key(cur<span style=color:#f92672>-&gt;</span>val), get_key(obj)))
</span></span><span style=display:flex><span>        <span style=color:#75715e>//遍历bucket所对应的链表，如果发现与链表中某个键值相同，就不插入，立刻返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> pair<span style=color:#f92672>&lt;</span>iterator, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(iterator(cur, <span style=color:#66d9ef>this</span>), false);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  node<span style=color:#f92672>*</span> tmp <span style=color:#f92672>=</span> new_node(obj);
</span></span><span style=display:flex><span>  tmp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> first;  <span style=color:#75715e>//令新节点成为链表中的第一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  buckets[n] <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>  <span style=color:#f92672>++</span>num_elements;      <span style=color:#75715e>//节点数加一
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> pair<span style=color:#f92672>&lt;</span>iterator, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(iterator(tmp, <span style=color:#66d9ef>this</span>), true);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=3-insert_equal>.3. insert_equal</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>iterator <span style=color:#a6e22e>insert_equal</span>(<span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>&amp;</span> obj)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    resize(num_elements <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> insert_equal_noresize(obj);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4-insert_equal_noresize>.4. insert_equal_noresize</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>V</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>K</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HF</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ex</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Eq</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typename</span> hashtable<span style=color:#f92672>&lt;</span>V, K, HF, Ex, Eq, A<span style=color:#f92672>&gt;::</span>iterator 
</span></span><span style=display:flex><span>hashtable<span style=color:#f92672>&lt;</span>V, K, HF, Ex, Eq, A<span style=color:#f92672>&gt;::</span>insert_equal_noresize(<span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>&amp;</span> obj)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> size_type n <span style=color:#f92672>=</span> bkt_num(obj);
</span></span><span style=display:flex><span>  node<span style=color:#f92672>*</span> first <span style=color:#f92672>=</span> buckets[n];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (node<span style=color:#f92672>*</span> cur <span style=color:#f92672>=</span> first; cur; cur <span style=color:#f92672>=</span> cur<span style=color:#f92672>-&gt;</span>next) 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (equals(get_key(cur<span style=color:#f92672>-&gt;</span>val), get_key(obj))) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//遍历bucket所对应的整个链表，如果发现与链表中的某键值相同，将新节点插入当前位置之后，返回指向新节点的iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      node<span style=color:#f92672>*</span> tmp <span style=color:#f92672>=</span> new_node(obj);
</span></span><span style=display:flex><span>      tmp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> cur<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>      cur<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>      <span style=color:#f92672>++</span>num_elements;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>iterator</span>(tmp, <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  node<span style=color:#f92672>*</span> tmp <span style=color:#f92672>=</span> new_node(obj);
</span></span><span style=display:flex><span>  tmp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> first;
</span></span><span style=display:flex><span>  buckets[n] <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>  <span style=color:#f92672>++</span>num_elements;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>iterator</span>(tmp, <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=5-hash-function>5. hash function</h3><blockquote><ul><li>插入元素之后需要知道某个元素落脚于哪一个 bucket 内。这本来是哈希函数的责任，但是 SGI 把这个任务包装了一层，先交给 bkt_num () 函数，再由此函数调用哈希函数，取得一个可以执行 modulus（取模）运算的数值为什么要这么做？因为有些函数类型无法直接拿来对哈表表的大小进行模运算，例如字符串，这时候我们需要做一些转换</li><li>hash functions 是计算元素位置的函数，SGI 将这项任务赋予了先前提到过的 bkt_num () 函数，再由 bkt_num () 函数调用这些 hash function，取得一个可以对 hashtable 进行模运算的值，针对 char、int、long 等整数类型，这里大部分的 hash function 什么都没有做，只是直接返回原值。具体见&lt;stl_hash_fun.h></li><li>hashtable <strong>无法处理上述所列各项类型之外的元素</strong>。例如 string、double、float 等，这些类型<strong>用户必须自己定义 hash function。</strong></li></ul></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>//版本1：接受实值（value）和buckets个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>size_type <span style=color:#a6e22e>_M_bkt_num</span>(<span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>&amp;</span> __obj, size_t __n) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _M_bkt_num_key(_M_get_key(__obj), __n); <span style=color:#75715e>//调用版本4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>//版本2：只接受实值（value）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>size_type <span style=color:#a6e22e>_M_bkt_num</span>(<span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>&amp;</span> __obj) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _M_bkt_num_key(_M_get_key(__obj)); <span style=color:#75715e>//调用版本3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>//版本3，只接受键值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>size_type <span style=color:#a6e22e>_M_bkt_num_key</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> __key) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _M_bkt_num_key(__key, _M_buckets.size()); <span style=color:#75715e>//调用版本4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>//版本4：接受键值和buckets个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>size_type <span style=color:#a6e22e>_M_bkt_num_key</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> __key, size_t __n) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _M_hash(__key) <span style=color:#f92672>%</span> __n; <span style=color:#75715e>//SGI的所有内建的hash()，在后面的hash functions中介绍
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=6-copy_fromclear>6. copy_from&amp;clear</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>V</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>K</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HF</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ex</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Eq</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> hashtable<span style=color:#f92672>&lt;</span>V, K, HF, Ex, Eq, A<span style=color:#f92672>&gt;::</span>clear()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (size_type i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> buckets.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>    node<span style=color:#f92672>*</span> cur <span style=color:#f92672>=</span> buckets[i];
</span></span><span style=display:flex><span>    <span style=color:#75715e>//删除桶中每一个元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (cur <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      node<span style=color:#f92672>*</span> next <span style=color:#f92672>=</span> cur<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>      delete_node(cur);
</span></span><span style=display:flex><span>      cur <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    buckets[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>//令桶的内容为null指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  num_elements <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;   <span style=color:#75715e>//总结点个数为0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>V</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>K</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HF</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ex</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Eq</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> hashtable<span style=color:#f92672>&lt;</span>V, K, HF, Ex, Eq, A<span style=color:#f92672>&gt;::</span>copy_from(<span style=color:#66d9ef>const</span> hashtable<span style=color:#f92672>&amp;</span> ht)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  buckets.clear();
</span></span><span style=display:flex><span>  <span style=color:#75715e>//如果大于ht的空间就不动，否则增大自己空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  buckets.reserve(ht.buckets.size());
</span></span><span style=display:flex><span>  <span style=color:#75715e>//此时，buckets vector为空，所以此处的尾端及开头
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  buckets.insert(buckets.end(), ht.buckets.size(), (node<span style=color:#f92672>*</span>) <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  __STL_TRY {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (size_type i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ht.buckets.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//复制vector的每一个元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> node<span style=color:#f92672>*</span> cur <span style=color:#f92672>=</span> ht.buckets[i]) {
</span></span><span style=display:flex><span>        node<span style=color:#f92672>*</span> copy <span style=color:#f92672>=</span> new_node(cur<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>        buckets[i] <span style=color:#f92672>=</span> copy;
</span></span><span style=display:flex><span>		<span style=color:#75715e>//复制bucket list中每一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (node<span style=color:#f92672>*</span> next <span style=color:#f92672>=</span> cur<span style=color:#f92672>-&gt;</span>next; next; cur <span style=color:#f92672>=</span> next, next <span style=color:#f92672>=</span> cur<span style=color:#f92672>-&gt;</span>next) {
</span></span><span style=display:flex><span>          copy<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> new_node(next<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>          copy <span style=color:#f92672>=</span> copy<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    num_elements <span style=color:#f92672>=</span> ht.num_elements;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  __STL_UNWIND(clear());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=7-find--count>7. find & count</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>const_iterator <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> key) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    size_type n <span style=color:#f92672>=</span> bkt_num_key(key);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> node<span style=color:#f92672>*</span> first;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ( first <span style=color:#f92672>=</span> buckets[n];
</span></span><span style=display:flex><span>         first <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>equals(get_key(first<span style=color:#f92672>-&gt;</span>val), key);
</span></span><span style=display:flex><span>         first <span style=color:#f92672>=</span> first<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>    {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> const_iterator(first, <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>} 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>size_type <span style=color:#a6e22e>count</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> key) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> size_type n <span style=color:#f92672>=</span> bkt_num_key(key);
</span></span><span style=display:flex><span>    size_type result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> node<span style=color:#f92672>*</span> cur <span style=color:#f92672>=</span> buckets[n]; cur; cur <span style=color:#f92672>=</span> cur<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (equals(get_key(cur<span style=color:#f92672>-&gt;</span>val), key))
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>result;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=8-demo>8. demo</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;hash_set&gt; //会包含&lt;stl_hashtable.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	hashtable<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, hash<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, identity<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, equal_to<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, alloc<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>		iht(<span style=color:#ae81ff>50</span>, hash<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(), equal_to<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> iht.size() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>//0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> iht.bucket_count()() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>//53。这是STL供应的第一个质数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> iht.max_bucket_count() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>//4294967291，这是STL供应的最后一个质数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>	iht.insert_unique(<span style=color:#ae81ff>59</span>);
</span></span><span style=display:flex><span>	iht.insert_unique(<span style=color:#ae81ff>63</span>);
</span></span><span style=display:flex><span>	iht.insert_unique(<span style=color:#ae81ff>108</span>);
</span></span><span style=display:flex><span>	iht.insert_unique(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	iht.insert_unique(<span style=color:#ae81ff>53</span>);
</span></span><span style=display:flex><span>	iht.insert_unique(<span style=color:#ae81ff>55</span>);
</span></span><span style=display:flex><span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> iht.size() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>//6。这个就是hashtable&lt;T&gt;::num_element
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>//下面声明一个hashtable迭代器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	hashtable<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, hash<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, identity<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, equal_to<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, alloc<span style=color:#f92672>&gt;::</span>iterator
</span></span><span style=display:flex><span>		ite <span style=color:#f92672>=</span> iht.begin();
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>	<span style=color:#75715e>//遍历hashtable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> iht.size(); <span style=color:#f92672>++</span>i, <span style=color:#f92672>++</span>ite)
</span></span><span style=display:flex><span>		std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>ite <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>//53 55 2 108 59 53
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>	<span style=color:#75715e>//遍历所有buckets。如果其节点个数不为0，就打印节点个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> iht.bucket_count(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> iht.elems_in_bucket(i);  <span style=color:#75715e>//桶中元素个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> (n <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>			std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;bucket[&#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;]has&#34;</span><span style=color:#f92672>&lt;&lt;</span>n<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;elems.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>//会打印如下内容
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//bucket[0] has 1 elems
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//bucket[2] has 3 elems
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//bucket[6] has 1 elems
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//bucket[10] has 1 elems
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*为了验证bucket(list)的容量就是buckets vector的大小，
</span></span></span><span style=display:flex><span><span style=color:#75715e>	这里从hastable&lt;T&gt;::Resize()得到结果。此处刻意将元素加到54个，
</span></span></span><span style=display:flex><span><span style=color:#75715e>	看看是否发生”表格重建“
</span></span></span><span style=display:flex><span><span style=color:#75715e>	*/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>47</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>		iht.insert_equal(i);
</span></span><span style=display:flex><span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> iht.size() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>//54。元素(节点)个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> iht.bucket_count() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>//97，buckets个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>	<span style=color:#75715e>//遍历所有buckets，如果其节点个数不为0，就打印节点个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> iht.bucket_count(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> iht.elems_in_bucket(i);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (n <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>			std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;bucket[&#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;]has&#34;</span> <span style=color:#f92672>&lt;&lt;</span> n <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;elems.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>//打印的结果为：bucket[2]和bucket[11]的节点个数为2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//其余的bucket[0]~bucket[47]的节点个数为1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//此外，bucket[53],[55],[59],[63]的节点个数均为1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>	<span style=color:#75715e>//以迭代器遍历hashtable，将所有节点的值打印出来
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ite <span style=color:#f92672>=</span> iht.begin();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> iht.size(); <span style=color:#f92672>++</span>i, <span style=color:#f92672>++</span>ite)
</span></span><span style=display:flex><span>		std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>ite <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>	<span style=color:#75715e>//0 1 2 2 3 4 5 6 7 8 9 10 11 108 12 13 14 15 16 17 18 19 20 21
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//43 44 45 46 47 53 55 59 63
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>(iht.find(<span style=color:#ae81ff>2</span>)) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;  <span style=color:#75715e>//2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>(iht.count(<span style=color:#ae81ff>2</span>)) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>//2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=resource>Resource</h3><ul><li><a href=https://github1s.com/TBLGSn/SGI-STL/blob/HEAD/g++/stl_hashtable.h#L162-L240 target=_blank rel="external nofollow noopener noreferrer">https://github1s.com/TBLGSn/SGI-STL/blob/HEAD/g++/stl_hashtable.h#L162-L240<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2023-09-24 17:00:04">更新于 2023-09-24&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://liudongdong1.github.io/edit/master/content/posts%5c%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80%5cC++%5cSTL%e5%85%b3%e8%81%94%e5%bc%8f%e5%ae%b9%e5%99%a8-hashtable.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/ data-title=STL关联式容器-hashtable data-hashtags=C++><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/ data-hashtag=C++><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=liudongdong1.github.io/stl%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-hashtable/ data-title=STL关联式容器-hashtable data-image=https://cdn.pixabay.com/photo/2022/04/02/13/43/music-7107045__340.jpg><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=liudongdong1.github.io/tags/c++/>C++</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=liudongdong1.github.io/>主页</a></span></section></div><div class=post-nav><a href=liudongdong1.github.io/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/ class=prev rel=prev title=数据密集型应用系统设计笔记-数据复制><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>数据密集型应用系统设计笔记-数据复制</a>
<a href=liudongdong1.github.io/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/ class=next rel=next title=数据密集型应用系统设计笔记-数据分区>数据密集型应用系统设计笔记-数据分区<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.118.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.17-RC"><img class=fixit-icon src=/liudongdong1.github.io/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=https://liudongdong1.github.io/ target=_blank rel="external nofollow noopener noreferrer">LiuDongdong</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title='网站运行中 ...'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i>&nbsp;<span class=run-times>网站运行中 ...</span></span></div><div class="footer-line ibruce"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://liudongdong1.github.io/ title="在 GitHub 上查看源代码" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#0076ff;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/liudongdong1.github.io/lib/katex/katex.min.css><link rel=stylesheet href=/liudongdong1.github.io/lib/cookieconsent/cookieconsent.min.css><script src=/liudongdong1.github.io/lib/autocomplete/autocomplete.min.js defer></script><script src=/liudongdong1.github.io/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/liudongdong1.github.io/lib/lazysizes/lazysizes.min.js async defer></script><script src=/liudongdong1.github.io/lib/sharer/sharer.min.js async defer></script><script src=/liudongdong1.github.io/lib/typeit/index.umd.js defer></script><script src=/liudongdong1.github.io/lib/katex/katex.min.js defer></script><script src=/liudongdong1.github.io/lib/katex/auto-render.min.js defer></script><script src=/liudongdong1.github.io/lib/katex/copy-tex.min.js defer></script><script src=/liudongdong1.github.io/lib/katex/mhchem.min.js defer></script><script src=/liudongdong1.github.io/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/liudongdong1.github.io/lib/pangu/pangu.min.js defer></script><script src=/liudongdong1.github.io/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},data:{"typeit-header-subtitle-desktop":`<span style='font-family: MMT,"沐目体";'>吾日三省吾身</span>`,"typeit-header-subtitle-mobile":`<span style='font-family: MMT,"沐目体";'>吾日三省吾身</span>`},enablePWA:!0,enablePangu:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"2R1K9SKLQZ",algoliaIndex:"index.zh-cn",algoliaSearchKey:"4a226aa1c5c98d6859e4d1386adb2bc7",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-12-18T16:15:22+08:00",typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"typeit-header-subtitle-desktop":["typeit-header-subtitle-desktop"],"typeit-header-subtitle-mobile":["typeit-header-subtitle-mobile"]},duration:-1,speed:100},watermark:{appendto:".wrapper>main",colspacing:30,content:'<img class="fixit-icon" src="/fixit.min.svg" alt="FixIt logo" /> FixIt 主题',enable:!0,fontfamily:"inherit",fontsize:.85,height:21,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/liudongdong1.github.io/js/theme.min.js defer></script><script src=/liudongdong1.github.io/js/custom.min.js defer></script></body></html>