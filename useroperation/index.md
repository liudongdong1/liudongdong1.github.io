# userOperation


## 1 用户和用户组分类

Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须要拥有一个账号进入系统。账号实质上就是一个用户在系统上的标识，系统根据该标识分配不同的权限和资源。一个账号包含**用户**和**用户组**两部分。

- **用户分类：**
  - `超级管理员`：具有操作系统的一切权限，UID 为 0 。一般是 "root"用户，不建议一个系统有多个超级用户
  - `系统用户(伪用户)`：方便系统管理，用来运行系统和服务的用户，没有密码不能登录，UID在 1 - 499 之间。比如有些服务不希望使用 root 的身份去执行，而是希望使用权限更小的账号去执行，所以我们就得要提供这些运作程序的拥有者
  - `普通用户`：可登入用户，拥有系统部分权限的用户，UID 从 500 开始。
- **用户组分类：**
  - `初始组`：用户刚登录入系统就所在的组，用户的必须要有一个初始组且只能有一个，一般初始组名和用户名相同
  - `附加组`：用户除了初始组外加入的其他组，每个用户可以拥有0或多个附加组

## 2 用户和用户组相关文件

- **用户信息文件：/etc/passwd**
  - 该用户存放系统所有用户的信息，每一行内容代表一个用户，以 ":" 分割共 7 列。以 root 用户为例："`root:x:0:0:root:/root:/bin/bash`"
  - **第 1 列**：**用户名**
  - **第 2 列**：**密码位**。早期 Unix 系统的密码就是放在这字段上，但是因为这个文件的特性是所有的程序都能够读取，这样一来很容易造成密码数据被窃取， 因此后来就将这个字段的密码数据给放到 "/etc/shadow" 中了，所以这里会看到一个 "x"
  - **第 3 列**：**用户ID，即 UID**
    - `0 (超级管理员)`：当 UID 为 0 时，代表该用户是超级管理员。所以当你要让其他的用户名称也具有 root 的权限时，将该用户的 UID 改为 0 即可，也就是说一个系统上超级管理员不见得就是 root，很不建议有多个用户的 UID 是 0
    - `1 - 499 (系统用户)`：这些 UID 是保留给系统用户的 UID，也就是说 UID 在 1 - 499 范围的用户是不能登录的，只能用来运行系统或者服务。其中，UID 1 - 99 是系统自动创建账号时使用的； UID 100 - 499 是用户有创建系统账号需求时使用的
    - `500 - 60000 (普通用户)`：普通用户UID。实际上Linux 2.6.x 内核以后可以支持 2^32-1 这么多了
  - **第 4 列**：**用户初始组ID，即 GID**
  - **第 5 列**：**用户信息说明**。这个字段基本上并没有什么重要用途，只是用来解释这个账号的意义而已
  - **第 6 列**：**用户目录**，即用户登录后默认进入的目录。如果你想让某个用户登录后默认进入其他目录，修改这列就行了，前提该用户要有进入这个目录的权限
  - **第 7 列**：**登录后获取的shell**。一般都是 "/bin/bash"，注意系统用户不能登录所以这列是一个特殊shell "/sbin/nologin"
- **用户密码文件：/etc/shadow**
  - 该文件存放的实际上才是用户的密码信息，每行代表一个用户的密码信息，以 ":" 分割共 9 列。早期的密码(加密过的)存放在 "/etc/passwd" 文件的第二列，但由于 "/etc/passwd" 文件权限是 "-rw-r--r--" 容易被窃取，后来把密码放到了 "/etc/shadow" 文件，且文件权限为 "----------" 。以 root 用户密码信息为例：`root:$6$jOouAVJYJ5Ys2U1q$5j..L0vQV8W2ih8M2AK50PFhHJfJRUMIyMLkZuCezV6HOoX4Zls3yH7JdJlAPz6bp3DaKNhVh4ewXzxTivRC9/:18020:0:99999:7:::`
  - **第 1 列**：**用户名**。对应 "/etc/passwd" 文件中的用户名
  - **第 2 列**：**加密密码**。如果是 "`!!`" 或者 "`*`"，代表没有密码不能登录，系统用户就是 "`!!`" 或者 "`*`"
  - **第 3 列**：**密码最近一次改动日期**。值是以 1970 年 1 月 1 日作为 1 而累加得来得天数
    - 天数转日期：`date -d "1970-01-01 18020 days"`
    - 日期传天数：`echo $(($(date --date="2019/05/04" +%s)/86400+1))`
  - **第 4 列**：**两次密码修改时间间隔**(与第3列相比)。该用户的密码在最近一次被更改后需要经过几天才可以再被变更，如果是 0 的话表示密码随时可以更动的意思。这的限制是为了怕密码被某些人一改再改而设计的，如果设定为 20 天的话，那么当你设定了密码之后， 20 天之内都无法改变这个密码
  - **第 5 列**：**密码有效期**(与第3列相比)。经常变更密码是个好习惯！为了强制要求用户变更密码，这个字段可以指定在最近一次更改密码后， 在多少天数内需要再次变更密码才行
  - **第 6 列**：**密码到期前的警告天数**(与第5列相比)。当用户的密码有效期限快要到的时候，系统会依据这个字段的设定，发出警告信息给这个用户，提醒他 "再过 n 天你的密码就要过期了，请尽快重新设定你的密码"，如上面的例子，则是密码到期之前的 7 天之内，系统会警告该用户
  - **第 7 列**：**密码到期后的宽限天数**(与第5列相比)。如果设置了宽限天数，密码到期后不会立即失效，再宽限天数内任务没有更改密码，密码才会真正的失效
  - **第 8 列**：**账号失效日期**。这个日期跟第三个字段一样，都是使用 1970 年以来的总日数设定。这列表示： 该用户在此字段规定的日期之后，将无法再使用，就是所谓的账号失效，此时不论你的密码是否有过期，这个账号都不能再被使用！ 这个字段会被使用通常应该是在收费服务的系统中，你可以规定一个日期让该账号不能再使用了
  - **第 9 列**：**保留**。这列是保留的，看以后有没有新功能加入
- **用户组文件：/etc/group**
  - 该文件存放用户组信息，每行代表一个用户组信息，以 ":" 分割共 4 列。以 root 组信息为例：`root:x:0:`
  - **第 1 列**：**用户组名**。
  - **第 2 列**：**用户组密码位**。和用户密码一样，组密码已经移动到 "/etc/gshadow" 文件中去，因此这个字段只存在一个 "x" 而已
  - **第 3 列**：**用户组ID，即 GID**。对应 "/etc/passwd" 文件中的用户组ID
  - **第 4 列**：**组内用户列表**(不包含以该组为初始组的用户)，多个用户名以","隔开。例如现在需要把 "user1" 和 "user2" 也加入到该 root 组，则 root 组信息变为 "`root:x:0:user1,user2`"
- **用户组密码文件：/etc/gshadow**
  - 如果给某个用户设定了组管理员，并给该用户组设定了组密码，组密码就保存在这个文件中，组管理员就可以利用这个密码管理这个用户组了。通常很少有这个机会设定用户组管理员，这里只对内容结构做一下简单说明，以 ":" 分割共 4 列
  - **第 1 列**：**用户组名**。对应 "/etc/group" 文件中的用户组名
  - **第 2 列**：**加密的用户组密码**。
  - **第 3 列**：**用户组的管理员账号**。管理员拥有对该组添加和删除账号的权限
  - **第 4 列**：**组内用户列表**
- **用户目录**
  - 一般 root 用户的家目录为 "/root"，普通用户的家目录为 "/home/xxx"
- **用户邮箱**
  - 用户邮箱在 "/var/spool/mail/" 目录下，例如 "user1" 用户的邮箱是 "/var/spool/mail/user1"
- **用户模板文件：/etc/skel/**
  - 新建一个用户的时候，"/etc/skel/" 目录下的文件都会原封不动的复制到新建用户的家目录下。例如，提前在 "/etc/skel/" 目录下放入一个用户使用手册文件 "manual.pdf"，再创建一个新用户，该用户登录后就会在他的家目录下看到这个用户使用手册文件了

**登录系统流程：**

1. 先找寻 **/etc/passwd** 里面是否有你输入的用户名，如果没有则跳出，如果有的话则将该用户名对应的 **UID** 与 **GID** (关联 **/etc/group** 中的GID) 读出来，另外该用户的家目录与 shell 设定也一并读出来；
2. 核对密码表。这时 Linux 会进入 **/etc/shadow** 里面找出对应的用户，然后核对一下你刚刚输入的密码与里头的密码是否相符；
3. 如果一切都 OK 的话，就进入 Shell 控管的阶段。

## 3 用户管理

### 3.1 添加用户：useradd

命令格式：`useradd [选项] 用户名`

- 选项：
  - `-u 用户ID`：指定用户ID。一般指定 UID 要大于500，如果没有特殊需求尽量不要指定，由系统自动分配即可
  - `-g 初始组名`：指定用户所属初始组。尽量不要指定，系统会自动创建一个和新增用户名相同的组最为该新增用户的初始组
  - `-G 附加组名`：指定用户所属附加组。如果要指定多个附加组，组名用 "," 隔开
  - `-c 说明文字`：加上备注文字。备注文字会保存在 "/etc/passwd" 文件的第 5 列
  - `-d 家目录`：指定用户家目录
  - `-s shell`：指定用户登入后所使用的 shell 程序

### 3.2 用户密码设定：passwd

刚添加成功的用户没有密码(此时该用户的密码是 "`!!`" )，还不能用于登录系统，需要通过 "`passwd`" 命令设置密码后才能登录。当然，"`passwd`" 命令也能用来修改已存在的用户密码，以及管理用户密码有效时间等。

命令格式：`passwd [选项] [用户名]`

- 选项：
  - `-l` 或 `--lock`：临时锁住密码使密码失效。即把 "/etc/shadow" 第二列密文密码前面多加个 "!!"
  - `-u` 或 `--unlock`：解开已锁住的用户密码。相对于 `-l` 的反向操作
  - `-d` 或 `--delete`：删除现有用户的密码
  - `-n 天数`：两次密码修改时间间隔。对应"/etc/shadow" 第 4 列
  - `-x 天数`：密码有效期。对应"/etc/shadow" 第 5 列。
  - `-w 天数`：密码到期前的警告天数。对应"/etc/shadow" 第 6 列
  - `-i 天数`：密码到期后的宽限天数。对应"/etc/shadow" 第 7 列
  - `-S` 或 `--status`：显示用户密码状态
  - `--stdin`：从标准输入读取令牌。主要用在通过脚本批量添加用户，不需要交互的场景
    - 示例，修改 "user1" 的密码为 "123456"：`echo "123456" | passwd --stdin user1` 。尽量不要在shell里这样操作，`history` 会记录执行过的历史命令，设置的密码可能不被泄露
- `用户名`：用户名省略，默认修改当前登录用户的密码。一般用户修改自己的密码直接执行 "`passwd`" 即可

> **注意：只有`管理者才能修改其他用户的密码`，普通用户只能修改自己的密码**

### 3.3 用户信息修改：usermod

命令格式：`usermod [选项] 用户名`

- 选项：
  - `-u 用户ID`：修改用户ID
  - `-d 家目录`：修改用户家目录
  - `-c 用户说明`：修改用户说明
  - `-g 初始组名`：修改用户初始组
  - `-G 附加组名`：修改用户附加组
  - `-s shell`：修改用户登入后所使用的 shell 程序
  - `-e 日期`：修改账号失效日期，格式是 "YYYY-MM-DD"。即修改 /etc/shadow 第 8 列数据
  - `-l 新用户名`：修改用户名
  - `-L`：临时锁定账号。与 "`passwd -l 用户名`" 作用一样
  - `-U`：解锁账号

### 3.3 用户删除：userdel

命令格式：`userdel [选项] 用户名`

- 选项：
  - `-r`：同时删除用户家目录和用户邮件

## 4 用户组管理

### 4.1 添加组：groupadd

命令格式：`groupadd [选项] 组名`

- 选项：
  - `-g 组ID`：指定组ID
  - `-r`：创建系统用户组，系统用户组的组ID小于500。与 /etc/login.defs 内的 GID_MIN 有关

### 4.2 组信息修改：groupmod

命令格式：`groupmod [选项] 组名`

- 选项：
  - `-g 组ID`：修改组ID
  - `-n 新组名`：修改组名

### 4.3 组删除：groupdel

命令格式：`groupdel 组名`

**注意：如果用户组是某个用户的初始组，必须先删除这个用户或者修改该用户的GID后，才能删除该用户组**

### 4.4 切换有效组：newgrp

如果用户 user1 有个多个用户组(初始组：user1，附加组：group1，group2)，则登录后默认的有效组是该用户的初始组user1，此时该用户创建的文件所属组就是 user1，如果让该用户创建的文件所属组为 group1，就需要使用 "`newgrp`" 命令切换有效组为 group1

命令格式：`newgrp 组名`

### 4.5 组密码和组管理员功能：gpasswd

如果管理员太忙了，可以为某个用户组设置一个管理员来帮忙管理该组成员用户。 一般组密码和组管理员功能其实很少使用了，完全可以由 "`sudo`" 取代。

命令格式：`gpasswd [选项] 组名`

- 选项：
  - `-a 用户名`：添加用户到该组
  - `-d 用户名`：从组中删除某个用户
  - `-A 用户1,用户2,...`：添加组管理员列表
  - `-M 用户1,用户2,...`：添加组成员列表。注意，`-a` 是追加，`-M` 是会覆盖原有值
  - `-r`：删除组密码
  - `-R`：使组密码失效
  - 不加任何选项，即 `gpasswd 组名`：设置用户组密码

> 注意：如果某个用户组设置了组密码，就代表允许非该组内的用户可以通过 "`newgrp `" 命令(会提示输入密码)，切换有效组为该组。相当于把非该组内的用户临时添加到了该组，只是临时生效，并没有修改 "/etc/group" 和 "/etc/gshadow" 文件

## 5 扩展命令

### 5.1 查询用户UID/GID等信息：id

命令格式：`id [选项] [用户名]`

- 选项：一般使用不加任何选项，
  - `-g`：仅显示该用户当前有效的用户组ID
  - `-G`：显示该用户所有用户组ID
  - `-u`：仅显示该用户ID
  - `-Z`：仅显示当前用户的安全环境
- 用户名：省略代表查询当前进程用户

> 该命令使用一般不加任何选项，基本能输出所有要查询的信息。例如直接执行 "`id`" 或 "`id root`"

### 5.2 查询用户所在全部组名称：groups

命令格式：`groups [用户1] [用户2] ...`

- 参数省略，即直接执行 "`groups`"，代表查询当前进程用户

> 查询出来的第一个组是当前有效组

### 5.3 显示当前登录用户名：whoami

命令格式：`whoami`

- 不需要任何选项和参数，直接执行即可

### 5.4 显示当前已登录用户信息：w、who

`w` 和 `who` 命令作用相似都是显示系统中正在登录的用户信息，这两个命令查询信息都来源于日志文件 "/var/run/utmp"。

**w** 命令格式：`w [选项] [用户名]`

- 选项：
  - `-h`：不打印头信息
  - `-u`：当显示当前进程和cpu时间时忽略用户名
  - `-s`：使用短输出格式
  - `-f`：显示用户从哪登录
  - `-i`：登录来源展示ip地址而不是主机名
- 用户：仅显示指定用户

示例：

```shell
[root@localhost ~]# w
 18:31:08 up 1 day, 16 min,  3 users,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     tty1     -                Sat18   49:23   0.07s  0.07s -bash
root     pts/0    192.168.199.119  18:22    8:17   0.02s  0.02s -bash
root     pts/1    192.168.199.119  18:22    0.00s  0.03s  0.00s w
```

输出内容说明：

- 第一行内容：
  - 18:31:08：系统当前时间
  - up 1 day, 16 min：系统的运行时间
  - 3 users：当前登录终端数量
  - load average: 0.00, 0.00, 0.00：系统在之前1分钟、5分钟、15分钟的平均负载。如果CPU是单核的，则这个数据超过1就是高负载；如果CPU是四核的，则这个数值超过4就是高负载
- 第二行内容：
  - USER：当前登录的用户
  - TTY：登录的终端。tty1-6: 本地字符终端(alt+F1-6 切换)，tty7: 本地图形终端(ctrl+F7切换，必须安装启动图形界面)，pts/0-255: 远程终端
  - FROM：登录的IP地址，如果是本地终端，则是空
  - LOGIN@：登录时间
  - IDLE：用户空闲时间
  - JCPU：所有的进程占用的CPU时间
  - PCPU：当前进程占用的CPU时间
  - WHAT：用户正在进行的操作

**who** 命令格式：`who [选项] [查询文件]`

- 选项：
  - `-H`：显示各栏位的标题信息列
  - `-q`：只显示登入系统的帐号名称和总人数
  - `-w`：显示用户的信息状态栏
  - `-u`：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成"."号，如果该用户已超过24小时没有任何动作，则标示出"old"字符串
- 查询文件：指定要查询的文件，默认是/var/run/utmp

### 5.5 更改使用的shell：chsh

命令格式：`chsh [选项] [用户名]`

- 选项：
  - `-l`：列出目前系统所有可用shell。其实就是输出 "/etc/shells" 文件内容
  - `-s 新shell程序`：指定要设定的shell。其实就是修改上面说到的 "/etc/passwd" 文件的第 7 列数据
- 用户名：省略则默认是操作当前登录用户

### 6 添加用户默认值配置

`useradd` 命令添加用户时，有些选项如果不指定的话都会有默认值，比如家目录。添加用户时默认值的参考文件主要有两个，分别是 **"/etc/default/useradd"** 和 **"/etc/login.defs"**，下面对文件内容一一进行说明

**/etc/default/useradd 文件**，内容如下：

```
[root@localhost ~]# cat /etc/default/useradd 
# useradd defaults file
GROUP=100
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=yes
```

- `GROUP=100`：默认初始组ID，就是说新添用户时的默认初始组是 users 组(users组的GID就是100)，但是你看到的现象可能并不是这样，而是创建了一个和用户名一样的用户组作为该新用户的初始组。这是因为针对用户组有两种不同的机制，这两种机制分别是：
  - **私有群组机制**：系统会建立一个与用户名一样的群组给用户作为初始群组。 这种群组的设定机制会比较有保密性，用户都有自己的群组，而且家目录权限将会设定为 700 (仅有自己可进入自己的家目录)。使用这种机制就不会参考 GROUP=100 这个设定值了。代表性的Linux发行版有 RHEL，Fedora，CentOS 等
  - **公共群组机制**：就是以 GROUP=100 这个设定值作为新建用户的初始群组，因此每个账号都属于 users 这个群组，且默认家目录通常的权限会是 "drwxr-xr-x"，由于每个账号都属于 users 群组，因此大家都可以互相分享家目录内的数据。代表Linux发行版有 SuSE 等
- `HOME=/home`：用户家目录位置。即每个新建用户会在该目录下新建一个和用户名一样的目录来存放该用户的文件
- `INACTIVE=-1`：密码过期后的宽限天数。即对应 "/etc/shadow" 文件的第 7 列。这里的值是天数，如果是 0 代表密码过期立刻失效；如果是 -1 则是代表密码永远不会失效；如果是其他数字如 30 ，则代表密码过期后 30 天后才失效
- `EXPIRE=`：默认失效的日期。即对应 "/etc/shadow" 文件的第 7 列。默认值是空，代表永久有效
- `SHELL=/bin/bash`：使用的 shell 程序。即对应 "/etc/passwd" 文件的第 7 列
- `SKEL=/etc/skel`：新建用户家目录的模板文件。该目录下的文件会全部原封不动的复制到新用户的家目录下
- `CREATE_MAIL_SPOOL=yes`：是否给新用户建立邮箱。这里默认创建，就是说新建用户会创建一个和用户名一样的文件放在 "/var/spool/mail/" 目录(该目录由 "/etc/login.defs" 文件指定的) 下

**/etc/login.defs 文件**，内容如下：

```
[root@localhost ~]# cat /etc/login.defs 
...(注释内容省略)...
MAIL_DIR    /var/spool/mail

PASS_MAX_DAYS    99999
PASS_MIN_DAYS    0
PASS_MIN_LEN    5
PASS_WARN_AGE    7

UID_MIN              500
UID_MAX            60000
GID_MIN              500
GID_MAX            60000

CREATE_HOME    yes
UMASK           077
USERGROUPS_ENAB yes
ENCRYPT_METHOD SHA512 
```

- `MAIL_DIR /var/spool/mail`：默认邮箱目录
- `PASS_MAX_DAYS 99999`：密码有效期。对应 "/etc/shadow" 文件的第 5 列
- `PASS_MIN_DAYS 0`：两次密码修改时间隔。对应 "/etc/shadow" 文件的第 4 列
- `PASS_MIN_LEN 5`：密码最小长度。已被 PAM 模块取代，这里不再生效
- `PASS_WARN_AGE 7`：密码到期前的警告天数。对应 "/etc/shadow" 文件的第 6 列
- `UID_MIN 500`：最小UID
- `UID_MAX 60000`：最大UID
- `GID_MIN 500`：最小GID
- `GID_MAX 60000`：最大GID
- `CREATE_HOME yes`：创建用户时是否为其创建家目录。默认创建
- `UMASK 077`：新建用户家目录的默认权限。这里值为 077，那么新建用户家目录的权限是 700，即 "drwx------"
- `USERGROUPS_ENAB yes`：使用 `userdel` 命令删除用户时，如果所属的初始组已经没有其他用户隶属于该组了，是否删除该用户的初始组。默认是删除
- `ENCRYPT_METHOD SHA512`：密码加密方式。加密方式有：SHA512、DES、MD5

## 7 用户身份切换(su与sudo)

当用普通账号登录系统，需要执行某些操作但是权限不足，这时就需要切换到更高权限的用户身份去执行啦。这里就涉及到两个命令的使用 **su** 和 **sudo**

### 7.1 su

**su** 是最简单的用户身份切换命令，可以进行任何身份的切换。除了 root 用户切换到其他用户不需要输入密码外，其他情况使用 **"su"** 命令切换用户时都必须输入要切换用户的登录密码

命令格式：`su [选项] [用户名]`

- 选项：
  - `-` 或 `-l` 或 `--login`：使用 login-shell 的变量文件读取方式来登录系统。即切换身份时同时切换环境变量，如果不加该选项的话，用户切换后环境变量还是旧的，建议每次切换都带上该选项
  - `-c 命令`：只是以某个用户执行一次指令，而不切换用户身份
- `用户名`：要切换的用户。如果省略则代表切换到 root 用户

示例：

```
# 1. 从 user1 切换至 root 用户，提示输入密码
[user1@localhost ~]$ su -
密码：
# 2. 查看 /root/aaa.txt 文件权限、所有者和所属组
[root@localhost ~]# ls -l aaa.txt 
-rw-r--r--. 1 root root 17 4月  18 19:15 aaa.txt
# 3. 从 root 用户切换至 user2 用户，不需要输入密码直接切换成功
[root@localhost ~]# su - user2
# 4. 查看 user2 用户所属组。不在 root 组，即不能查看/root/aaa.txt内容
[user2@localhost ~]$ id user2
uid=502(user2) gid=502(user2) 组=502(user2),501(user1)
# 5. 使用 root 身份执行一次查看指令，而不切换身份
[user2@localhost ~]$ su -c "cat /root/aaa.txt" root
密码：
aaaaaaaaaaaaaaaa
[user2@localhost ~]$ 
```

### 7.2 sudo

虽然 **su** 很方便了，但是如果有很多人都需要切换 root 身份来执行某些指令，就必须知道 root 密码，这样容易导致密码流出，很不妥。相对于 **su** 必须知道要切换的用户密码，而使用 **sudo** 来切换身份只需要知道用户自己的密码即可。并不是所有用户都能使用 sudo 切换身份，前提必须是由管理员审核后，给用户开放了 **sudo** 权限才能使用，能使用 **sudo** 其实就已经代表是受信任的用户了，这也是使用 **sudo**不要需要知道切换用户密码的原因。

命令格式：`sudo [选项] 原始命令`

- 选项：
  - `-u 用户名`：要使用的用户身份，省略此选项默认是 root 身份
  - `-b`：在后台执行指令

示例，

```
# 1. 使用 user1 用户身份创建文件 /tmp/aaa.txt
[root@localhost ~]# sudo -u user1 touch /tmp/aaa.txt
# 2. 查看 /tmp/aaa.txt，发现文件所属者和所属组都是 user1，而不是 root
[root@localhost ~]# ls -l /tmp/aaa.txt 
-rw-r--r--. 1 user1 user1 0 4月  18 21:32 /tmp/aaa.txt
[root@localhost ~]# 
```

**sudo** 预设只有 root 用户能够使用，那么普通用户如何才能使用 **sudo** 来获取其他用户身份呢？这就涉及到 **"/etc/sudoers"** 文件的配置，因为 **sudo** 的执行流程是这样的：

1. 当用户执行 **sudo** 时，系统于 **/etc/sudoers** 文件中搜寻该使用者是否有执行 **sudo** 的权限
2. 若使用者具有可执行 **sudo** 的权限，便让使用者**输入自己的密码**来确认
3. 若密码输入成功，便开始进行 **sudo** 后续接的指令
4. 若欲切换的身份与执行者身份相同或者 root 用户执行 **sudo** 时，不需要输入密码

所以用户能否使用 **sudo**，只需要编辑 **/etc/sudoers** 文件就可以了。因为该文件有一定的规范性，直接使用 vi 去编辑不是太好，因此系统提供了一个命令 `visudo` 专门来编辑这个文件，并在编辑完成退出编辑界面时去进行校验该文件的语法。下面对该文件内容进行介绍：

```
[root@localhost ~]# visudo

...省略...
# 使用者  来源主机=(可切换的身份) 可执行的命令
root      ALL=(ALL)             ALL
```

- **使用者**：可以是 "`用户名`" 或者 "`%组名`" ，指给哪个用户或者用户组下的所有用户授予 **sudo** 权限。注意如果是用户组，前面要加 "`%`"
- **来源主机**：登录者的来源主机。意思是这个用户可由哪一部网络主机联机过来，这个可以指定受信任客户端计算机来源。"`ALL`" 代表所有主机
- **可切换的身份**：使用者可以切换成什么身份。"`ALL`" 代表任意身份。这个字段可以省略，默认可切换 root 身份。
- **可执行的命令**：可用切换身份下达什么指令，**指令务必写绝对路径**。"`ALL`" 代表全部指令。前面如果加了 "`NOPASSWD:`"，则使用 **sudo** 时可以免密码(使用者自己的密码)输入

示例，

```
# 1. 授权user1可以切换root身份重启服务器。可切换身份省略默认就是root身份
user1 ALL= /sbin/shutdown -r now 
# 等同于上面一条
user1 ALL=(root) /sbin/shutdown -r now

# 2. 授权user1可以修改其他用户密码，但是不能修改root密码。! 是不可执行的意思
user1 ALL=(root) !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root

# 3. 授权wheel用户组所有身份权限，并且免密码输入
%wheel ALL=(ALL) NOPASSWD: ALL

# 4. 设置别名。User_Alias(设置用户别名)、Cmnd_Alias(设置命令别名)、Host_Alias(设置来源主机名别名)
# 注意别名一定要用大写字母，入下面的 ADMPW、ADMPWCOM
User_Alias ADMPW = user1, user2, user3
Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
ADMPW ALL=(root) ADMPWCOM
```

## 8. 添加root用户

- 添加普通用户

```shell
//添加一个名为tommy的用户  
adduser tommy  
//修改密码  
passwd tommy   
#Changing password for user tommy.  
#New UNIX password:     //在这里输入新密码  
#Retype new UNIX password:  //再次输入新密码  
#passwd: all authentication tokens updated successfully.  
```

- 赋予root权限

```shell
#修改 /etc/sudoers 文件，找到下面一行，把前面的注释（#）去掉
## Allows people in group wheel to run all commands  
%wheel    ALL=(ALL)    ALL  
#
usermod -g root tommy 
```

- 赋予Root权限方法二

```shell
tommy:x:0:33:tommy:/data/webroot:/bin/bash  
```



---

> 作者: liudongdong1  
> URL: liudongdong1.github.io/useroperation/  

