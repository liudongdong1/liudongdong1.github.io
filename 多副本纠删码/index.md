# 多副本&纠删码


### 一、Erasure Coding（纠删码）和Raid比较

（1）EC算法是跨节点的，4+2:1的冗余允许1个节点故障而不丢失数据，RAID5一般是由节点内的若干块盘组成RAID组的，只能容忍硬盘故障，不能容忍节点故障。
（2）EC算法采用全局热备的方式，不需要单独的热备盘，所有硬盘都可参与数据读写，只要系统中有剩余空间，就可以恢复故障数据；RAID5方式单节点至少准备一块全局热备盘。
（3）4+2:1的EC方式允许损害任意的2块盘而不丢失数据，RAID5方式每个RAID组最多只允许损害1块盘，所谓的允许损坏多块盘是建立在所有坏盘都不位于相同RAID组中的，从实际经验来看，把数据安全建立在理想情况下是不靠谱的。
（4）当出现硬盘故障时，EC方式是多块盘参与数据恢复，RAID方式只有1块盘（热备盘）能够写数据，这就导致EC方式的数据恢复效率（1TB/小时）是RAID方式的几十倍，这也大大减少了数据恢复期间硬盘再次故障的可能（目前单盘容量都达到数个TB使得该风险急剧增加），进一步提升了系统的安全性。
（5）EC方式的保护级别可以针对目录设置，重要的数据目录可以设置更高的保护级别以确保安全性，随着节点扩容，数据条带大小还能自动调整以获取更高的空间利用率；RAID方式所有数据的保护级别是相同的，RAID组一旦划分完不能够再调整。
（6）RAID方式需要独立的RAID卡，EC方式不需要额外的硬件支持。

### 二、Erasure Coding（纠删码）介绍

传统的硬盘级RAID模式将数据存放于单节点内的不同硬盘，当整节点发生故障时，无法有效恢复数据。为了避免数据丢失，存储系统需要将数据在节点间进行冗余保护。Erasure Coding（简称EC，即纠删码）是一种冗余保护机制，通过计算校验片的方式实现数据冗余保护。

分布式存储系统在写入数据时，将数据切分为N个数据块（N为偶数），通过EC编码算法计算得到M个校验块（M取值2、3或4）。

服务器级安全：将N+M个数据块和校验块存储于不同的节点中，故障M个节点或M块硬盘，系统仍可正常读写数据，业务不中断，数据不丢失。
机柜级安全：将N+M个数据块和校验块存储于不同的机柜中，故障M个机柜、不同机柜的M个节点或M块硬盘，系统仍可正常读写数据，业务不中断，数据不丢失。
EC冗余方式的空间利用率约为N/(N+M)，N越大，空间利用率越高，数据的可靠性由M值的大小决定，M越大可靠性越高。具体的冗余配比关系可以参见本章节末尾的“EC冗余配比表”，基于性能和可靠性综合考虑，推荐配置4+2。

> 说明：机柜级安全和服务器级安全的原理类似，以下内容以服务器级安全为例介绍其不同场景的读写原理。

#### 2.1正常场景时EC读写原理

当存储节点的个数≥N+M时采用N+M冗余配比，当（N+M）/M≤存储节点的个数＜N+M时采用N+M:1冗余配比。
N+M：将N个数据块和M个校验块随机存储于不同的节点中（因为存储节点的个数大于N+M同时基于可靠性的考虑，数据块将存储于不重复的节点），此时存储池允许故障M块盘或M个节点。
以N=4、M=2、存储节点个数=7为例：

- 写原理：如图1-2所示，用户写入数据Data后被系统切分为4个数据块（D1D4），同时通过EC编码得到2个校验码（C1C2），系统将6个数据块随机存入6个节点中。
  图1-2 使用EC（N+M）写入数据

![](https://gitee.com/github-25970295/blogimgv2022/raw/master/fbbf438379e74751b238e5a1b5651a5d.png)

- 读原理：如图1-3所示，系统从4个节点的不同硬盘中读取数据块（D1~D4），并通过Copy的方式将这4个数据块拼装成Data返回给用户。
  图1-3 使用EC（N+M）读取数据

![](https://gitee.com/github-25970295/blogimgv2022/raw/master/c7bf1857fda844b9ba357a2d0f011a3f.png)
N+M:1（折叠)：将N个数据块和M个校验块随机打散存放于所有节点，每个节点都存在存放M个分片的情况，此时存储池允许故障M块硬盘或1个节点。
以N=4、M=2、存储节点个数=5为例：

- 写原理：如图1-4所示，用户写入数据Data后被系统切分为4个数据块（D1D4），同时通过EC编码得到2个校验码（C1C2），系统将6个数据块随机打散存放在5个节点中。
  此时以Node3存放2个分片为例，故障Node3和其他任意一个节点时，故障的分片数量（3个）超过系统允许故障的个数M（2个），因此当N+M:1（折叠）时，**只允许故障1个节点。**
  图1-4 使用EC（N+M:1）写入数据

![](https://gitee.com/github-25970295/blogimgv2022/raw/master/0719f9ab16ee476c963eb33c5a7f547d.png)

- 读原理：如图1-5所示，系统从3个节点的不同硬盘中读取数据块（D1~D4），并通过Copy的方式将这4个数据块拼装成Data返回给用户。
  图1-5 使用EC（N+M:1）读取数据

![](https://gitee.com/github-25970295/blogimgv2022/raw/master/06883400751d4508867193847e7f8cac.png)

> 说明：扩容后，当存储节点数量≥N+M时，系统会通过后台自动均衡将N+M:1展开为N+M。

#### 2.2故障场景时EC读写原理

故障场景写原理（N+M冗余配比）

- 当故障后的剩余存储节点数量≥N+M，系统会重新分配一个新节点组成N+M冗余，保证数据冗余不降低。
  以N=4、M=2、存储节点个数=7为例，如图1-6所示，当故障Node6节点后，剩余6个节点仍满足4+2的情况，系统分配Node7存放数据块D2。

  图1-6 故障场景写原理（剩余存储节点的数量≥N+M）

![](https://gitee.com/github-25970295/blogimgv2022/raw/master/9c87e7fa21634c1cb97f88692cc26a75.png)

- 当故障后的剩余存储节点数量＜N+M时，在故障恢复前系统会将新写入的数据缩列为N/2+M，保证IO不中断的同时可靠性级别不降低，故障恢复后，系统冗余配比恢复为N+M。
  以N=4、M=2、存储节点个数=6为例，如图1-7所示，数据Data1在以4+2的冗余配比写入过程中，EC成员节点突然故障，此时为了保证可靠性不变，系统将新写入的数据Data2缩列为2+2冗余配比。

  图1-7 数据写入原理（剩余节点数量＜N+M）
  ![](https://gitee.com/github-25970295/blogimgv2022/raw/master/900015f7cfd1435b9d331c4b3288ad1c.png)

**故障场景写原理（N+M:1冗余配比)**
当故障1个节点或M块硬盘后，系统仍然将N+M个数据块和校验块写入所有正常节点中。

**数据读取原理**
当EC成员节点或成员盘故障时，系统会读取任意N个数据（不管是数据分片还是校验分片），通过EC解码恢复数据。

以N=4、M=2为例：

- 冗余配比N+M：如图1-8所示，Node6和Node5发生故障，无法读取该节点的数据块D2和校验块C1，系统会从其他正常节点读取4个数据D1、D3、D4和C2，并通过解码获取Data返回给用户。
  图1-8 故障场景数据读取原理（N+M）
  ![](https://gitee.com/github-25970295/blogimgv2022/raw/master/ce9037a270534b3aac19968c75e3ed11.png)
- 冗余配比N+M:1：如图1-9所示，Node3发生故障，无法读取该节点的数据块D2、D3，系统会从其他正常节点读取4个数据D4、D1、C1和C2，并通过解码获取Data返回给用户。
  图1-9 故障场景数据读取原理（N+M:1）
  ![](https://gitee.com/github-25970295/blogimgv2022/raw/master/23d5893828214d10987965a1a5a2ab75.png)
  **故障场景时EC数据重构原理**
  当系统的EC成员盘或成员节点发生故障后，将读取其他正常盘的N个数据，通过解码的方式获取故障盘的数据块并将其存放至其他正常盘中，具体原理如图1-10所示。
  图1-10 数据重构原理
  ![](https://img-bc.icode.best/d7c1b1a1dd0048a19da717370a324af0.png)
  根据不同的故障场景，会采取不同的重构策略：
- 当硬盘发生故障时，存储池等待15分钟后启动数据重构。
- 当节点发生故障时，存储池还存在冗余保护时，延迟7天启动数据重构；当存储池不存在冗余保护时，延迟24小时启动数据重构。
  例如，6节点场景，EC冗余配比4+2，当故障1个节点，7天后启动数据重构；故障2个节点，24小时后启动数据重构。

#### 2.3EC冗余配比

![](https://gitee.com/github-25970295/blogimgv2022/raw/master/8d0c23a7c38f475388ae9089414d15ba.png)

### Resource

- https://icode.best/i/91066744163387

---

> 作者: liudongdong1  
> URL: https://liudongdong1.github.io/%E5%A4%9A%E5%89%AF%E6%9C%AC%E7%BA%A0%E5%88%A0%E7%A0%81/  

