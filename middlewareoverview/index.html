<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>middlewareOverview - DAY By DAY</title><meta name=author content="LiuDongdong"><meta name=author-link content="https://liudongdong1.github.io/"><meta name=description content="消息队列 已经逐渐成为企业应用系统 内部通信 的核心手段。它具有 低耦合、可靠投递、广播、流量控制、最终一致性 等一系列功能。 当前使用较多的 消息队列 有"><meta name=keywords content="Framework,Middleware"><meta itemprop=name content="middlewareOverview"><meta itemprop=description content="消息队列 已经逐渐成为企业应用系统 内部通信 的核心手段。它具有 低耦合、可靠投递、广播、流量控制、最终一致性 等一系列功能。 当前使用较多的 消息队列 有"><meta itemprop=datePublished content="2021-07-15T20:31:56+00:00"><meta itemprop=dateModified content="2023-09-28T22:47:26+08:00"><meta itemprop=wordCount content="5886"><meta itemprop=image content="/logo.png"><meta itemprop=keywords content="Framework,Middleware,"><meta property="og:title" content="middlewareOverview"><meta property="og:description" content="消息队列 已经逐渐成为企业应用系统 内部通信 的核心手段。它具有 低耦合、可靠投递、广播、流量控制、最终一致性 等一系列功能。 当前使用较多的 消息队列 有"><meta property="og:type" content="article"><meta property="og:url" content="liudongdong1.github.io/middlewareoverview/"><meta property="og:image" content="/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-15T20:31:56+00:00"><meta property="article:modified_time" content="2023-09-28T22:47:26+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo.png"><meta name=twitter:title content="middlewareOverview"><meta name=twitter:description content="消息队列 已经逐渐成为企业应用系统 内部通信 的核心手段。它具有 低耦合、可靠投递、广播、流量控制、最终一致性 等一系列功能。 当前使用较多的 消息队列 有"><meta name=application-name content="DAY By DAY"><meta name=apple-mobile-web-app-title content="DAY By DAY"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=liudongdong1.github.io/middlewareoverview/><link rel=prev href=liudongdong1.github.io/qbittorrent/><link rel=next href=liudongdong1.github.io/distributionalgorithm/><link rel=stylesheet href=/liudongdong1.github.io/css/style.min.css><link rel=stylesheet href=/liudongdong1.github.io/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/liudongdong1.github.io/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"middlewareOverview","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"liudongdong1.github.io\/middlewareoverview\/"},"genre":"posts","keywords":"Framework, Middleware","wordcount":5886,"url":"liudongdong1.github.io\/middlewareoverview\/","datePublished":"2021-07-15T20:31:56+00:00","dateModified":"2023-09-28T22:47:26+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"LiuDongdong","logo":"\/images\/person.png"},"author":{"@type":"Person","name":"liudongdong1"},"description":""}</script></head><body data-header-desktop=auto data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=liudongdong1.github.io/ title="DAY By DAY"><img class="lazyload logo" src=/liudongdong1.github.io/svg/loading.min.svg data-src=/fixit.min.svg data-srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x" data-sizes=auto alt="DAY By DAY" title="DAY By DAY"><span class=header-title-text></span></a><span id=typeit-header-subtitle-desktop class="typeit header-subtitle"></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item language"><span role=button aria-label=选择语言 title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item>没有更多翻译</li></ul></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=liudongdong1.github.io/ title="DAY By DAY"><img class="lazyload logo" src=/liudongdong1.github.io/svg/loading.min.svg data-src=/fixit.min.svg data-srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x" data-sizes=auto alt=/fixit.min.svg title=/fixit.min.svg><span class=header-title-text></span></a><span id=typeit-header-subtitle-mobile class="typeit header-subtitle"></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://liudongdong1.github.io/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li><li class="menu-item language"><span role=button aria-label=选择语言 title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span>
<select class=language-select onchange="location=this.value"><option disabled>没有更多翻译</option></select></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container data-page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom id=aside-sakana><div class=sakana-widget><div class=sakana-item id=takina-widget></div><div class=sakana-item id=chisato-widget></div></div><script>function initSakanaWidget(){const e=SakanaWidget.getCharacter("takina");SakanaWidget.registerCharacter("takina-slow",e),new SakanaWidget({character:"takina-slow",controls:!1,autoFit:!0,stroke:{color:"#b4b4b4",width:2}}).mount("#takina-widget");const t=SakanaWidget.getCharacter("chisato");SakanaWidget.registerCharacter("chisato-slow",t),new SakanaWidget({character:"chisato-slow",controls:!1,autoFit:!0,stroke:{color:"#b4b4b4",width:2}}).mount("#chisato-widget")}</script><script async onload=initSakanaWidget() src=https://cdn.jsdelivr.net/npm/sakana-widget@2.3.0/lib/sakana.min.js></script></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>middlewareOverview</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
liudongdong1</span></span>
<span class=post-category>收录于 <a href=liudongdong1.github.io/categories/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Categories</a>&ensp;<a href=liudongdong1.github.io/categories/framework/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Framework</a></span></div><div class=post-meta-line><span title="2021-07-15 20:31:56"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-07-15>2021-07-15</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 5886 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 12 分钟&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=middlewareOverview>
<i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class=featured-image><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://cdn.stocksnap.io/img-thumbs/280h/plant-leaves_RP9VPMSKFG.jpg data-srcset="https://cdn.stocksnap.io/img-thumbs/280h/plant-leaves_RP9VPMSKFG.jpg, https://cdn.stocksnap.io/img-thumbs/280h/plant-leaves_RP9VPMSKFG.jpg 1.5x, https://cdn.stocksnap.io/img-thumbs/280h/plant-leaves_RP9VPMSKFG.jpg 2x" data-sizes=auto alt=https://cdn.stocksnap.io/img-thumbs/280h/plant-leaves_RP9VPMSKFG.jpg title=https://cdn.stocksnap.io/img-thumbs/280h/plant-leaves_RP9VPMSKFG.jpg></div><div class="details toc" id=toc-static kept=true><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#1-消息队列概述>1. 消息队列概述</a></li><li><a href=#2-消息队列的特点>2. 消息队列的特点</a></li><li><a href=#3-消息队列的传递服务模型>3. 消息队列的传递服务模型</a></li><li><a href=#4-消息队列的的传输模式>4. 消息队列的的传输模式</a></li><li><a href=#5-消息队列应用场景>5. 消息队列应用场景</a></li><li><a href=#6-消息队列的推拉模型>6. 消息队列的推拉模型</a></li><li><a href=#7-消息队列技术对比>7. 消息队列技术对比</a></li><li><a href=#resource>Resource</a></li></ul></li></ul></nav></div></div><div class=content id=content><blockquote><p><strong>消息队列</strong> 已经逐渐成为企业应用系统 <strong>内部通信</strong> 的核心手段。它具有 <strong>低耦合</strong>、<strong>可靠投递</strong>、<strong>广播</strong>、<strong>流量控制</strong>、<strong>最终一致性</strong> 等一系列功能。</p><p>当前使用较多的 <strong>消息队列</strong> 有 <code>RabbitMQ</code>、<code>RocketMQ</code>、<code>ActiveMQ</code>、<code>Kafka</code>、<code>ZeroMQ</code>、<code>MetaMQ</code> 等，而部分 <strong>数据库</strong> 如 <code>Redis</code>、<code>MySQL</code> 以及 <code>phxsql</code> 也可实现消息队列的功能。</p></blockquote><h3 id=1-消息队列概述>1. 消息队列概述</h3><p><strong>消息队列</strong> 是指利用 <strong>高效可靠</strong> 的 <strong>消息传递机制</strong> 进行与平台无关的 <strong>数据交流</strong>，并基于 <strong>数据通信</strong> 来进行分布式系统的集成。通过提供 <strong>消息传递</strong> 和 <strong>消息排队</strong> 模型，它可以在 <strong>分布式环境</strong> 下提供 <strong>应用解耦</strong>、<strong>弹性伸缩</strong>、<strong>冗余存储</strong>、<strong>流量削峰</strong>、<strong>异步通信</strong>、<strong>数据同步</strong> 等等功能，其作为 <strong>分布式系统架构</strong> 中的一个重要组件，有着举足轻重的地位。</p><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c77109d data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c77109d, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c77109d 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c77109d 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c77109d title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c77109d></p><h3 id=2-消息队列的特点>2. 消息队列的特点</h3><h4 id=1-采用异步处理模式>.1. 采用异步处理模式</h4><blockquote><p><strong>消息发送者</strong> 可以发送一个消息而无须等待响应。<strong>消息发送者</strong> 将消息发送到一条 <strong>虚拟的通道</strong>（<strong>主题</strong> 或 <strong>队列</strong>）上，<strong>消息接收者</strong> 则 <strong>订阅</strong> 或是 <strong>监听</strong> 该通道。一条信息可能最终转发给 <strong>一个或多个</strong> 消息接收者，这些接收者都无需对 <strong>消息发送者</strong> 做出 <strong>同步回应</strong>。整个过程都是 <strong>异步的</strong>。</p></blockquote><h4 id=2-应用系统之间解耦合>.2. 应用系统之间解耦合</h4><blockquote><p>主要体现在如下两点：</p><ol><li>发送者和接受者不必了解对方、只需要 <strong>确认消息</strong>；</li><li>发送者和接受者 <strong>不必同时在线</strong>。</li></ol><p>比如在线交易系统为了保证数据的 <strong>最终一致</strong>，在 <strong>支付系统</strong> 处理完成后会把 <strong>支付结果</strong> 放到 <strong>消息中间件</strong> 里，通知 <strong>订单系统</strong> 修改 <strong>订单支付状态</strong>。两个系统是通过消息中间件解耦的。</p></blockquote><h3 id=3-消息队列的传递服务模型>3. 消息队列的传递服务模型</h3><p>消息队列的 <strong>传递服务模型</strong> 如下图所示：</p><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c831340 data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c831340, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c831340 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c831340 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c831340 title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c831340></p><h3 id=4-消息队列的的传输模式>4. 消息队列的的传输模式</h3><h4 id=1-点对点模型>.1. 点对点模型</h4><blockquote><p><strong>点对点模型</strong> 用于 <strong>消息生产者</strong> 和 <strong>消息消费者</strong> 之间 <strong>点到点</strong> 的通信。消息生产者将消息发送到由某个名字标识的特定消费者。这个名字实际上对于消费服务中的一个 <strong>队列</strong>（<code>Queue</code>），在消息传递给消费者之前它被 <strong>存储</strong> 在这个队列中。<strong>队列消息</strong> 可以放在 <strong>内存</strong> 中也可以 <strong>持久化</strong>，以保证在消息服务出现故障时仍然能够传递消息。</p></blockquote><p>传统的点对点消息中间件通常由 <strong>消息队列服务</strong>、<strong>消息传递服务</strong>、<strong>消息队列</strong> 和 <strong>消息应用程序接口</strong> <code>API</code> 组成，其典型的结构如下图所示。</p><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c97b0c3 data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c97b0c3, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c97b0c3 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c97b0c3 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c97b0c3 title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c97b0c3></p><p><strong>特点：</strong></p><ol><li><code>每个消息只用一个消费者</code>；</li><li>发送者和接受者<code>没有时间依赖</code>；</li><li><code>接受者确认消息接受和处理成功</code>。</li></ol><p><strong>示意图如下所示：</strong></p><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c89962f data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c89962f, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c89962f 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c89962f 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c89962f title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7c89962f></p><h4 id=2-发布订阅模型pubsub>.2. 发布/订阅模型（Pub/Sub）</h4><blockquote><p><strong>发布者/订阅者</strong> 模型支持向一个特定的 <strong>消息主题</strong> 生产消息。<code>0</code> 或 <strong>多个订阅者</strong> 可能对接收来自 <strong>特定消息主题</strong> 的消息感兴趣。在这种模型下，发布者和订阅者彼此不知道对方，就好比是匿名公告板。这种模式被概况为：多个消费者可以获得消息，在 <strong>发布者</strong> 和 <strong>订阅者</strong> 之间存在 <strong>时间依赖性</strong>。发布者需要建立一个 <strong>订阅</strong>（<code>subscription</code>），以便能够消费者订阅。<strong>订阅者</strong> 必须保持 <strong>持续的活动状态</strong> 并 <strong>接收消息</strong>。</p></blockquote><p>在这种情况下，在订阅者 <strong>未连接时</strong>，发布的消息将在订阅者 <strong>重新连接</strong> 时 <strong>重新发布</strong>，如下图所示：</p><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7faf60a5 data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7faf60a5, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7faf60a5 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7faf60a5 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7faf60a5 title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e7faf60a5></p><p><strong>特性：</strong></p><ol><li><code>每个消息可以有多个订阅者</code>；</li><li><code>客户端只有订阅后才能接收到消息</code>；</li><li><code>持久订阅和非持久订阅</code>。</li></ol><blockquote><p>注意：</p><ol><li><code>发布者和订阅者有时间依赖</code>：接受者和发布者只有建立订阅关系才能收到消息；</li><li>持久订阅：订阅关系建立后，<code>消息就不会消失，不管订阅者是否都在线</code>；</li><li>非持久订阅：<code>订阅者为了接受消息，必须一直在线</code>。 当只有一个订阅者时约等于点对点模式</li></ol></blockquote><h3 id=5-消息队列应用场景>5. 消息队列应用场景</h3><blockquote><p>当你需要使用 <strong>消息队列</strong> 时，首先需要考虑它的必要性。可以使用消息队列的场景有很多，最常用的几种，是做 <strong>应用程序松耦合</strong>、<strong>异步处理模式</strong>、<strong>发布与订阅</strong>、<strong>最终一致性</strong>、<strong>错峰流控</strong> 和 <strong>日志缓冲</strong> 等。反之，如果需要 <strong>强一致性</strong>，关注业务逻辑的处理结果，则使用 <code>RPC</code> 显得更为合适。</p></blockquote><h4 id=1-异步处理>.1. 异步处理</h4><blockquote><ul><li><strong>非核心</strong> 流程 <strong>异步化</strong>，减少系统 <strong>响应时间</strong>，提高 <strong>吞吐量</strong>。例如：<strong>短信通知</strong>、<strong>终端状态推送</strong>、<code>App</code> <strong>推送</strong>、<strong>用户注册</strong> 等。</li><li><strong>消息队列</strong> 一般都内置了 <strong>高效的通信机制</strong>，因此也可以用于单纯的消息通讯，比如实现 <strong>点对点消息队列</strong> 或者 <strong>聊天室</strong> 等。</li></ul></blockquote><ul><li><strong>应用案例</strong>: 网站用户注册，注册成功后会过一会发送邮件确认或者短息。</li></ul><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e800ce905 data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e800ce905, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e800ce905 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e800ce905 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e800ce905 title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8e800ce905></p><h4 id=2-系统解耦>.2. 系统解耦</h4><blockquote><ul><li>系统之间不是 <strong>强耦合的</strong>，<strong>消息接受者</strong> 可以随意增加，而不需要修改 <strong>消息发送者的代码</strong>。<strong>消息发送者</strong> 的成功不依赖 <strong>消息接受者</strong>（比如：有些银行接口不稳定，但调用方并不需要依赖这些接口）。</li><li><strong>不强依赖</strong> 于非本系统的核心流程，对于 <strong>非核心流程</strong>，可以放到消息队列中让 <strong>消息消费者</strong> 去按需消费，而 <strong>不影响核心主流程</strong>。</li></ul></blockquote><h4 id=3-最终一致性>.3. 最终一致性</h4><p><strong>最终一致性</strong> 不是 <strong>消息队列</strong> 的必备特性，但确实可以依靠 <strong>消息队列</strong> 来做 <strong>最终一致性</strong> 的事情。</p><ul><li><strong>先写消息再操作</strong>，确保操作完成后再修改消息状态。<strong>定时任务补偿机制</strong> 实现消息 <strong>可靠发送接收</strong>、业务操作的可靠执行，要注意 <strong>消息重复</strong> 与 <strong>幂等设计</strong>。</li><li>所有不保证 <code>100%</code> <strong>不丢消息</strong> 的消息队列，理论上无法实现 <strong>最终一致性</strong>。</li></ul><blockquote><p>像 <code>Kafka</code> 一类的设计，在设计层面上就有 <strong>丢消息</strong> 的可能（比如 <strong>定时刷盘</strong>，如果掉电就会丢消息）。哪怕只丢千分之一的消息，业务也必须用其他的手段来保证结果正确。</p></blockquote><h4 id=4-广播>.4. 广播</h4><blockquote><p><strong>生产者/消费者</strong> 模式，只需要关心消息是否 <strong>送达队列</strong>，至于谁希望订阅和需要消费，是 <strong>下游</strong> 的事情，无疑极大地减少了开发和联调的工作量。</p></blockquote><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea267f536 data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea267f536, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea267f536 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea267f536 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea267f536 title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea267f536></p><h4 id=5-流量削峰和流控>.5. 流量削峰和流控</h4><blockquote><p>当 <strong>上下游系统</strong> 处理能力存在差距的时候，利用 <strong>消息队列</strong> 做一个通用的 <strong>“漏斗”</strong>，进行 <strong>限流控制</strong>。在下游有能力处理的时候，再进行分发。</p></blockquote><blockquote><p>举个例子：用户在支付系统成功结账后，订单系统会通过短信系统向用户推送扣费通知。 <strong>短信系统</strong> 可能由于 <strong>短板效应</strong>，速度卡在 <strong>网关</strong> 上（每秒几百次请求），跟 <strong>前端的并发量</strong> 不是一个数量级。 于是，就造成 <strong>支付系统</strong> 和 <strong>短信系统</strong> 的处理能力出现差异化。</p></blockquote><p>然而用户晚上个半分钟左右收到短信，一般是不会有太大问题的。如果没有消息队列，两个系统之间通过 <strong>协商</strong>、<strong>滑动窗口</strong> 等复杂的方案也不是说不能实现。但 <strong>系统复杂性</strong> 指数级增长，势必在 <strong>上游</strong> 或者 <strong>下游</strong> 做 <strong>存储</strong>，并且要处理 <strong>定时</strong>、<strong>拥塞</strong> 等一系列问题。而且每当有 <strong>处理能力有差距</strong> 的时候，都需要 <strong>单独</strong> 开发一套逻辑来维护这套逻辑。所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。</p><ul><li><strong>应用案例</strong></li></ul><ol><li>把消息队列当成可靠的 <strong>消息暂存地</strong>，进行一定程度的 <strong>消息堆积</strong>；</li><li>定时进行消息投递，比如模拟 <strong>用户秒杀</strong> 访问，进行 <strong>系统性能压测</strong>。</li></ol><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea3e6231a data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea3e6231a, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea3e6231a 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea3e6231a 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea3e6231a title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea3e6231a></p><h4 id=6-日志处理>.6. 日志处理</h4><p>将消息队列用在 <strong>日志处理</strong> 中，比如 <code>Kafka</code> 的应用，解决 <strong>海量日志</strong> 传输和缓冲的问题。</p><ul><li><strong>应用案例</strong>: 把日志进行集中收集，用于计算 <code>PV</code>、<strong>用户行为分析</strong> 等等。</li></ul><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea41e864b data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea41e864b, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea41e864b 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea41e864b 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea41e864b title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea41e864b></p><h4 id=7-消息通讯>.7. 消息通讯</h4><blockquote><p>消息队列一般都内置了 <strong>高效的通信机制</strong>，因此也可以用于单纯的 <strong>消息通讯</strong>，比如实现 <strong>点对点消息队列</strong> 或者 <strong>聊天室</strong> 等。</p></blockquote><h3 id=6-消息队列的推拉模型>6. 消息队列的推拉模型</h3><h4 id=1-push推消息模型>.1. Push推消息模型</h4><blockquote><p><strong>消息生产者</strong> 将消息发送给 <strong>消息队列</strong>，<strong>消息队列</strong> 又将消息推给 <strong>消息消费者</strong>。</p></blockquote><h4 id=2-pull拉消息模型>.2. Pull拉消息模型</h4><blockquote><p><strong>消费者</strong> 请求 <strong>消息队列</strong> 接受消息，<strong>消息生产者</strong> 从 <strong>消息队列</strong> 中拉该消息。</p></blockquote><h4 id=3-两种类型的区别>.3. 两种类型的区别</h4><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea4b19ea9 data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea4b19ea9, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea4b19ea9 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea4b19ea9 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea4b19ea9 title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea4b19ea9></p><h3 id=7-消息队列技术对比>7. 消息队列技术对比</h3><h4 id=1-activem>.1. ActiveM</h4><blockquote><p><code>ActiveMQ</code> 是由 <code>Apache</code> 出品，<code>ActiveMQ</code> 是一个完全支持<code>JMS1.1</code> 和 <code>J2EE 1.4</code> 规范的 <code>JMS Provider</code> 实现。它非常快速，支持 <strong>多种语言的客户端</strong> 和 <strong>协议</strong>，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。</p></blockquote><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea7cdc2c0 data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea7cdc2c0, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea7cdc2c0 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea7cdc2c0 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea7cdc2c0 title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ea7cdc2c0></p><p><strong>(a) 主要特性</strong></p><ol><li><strong>服从JMS规范</strong>：<code>JMS</code> 规范提供了良好的标准和保证，包括：<strong>同步</strong> 或 <strong>异步</strong> 的消息分发，一次和仅一次的消息分发，<strong>消息接收</strong> 和 <strong>订阅</strong> 等等。遵从 <code>JMS</code> 规范的好处在于，不论使用什么 <code>JMS</code> 实现提供者，这些基础特性都是可用的；</li><li><strong>连接灵活性</strong>：<code>ActiveMQ</code> 提供了广泛的 <strong>连接协议</strong>，支持的协议有：<code>HTTP/S</code>，<code>IP</code> <strong>多播</strong>，<code>SSL</code>，<code>TCP</code>，<code>UDP</code> 等等。对众多协议的支持让 <code>ActiveMQ</code> 拥有了很好的灵活性；</li><li><strong>支持的协议种类多</strong>：<code>OpenWire</code>、<code>STOMP</code>、<code>REST</code>、<code>XMPP</code>、<code>AMQP</code>；</li><li><strong>持久化插件和安全插件</strong>：<code>ActiveMQ</code> 提供了 <strong>多种持久化</strong> 选择。而且，<code>ActiveMQ</code> 的安全性也可以完全依据用户需求进行 <strong>自定义鉴权</strong> 和 <strong>授权</strong>；</li><li><strong>支持的客户端语言种类多</strong>：除了 <code>Java</code> 之外，还有：<code>C/C++</code>，<code>.NET</code>，<code>Perl</code>，<code>PHP</code>，<code>Python</code>，<code>Ruby</code>；</li><li><strong>代理集群</strong>：多个 <code>ActiveMQ</code> <strong>代理</strong> 可以组成一个 <strong>集群</strong> 来提供服务；</li><li><strong>异常简单的管理</strong>：<code>ActiveMQ</code> 是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以 <strong>监控</strong> <code>ActiveMQ</code> 不同层面的数据，包括使用在 <code>JConsole</code> 或者在 <code>ActiveMQ</code> 的 <code>Web Console</code> 中使用 <code>JMX</code>。通过处理 <code>JMX</code> 的告警消息，通过使用 <strong>命令行脚本</strong>，甚至可以通过监控各种类型的 <strong>日志</strong>。</li></ol><p><strong>(b) 部署环境</strong></p><p><code>ActiveMQ</code> 可以运行在 <code>Java</code> 语言所支持的平台之上。使用 <code>ActiveMQ</code> 需要：</p><ul><li><code>Java JDK</code></li><li><code>ActiveMQ</code> 安装包</li></ul><p><strong>(c) 优点</strong></p><ol><li><strong>跨平台</strong> (<code>JAVA</code> 编写与平台无关，<code>ActiveMQ</code> 几乎可以运行在任何的 <code>JVM</code> 上)；</li><li>可以用 <code>JDBC</code>：可以将 <strong>数据持久化</strong> 到数据库。虽然使用 <code>JDBC</code> 会降低 <code>ActiveMQ</code> 的性能，但是数据库一直都是开发人员最熟悉的存储介质；</li><li>支持 <code>JMS</code> 规范：支持 <code>JMS</code> 规范提供的 <strong>统一接口</strong>;</li><li>支持 <strong>自动重连</strong> 和 <strong>错误重试机制</strong>；</li><li>有安全机制：支持基于 <code>shiro</code>，<code>jaas</code> 等多种 <strong>安全配置机制</strong>，可以对 <code>Queue/Topic</code> 进行 <strong>认证和授权</strong>；</li><li>监控完善：拥有完善的 <strong>监控</strong>，包括 <code>Web Console</code>，<code>JMX</code>，<code>Shell</code> 命令行，<code>Jolokia</code> 的 <code>RESTful API</code>；</li><li>界面友善：提供的 <code>Web Console</code> 可以满足大部分情况，还有很多 <strong>第三方的组件</strong> 可以使用，比如 <code>hawtio</code>；</li></ol><p><strong>(d) 缺点</strong></p><ol><li>社区活跃度不及 <code>RabbitMQ</code> 高；</li><li>根据其他用户反馈，会出莫名其妙的问题，会 <strong>丢失消息</strong>；</li><li>目前重心放到 <code>activemq 6.0</code> 产品 <code>Apollo</code>，对 <code>5.x</code> 的维护较少；</li><li>不适合用于 <strong>上千个队列</strong> 的应用场景；</li></ol><h4 id=2-rabbitmq>.2. RabbitMQ</h4><blockquote><p><code>RabbitMQ</code> 于 <code>2007</code> 年发布，是一个在 <code>AMQP</code> (<strong>高级消息队列协议</strong>)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p></blockquote><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ece3b5d7a data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ece3b5d7a, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ece3b5d7a 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ece3b5d7a 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ece3b5d7a title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ece3b5d7a></p><p><strong>(a) 主要特性</strong></p><ol><li><strong>可靠性</strong>：提供了多种技术可以让你在 <strong>性能</strong> 和 <strong>可靠性</strong> 之间进行 <strong>权衡</strong>。这些技术包括 <strong>持久性机制</strong>、<strong>投递确认</strong>、<strong>发布者证实</strong> 和 <strong>高可用性机制</strong>；</li><li><strong>灵活的路由</strong>：消息在到达队列前是通过 <strong>交换机</strong> 进行 <strong>路由</strong> 的。<code>RabbitMQ</code> 为典型的路由逻辑提供了 <strong>多种内置交换机</strong> 类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做 <code>RabbitMQ</code> 的 <strong>插件</strong> 来使用；</li><li><strong>消息集群</strong>：在相同局域网中的多个 <code>RabbitMQ</code> 服务器可以 <strong>聚合</strong> 在一起，作为一个独立的逻辑代理来使用；</li><li><strong>队列高可用</strong>：队列可以在集群中的机器上 <strong>进行镜像</strong>，以确保在硬件问题下还保证 <strong>消息安全</strong>；</li><li><strong>支持多种协议</strong>：支持 <strong>多种消息队列协议</strong>；</li><li><strong>支持多种语言</strong>：用 <code>Erlang</code> 语言编写，支持只要是你能想到的 <strong>所有编程语言</strong>；</li><li><strong>管理界面</strong>： <code>RabbitMQ</code> 有一个易用的 <strong>用户界面</strong>，使得用户可以 <strong>监控</strong> 和 <strong>管理</strong> 消息 <code>Broker</code> 的许多方面；</li><li><strong>跟踪机制</strong>：如果 <strong>消息异常</strong>，<code>RabbitMQ</code> 提供消息跟踪机制，使用者可以找出发生了什么；</li><li><strong>插件机制</strong>：提供了许多 <strong>插件</strong>，来从多方面进行扩展，也可以编写自己的插件。</li></ol><p><strong>(b) 部署环境</strong></p><p><code>RabbitMQ</code> 可以运行在 <code>Erlang</code> 语言所支持的平台之上，包括 <code>Solaris</code>，<code>BSD</code>，<code>Linux</code>，<code>MacOSX</code>，<code>TRU64</code>，<code>Windows</code> 等。使用 <code>RabbitMQ</code> 需要：</p><ul><li><p><code>ErLang</code> 语言包</p></li><li><p><code>RabbitMQ</code> 安装包</p><p><strong>RabbitMQ</strong></p></li></ul><ol><li>由于 <code>Erlang</code> 语言的特性，消息队列性能较好，支持 <strong>高并发</strong>；</li><li>健壮、稳定、易用、<strong>跨平台</strong>、支持 <strong>多种语言</strong>、文档齐全；</li><li>有消息 <strong>确认机制</strong> 和 <strong>持久化机制</strong>，可靠性高；</li><li>高度可定制的 <strong>路由</strong>；</li><li><strong>管理界面</strong> 较丰富，在互联网公司也有较大规模的应用，社区活跃度高。</li></ol><p><strong>(d) 缺点</strong></p><ol><li>尽管结合 <code>Erlang</code> 语言本身的并发优势，性能较好，但是<code>不利于做 二次开发和维护</code>；</li><li>实现了 <strong>代理架构</strong>，意味着消息在发送到客户端之前可以在 <strong>中央节点</strong> 上排队。此特性使得 <code>RabbitMQ</code> 易于使用和部署，但是使得其 <strong>运行速度较慢</strong>，因为中央节点 <strong>增加了延迟</strong>，<strong>消息封装后</strong> 也比较大；</li><li>需要学习 <strong>比较复杂</strong> 的 <strong>接口和协议</strong>，<code>学习和维护成本较高</code>。</li></ol><h4 id=3-rocketmq>.3. RocketMQ</h4><blockquote><p><code>RocketMQ</code> 出自 <strong>阿里</strong> 的开源产品，用 <code>Java</code> 语言实现，在设计时参考了 <code>Kafka</code>，并做出了自己的一些改进，<strong>消息可靠性上</strong> 比 <code>Kafka</code> 更好。<code>RocketMQ</code> 在阿里内部被广泛应用在 <strong>订单</strong>，<strong>交易</strong>，<strong>充值</strong>，<strong>流计算</strong>，<strong>消息推送</strong>，<strong>日志流式处理</strong>，<code>binglog</code> <strong>分发</strong> 等场景。</p></blockquote><p><strong>(a) 主要特性</strong></p><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec333c809 data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec333c809, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec333c809 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec333c809 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec333c809 title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec333c809></p><ol><li>基于 <strong>队列模型</strong>：具有 <strong>高性能</strong>、<strong>高可靠</strong>、<strong>高实时</strong>、<strong>分布式</strong> 等特点；</li><li><code>Producer</code>、<code>Consumer</code>、<strong>队列</strong> 都支持 <strong>分布式</strong>；</li><li><code>Producer</code> 向一些队列轮流发送消息，<strong>队列集合</strong> 称为 <code>Topic</code>。<code>Consumer</code> 如果做 <strong>广播消费</strong>，则一个 <code>Consumer</code> 实例消费这个 <code>Topic</code> 对应的 <strong>所有队列</strong>；如果做 <strong>集群消费</strong>，则 <strong>多个</strong> <code>Consumer</code> 实例 <strong>平均消费</strong> 这个 <code>Topic</code> 对应的队列集合；</li><li>能够保证 <strong>严格的消息顺序</strong>；</li><li>提供丰富的 <strong>消息拉取模式</strong>；</li><li>高效的订阅者 <strong>水平扩展</strong>能力；</li><li><strong>实时</strong> 的 <strong>消息订阅机制</strong>；</li><li>亿级 <strong>消息堆积</strong> 能力；</li><li>较少的外部依赖。</li></ol><p><strong>(b) 部署环境</strong></p><p><code>RocketMQ</code> 可以运行在 <code>Java</code> 语言所支持的平台之上。使用 <code>RocketMQ</code> 需要：</p><ul><li><code>Java JDK</code></li><li>安装 <code>git</code>、<code>Maven</code></li><li><code>RocketMQ</code> 安装包</li></ul><p><strong>(c) 优点</strong></p><ol><li><strong>单机</strong> 支持 <code>1</code> 万以上 <strong>持久化队列</strong>；</li><li><code>RocketMQ</code> 的所有消息都是 <strong>持久化的</strong>，先写入系统 <code>PAGECACHE</code>，然后 <strong>刷盘</strong>，可以保证 <strong>内存</strong> 与 <strong>磁盘</strong> 都有一份数据，而 <strong>访问</strong> 时，直接 <strong>从内存读取</strong>。</li><li>模型简单，接口易用（<code>JMS</code> 的接口很多场合并不太实用）；</li><li><strong>性能非常好</strong>，可以允许 <strong>大量堆积消息</strong> 在 <code>Broker</code> 中；</li><li>支持 <strong>多种消费模式</strong>，包括 <strong>集群消费</strong>、<strong>广播消费</strong>等；</li><li>各个环节 <strong>分布式扩展设计</strong>，支持 <strong>主从</strong> 和 <strong>高可用</strong>；</li><li>开发度较活跃，版本更新很快。</li></ol><p><strong>(d) 缺点</strong></p><ol><li>支持的 <strong>客户端语言</strong> 不多，目前是 <code>Java</code> 及 <code>C++</code>，其中 <code>C++</code> 还不成熟；</li><li><code>RocketMQ</code> 社区关注度及成熟度也不及前两者；</li><li>没有 <code>Web</code> 管理界面，提供了一个 <code>CLI</code> (命令行界面) 管理工具带来 <strong>查询</strong>、<strong>管理</strong> 和 <strong>诊断各种问题</strong>；</li><li>没有在 <code>MQ</code> 核心里实现 <code>JMS</code> 等接口；</li></ol><h4 id=4-kafka>.4. Kafka</h4><blockquote><p><code>Apache Kafka</code> 是一个 <strong>分布式消息发布订阅</strong> 系统。它最初由 <code>LinkedIn</code> 公司基于独特的设计实现为一个 <strong>分布式的日志提交系统</strong> (<code>a distributed commit log</code>)，之后成为 <code>Apache</code> 项目的一部分。<code>Kafka</code> <strong>性能高效</strong>、<strong>可扩展良好</strong> 并且 <strong>可持久化</strong>。它的 <strong>分区特性</strong>，<strong>可复制</strong> 和 <strong>可容错</strong> 都是其不错的特性。</p></blockquote><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec4ba760a data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec4ba760a, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec4ba760a 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec4ba760a 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec4ba760a title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ec4ba760a></p><p><strong>(a) 主要特性</strong></p><ol><li><strong>快速持久化</strong>：可以在 <code>O(1)</code> 的系统开销下进行 <strong>消息持久化</strong>；</li><li><strong>高吞吐</strong>：在一台普通的服务器上既可以达到 <code>10W/s</code> 的 <strong>吞吐速率</strong>；</li><li><strong>完全的分布式系统</strong>：<code>Broker</code>、<code>Producer</code> 和 <code>Consumer</code> 都原生自动支持 <strong>分布式</strong>，自动实现 <strong>负载均衡</strong>；</li><li>支持 <strong>同步</strong> 和 <strong>异步</strong> 复制两种 <strong>高可用机制</strong>；</li><li>支持 <strong>数据批量发送</strong> 和 <strong>拉取</strong>；</li><li><strong>零拷贝技术(zero-copy)</strong>：减少 <code>IO</code> 操作步骤，提高 <strong>系统吞吐量</strong>；</li><li><strong>数据迁移</strong>、<strong>扩容</strong> 对用户透明；</li><li><strong>无需停机</strong> 即可扩展机器；</li><li><strong>其他特性</strong>：丰富的 <strong>消息拉取模型</strong>、高效 <strong>订阅者水平扩展</strong>、实时的 <strong>消息订阅</strong>、亿级的 <strong>消息堆积能力</strong>、定期删除机制；</li></ol><p><strong>(b) 部署环境</strong></p><p>使用 <code>Kafka</code> 需要：</p><ul><li><code>Java JDK</code></li><li><code>Kafka</code> 安装包</li></ul><p><strong>(c) 优点</strong></p><ol><li><strong>客户端语言丰富</strong>：支持 <code>Java</code>、<code>.Net</code>、<code>PHP</code>、<code>Ruby</code>、<code>Python</code>、<code>Go</code> 等多种语言；</li><li><strong>高性能</strong>：单机写入 <code>TPS</code> 约在 <code>100</code> 万条/秒，消息大小 <code>10</code> 个字节；</li><li>提供 <strong>完全分布式架构</strong>，并有 <code>replica</code> 机制，拥有较高的 <strong>可用性</strong> 和 <strong>可靠性</strong>，理论上支持 <strong>消息无限堆积</strong>；</li><li>支持批量操作；</li><li><strong>消费者</strong> 采用 <code>Pull</code> 方式获取消息。<strong>消息有序</strong>，<strong>通过控制</strong> 能够保证所有消息被消费且仅被消费 <strong>一次</strong>；</li><li>有优秀的第三方 <code>Kafka Web</code> 管理界面 <code>Kafka-Manager</code>；</li><li>在 <strong>日志领域</strong> 比较成熟，被多家公司和多个开源项目使用。</li></ol><p><strong>(d) 缺点</strong></p><ol><li><code>Kafka</code> 单机超过 <code>64</code> 个 <strong>队列/分区</strong> 时，<code>Load</code> 时会发生明显的飙高现象。<strong>队列</strong> 越多，<strong>负载</strong> 越高，发送消息 <strong>响应时间变长</strong>；</li><li>使用 <strong>短轮询方式</strong>，<strong>实时性</strong> 取决于 <strong>轮询间隔时间</strong>；</li><li>消费失败 <strong>不支持重试</strong>；</li><li>支持 <strong>消息顺序</strong>，但是 <strong>一台代理宕机</strong> 后，就会产生 <strong>消息乱序</strong>；</li><li>社区更新较慢。</li></ol><h4 id=5-几种消息队列对比>.5. 几种消息队列对比</h4><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ecf7ad3ef data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ecf7ad3ef, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ecf7ad3ef 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ecf7ad3ef 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ecf7ad3ef title=https://gitee.com/github-25970295/blogpictureV2/raw/master/16479c8ecf7ad3ef></p><p><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210714105746218.png data-srcset="https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210714105746218.png, https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210714105746218.png 1.5x, https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210714105746218.png 2x" data-sizes=auto alt=https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210714105746218.png title=https://gitee.com/github-25970295/blogpictureV2/raw/master/image-20210714105746218.png></p><p><code>Kafka</code> 在于 <strong>分布式架构</strong>，<code>RabbitMQ</code> 基于 <code>AMQP</code> <strong>协议</strong> 来实现，<code>RocketMQ</code> 的思路来源于 <code>Kafka</code>，改成了 <strong>主从结构</strong>，在 <strong>事务性</strong> 和 <strong>可靠性</strong> 方面做了优化。广泛来说，<strong>电商</strong>、<strong>金融</strong> 等对 <strong>事务一致性</strong> 要求很高的，可以考虑 <code>RabbitMQ</code> 和 <code>RocketMQ</code>，对 <strong>性能要求高</strong> 的可考虑 <code>Kafka</code>。</p><h3 id=resource>Resource</h3><ul><li><a href=https://juejin.cn/post/6844903635046924296 target=_blank rel="external nofollow noopener noreferrer">https://juejin.cn/post/6844903635046924296<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2023-09-28 22:47:26">更新于 2023-09-28&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=liudongdong1.github.io/middlewareoverview/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://liudongdong1.github.io/edit/master/content/posts%5c%e6%a1%86%e6%9e%b6%e8%ae%be%e8%ae%a1%5cmiddleware%5cmiddlewareOverview.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=liudongdong1.github.io/middlewareoverview/ data-title=middlewareOverview data-hashtags=Framework,Middleware><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=liudongdong1.github.io/middlewareoverview/ data-hashtag=Framework><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=liudongdong1.github.io/middlewareoverview/ data-title=middlewareOverview data-image=https://cdn.stocksnap.io/img-thumbs/280h/plant-leaves_RP9VPMSKFG.jpg><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=liudongdong1.github.io/tags/framework/>Framework</a>,&nbsp;<a href=liudongdong1.github.io/tags/middleware/>Middleware</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=liudongdong1.github.io/>主页</a></span></section></div><div class=post-nav><a href=liudongdong1.github.io/qbittorrent/ class=prev rel=prev title=qBittorrent><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>qBittorrent</a>
<a href=liudongdong1.github.io/distributionalgorithm/ class=next rel=next title=DistributionAlgorithm>DistributionAlgorithm<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.118.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.17-RC"><img class=fixit-icon src=/liudongdong1.github.io/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=https://liudongdong1.github.io/ target=_blank rel="external nofollow noopener noreferrer">LiuDongdong</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title='网站运行中 ...'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i>&nbsp;<span class=run-times>网站运行中 ...</span></span></div><div class="footer-line ibruce"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://liudongdong1.github.io/ title="在 GitHub 上查看源代码" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#0076ff;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/liudongdong1.github.io/lib/katex/katex.min.css><link rel=stylesheet href=/liudongdong1.github.io/lib/cookieconsent/cookieconsent.min.css><script src=/liudongdong1.github.io/lib/autocomplete/autocomplete.min.js defer></script><script src=/liudongdong1.github.io/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/liudongdong1.github.io/lib/lazysizes/lazysizes.min.js async defer></script><script src=/liudongdong1.github.io/lib/sharer/sharer.min.js async defer></script><script src=/liudongdong1.github.io/lib/typeit/index.umd.js defer></script><script src=/liudongdong1.github.io/lib/katex/katex.min.js defer></script><script src=/liudongdong1.github.io/lib/katex/auto-render.min.js defer></script><script src=/liudongdong1.github.io/lib/katex/copy-tex.min.js defer></script><script src=/liudongdong1.github.io/lib/katex/mhchem.min.js defer></script><script src=/liudongdong1.github.io/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/liudongdong1.github.io/lib/pangu/pangu.min.js defer></script><script src=/liudongdong1.github.io/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},data:{"typeit-header-subtitle-desktop":`<span style='font-family: MMT,"沐目体";'>吾日三省吾身</span>`,"typeit-header-subtitle-mobile":`<span style='font-family: MMT,"沐目体";'>吾日三省吾身</span>`},enablePWA:!0,enablePangu:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"2R1K9SKLQZ",algoliaIndex:"index.zh-cn",algoliaSearchKey:"4a226aa1c5c98d6859e4d1386adb2bc7",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-12-18T16:15:22+08:00",typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"typeit-header-subtitle-desktop":["typeit-header-subtitle-desktop"],"typeit-header-subtitle-mobile":["typeit-header-subtitle-mobile"]},duration:-1,speed:100},watermark:{appendto:".wrapper>main",colspacing:30,content:'<img class="fixit-icon" src="/fixit.min.svg" alt="FixIt logo" /> FixIt 主题',enable:!0,fontfamily:"inherit",fontsize:.85,height:21,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/liudongdong1.github.io/js/theme.min.js defer></script><script src=/liudongdong1.github.io/js/custom.min.js defer></script></body></html>