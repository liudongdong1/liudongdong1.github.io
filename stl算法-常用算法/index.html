<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>STL算法-常用算法 - DAY By DAY</title><meta name=author content="LiuDongdong"><meta name=author-link content="https://liudongdong1.github.io/"><meta name=description content="STL 算法部分主要由头文件 ,, 组成。要使用 STL 中的算法函数必须包含头文件 ，对于数值算法须包含 ， 中则定义了一些模板类，用来声明函数对象。 非可变序列算法"><meta name=keywords content="C++"><meta itemprop=name content="STL算法-常用算法"><meta itemprop=description content="STL 算法部分主要由头文件 ,, 组成。要使用 STL 中的算法函数必须包含头文件 ，对于数值算法须包含 ， 中则定义了一些模板类，用来声明函数对象。 非可变序列算法"><meta itemprop=dateModified content="2023-09-24T17:00:04+08:00"><meta itemprop=wordCount content="8362"><meta itemprop=image content="/logo.png"><meta itemprop=keywords content="C++,"><meta property="og:title" content="STL算法-常用算法"><meta property="og:description" content="STL 算法部分主要由头文件 ,, 组成。要使用 STL 中的算法函数必须包含头文件 ，对于数值算法须包含 ， 中则定义了一些模板类，用来声明函数对象。 非可变序列算法"><meta property="og:type" content="article"><meta property="og:url" content="liudongdong1.github.io/stl%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"><meta property="og:image" content="/logo.png"><meta property="article:section" content="posts"><meta property="article:modified_time" content="2023-09-24T17:00:04+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo.png"><meta name=twitter:title content="STL算法-常用算法"><meta name=twitter:description content="STL 算法部分主要由头文件 ,, 组成。要使用 STL 中的算法函数必须包含头文件 ，对于数值算法须包含 ， 中则定义了一些模板类，用来声明函数对象。 非可变序列算法"><meta name=application-name content="DAY By DAY"><meta name=apple-mobile-web-app-title content="DAY By DAY"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=liudongdong1.github.io/stl%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/><link rel=prev href=liudongdong1.github.io/stl%E7%AE%97%E6%B3%95-%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/><link rel=next href=liudongdong1.github.io/stl%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/><link rel=stylesheet href=/liudongdong1.github.io/css/style.min.css><link rel=stylesheet href=/liudongdong1.github.io/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/liudongdong1.github.io/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"STL算法-常用算法","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"liudongdong1.github.io\/stl%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95\/"},"genre":"posts","keywords":"C\u002b\u002b","wordcount":8362,"url":"liudongdong1.github.io\/stl%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95\/","dateModified":"2023-09-24T17:00:04+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"LiuDongdong","logo":"\/images\/person.png"},"author":{"@type":"Person","name":"liudongdong1"},"description":""}</script></head><body data-header-desktop=auto data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=liudongdong1.github.io/ title="DAY By DAY"><img class="lazyload logo" src=/liudongdong1.github.io/svg/loading.min.svg data-src=/fixit.min.svg data-srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x" data-sizes=auto alt="DAY By DAY" title="DAY By DAY"><span class=header-title-text></span></a><span id=typeit-header-subtitle-desktop class="typeit header-subtitle"></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item language"><span role=button aria-label=选择语言 title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item>没有更多翻译</li></ul></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=liudongdong1.github.io/ title="DAY By DAY"><img class="lazyload logo" src=/liudongdong1.github.io/svg/loading.min.svg data-src=/fixit.min.svg data-srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x" data-sizes=auto alt=/fixit.min.svg title=/fixit.min.svg><span class=header-title-text></span></a><span id=typeit-header-subtitle-mobile class="typeit header-subtitle"></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/liudongdong1.github.io/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://liudongdong1.github.io/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li><li class="menu-item language"><span role=button aria-label=选择语言 title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span>
<select class=language-select onchange="location=this.value"><option disabled>没有更多翻译</option></select></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container data-page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom id=aside-sakana><div class=sakana-widget><div class=sakana-item id=takina-widget></div><div class=sakana-item id=chisato-widget></div></div><script>function initSakanaWidget(){const e=SakanaWidget.getCharacter("takina");SakanaWidget.registerCharacter("takina-slow",e),new SakanaWidget({character:"takina-slow",controls:!1,autoFit:!0,stroke:{color:"#b4b4b4",width:2}}).mount("#takina-widget");const t=SakanaWidget.getCharacter("chisato");SakanaWidget.registerCharacter("chisato-slow",t),new SakanaWidget({character:"chisato-slow",controls:!1,autoFit:!0,stroke:{color:"#b4b4b4",width:2}}).mount("#chisato-widget")}</script><script async onload=initSakanaWidget() src=https://cdn.jsdelivr.net/npm/sakana-widget@2.3.0/lib/sakana.min.js></script></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>STL算法-常用算法</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
liudongdong1</span></span>
<span class=post-category>收录于 <a href=liudongdong1.github.io/categories/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Categories</a>&ensp;<a href=liudongdong1.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;编程语言</a></span></div><div class=post-meta-line><span title="0001-01-01 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=0001-01-01>0001-01-01</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 8362 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 17 分钟&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=STL算法-常用算法>
<i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class=featured-image><img class=lazyload src=/liudongdong1.github.io/svg/loading.min.svg data-src=https://cdn.pixabay.com/photo/2021/11/11/17/14/year-6786741__340.jpg data-srcset="https://cdn.pixabay.com/photo/2021/11/11/17/14/year-6786741__340.jpg, https://cdn.pixabay.com/photo/2021/11/11/17/14/year-6786741__340.jpg 1.5x, https://cdn.pixabay.com/photo/2021/11/11/17/14/year-6786741__340.jpg 2x" data-sizes=auto alt=https://cdn.pixabay.com/photo/2021/11/11/17/14/year-6786741__340.jpg title=https://cdn.pixabay.com/photo/2021/11/11/17/14/year-6786741__340.jpg></div><div class="details toc" id=toc-static kept=true><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#1-查找算法>1 查找算法</a></li><li><a href=#2-排序和通用算法>2 排序和通用算法</a></li><li><a href=#3-删除和替换算法>3 删除和替换算法</a></li><li><a href=#4-排列组合算法>4 排列组合算法</a></li><li><a href=#5-数值算法>5 数值算法</a></li><li><a href=#6-生成和异变算法>6 生成和异变算法</a></li><li><a href=#7-关系算法>7 关系算法</a></li><li><a href=#8-集合算法>8 <strong>集合算法</strong></a></li><li><a href=#9-堆算法>9 堆算法</a></li><li><a href=#resouce>Resouce</a></li></ul></li></ul></nav></div></div><div class=content id=content><blockquote><p>STL 算法部分主要由头文件 ,, 组成。要使用 STL 中的算法函数必须包含头文件 ，对于数值算法须包含 ， 中则定义了一些模板类，用来声明函数对象。</p><ul><li>非可变序列算法：指不直接修改其所操作的容器内容的算法。</li><li>可变序列算法：指可以修改它们所操作的容器内容的算法。</li><li>排序算法：包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</li><li>数值算法：对容器内容进行数值计算。</li></ul></blockquote><h3 id=1-查找算法>1 查找算法</h3><p>查找算法共 13 个，包含在 头文件中，用来提供元素排序策略，这里只列出一部分算法：</p><ul><li>adjacent_find: 在 iterator 对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的 ForwardIterator。否则返回 last。重载版本使用输入的二元操作符代替相等的判断。</li><li>count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。</li><li>count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为 true 的个数。</li><li>binary_search: 在有序序列中查找 value，找到返回 true。重载的版本实用指定的比较函数对象或函数指针来判断相等。</li><li>equal_range: 功能类似 equal，返回一对 iterator，第一个表示 lower_bound，第二个表示 upper_bound。</li><li>find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回指向该元素的 Iterator。</li><li>find_if: 使用输入的函数代替等于操作符执行 find。</li><li>search: 给出两个范围，返回一个 ForwardIterator，查找成功指向第一个范围内第一次出现子序列 (第二个范围) 的位置，查找失败指向 last1。重载版本使用自定义的比较操作。</li><li>search_n: 在指定范围内查找 val 出现 n 次的子序列。重载版本使用自定义的比较操作。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt;  </span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv(iarr, iarr <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原型： _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;adjacent_find: &#34;</span>;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>adjacent_find(iv.begin(), iv.end()) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原型： count(_InIt _First, _InIt _Last, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;count(==7): &#34;</span>;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> count(iv.begin(), iv.end(), <span style=color:#ae81ff>6</span>) <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>// 统计6的个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原型： count_if(_InIt _First, _InIt _Last, _Pr _Pred)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 统计小于7的元素的个数 :9个
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;count_if(&lt;7): &#34;</span>;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> count_if(iv.begin(), iv.end(), bind2nd(less<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>7</span>)) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** binary_search: 在有序序列中查找value，找到返回true。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原型： bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;binary_search: &#34;</span>;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> binary_search(iv.begin(), iv.end(), <span style=color:#ae81ff>4</span>) <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// 找到返回true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原型： equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator<span style=color:#f92672>&gt;</span> pairIte;  
</span></span><span style=display:flex><span>	pairIte <span style=color:#f92672>=</span> equal_range(iv.begin(), iv.end(), <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;pairIte.first:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>(pairIte.first) <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>// lowerbound 3   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;pairIte.second:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>(pairIte.second) <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// upperbound 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原型： _InIt find(_InIt _First, _InIt _Last, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;find: &#34;</span>;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>find(iv.begin(), iv.end(), <span style=color:#ae81ff>4</span>) <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// 返回元素为4的元素的下标位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** find_if: 使用输入的函数代替等于操作符执行find。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原型： _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;find_if: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>find_if(iv.begin(), iv.end(), bind2nd(greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>2</span>)) <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// 返回大于2的第一个元素的位置：3 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列的位置。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原型： _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 在iv中查找 子序列 2 3 第一次出现的位置的元素   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>int</span> iarr3[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv3(iarr3, iarr3 <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;search: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>search(iv.begin(), iv.end(), iv3.begin(), iv3.end()) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** search_n: 在指定范围内查找val出现n次的子序列。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原型： _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 在iv中查找 2个6 出现的第一个位置的元素   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;search_n: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>search_n(iv.begin(), iv.end(), <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>6</span>) <span style=color:#f92672>&lt;&lt;</span> endl;  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>adjacent_find: 6
</span></span></span><span style=display:flex><span><span style=color:#75715e>count(==7): 3
</span></span></span><span style=display:flex><span><span style=color:#75715e>count_if(&lt;7): 9
</span></span></span><span style=display:flex><span><span style=color:#75715e>binary_search: 1
</span></span></span><span style=display:flex><span><span style=color:#75715e>pairIte.first:3
</span></span></span><span style=display:flex><span><span style=color:#75715e>pairIte.second:4
</span></span></span><span style=display:flex><span><span style=color:#75715e>find: 4
</span></span></span><span style=display:flex><span><span style=color:#75715e>find_if: 3
</span></span></span><span style=display:flex><span><span style=color:#75715e>search: 2
</span></span></span><span style=display:flex><span><span style=color:#75715e>search_n: 6
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=2-排序和通用算法>2 排序和通用算法</h3><p>排序算法共 14 个，包含在 头文件中，用来判断容器中是否包含某个值，这里只列出一部分算法：</p><ul><li>merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。</li><li>random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。</li><li>nth_element: 将范围内的序列重新排序，使所有小于第 n 个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。</li><li>reverse: 将指定范围内元素重新反序排序。</li><li>sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。</li><li>stable_sort: 与 sort 类似，不过保留相等元素之间的顺序关系。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdafx.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt; // 定义了greater&lt;int&gt;()</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 要注意的技巧
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>display</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span>x) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 自定义从大到小的比较器，用来改变排序方式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>Comp</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> b) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> a <span style=color:#f92672>&gt;</span> b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr1[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv1(iarr1, iarr1 <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr1) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv2(iarr1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>, iarr1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>); <span style=color:#75715e>// 4 5 6 6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv3(<span style=color:#ae81ff>15</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** merge: 合并两个有序序列，存放到另一个序列 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// iv1和iv2合并到iv3中（合并后会自动排序）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	merge(iv1.begin(), iv1.end(), iv2.begin(), iv2.end(), iv3.begin());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;merge合并后: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv3.begin(), iv3.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** random_shuffle: 对指定范围内的元素随机调整次序。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr2[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv4(iarr2, iarr2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr2) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 打乱顺序  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	random_shuffle(iv4.begin(), iv4.end());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;random_shuffle打乱后: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv4.begin(), iv4.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** nth_element: 将范围内的序列重新排序。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将小于iv.begin+5的放到左边   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	nth_element(iv4.begin(), iv4.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>, iv4.end());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;nth_element重新排序后: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv4.begin(), iv4.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** reverse: 将指定范围内元素重新反序排序。 ***/</span>
</span></span><span style=display:flex><span>	reverse(iv4.begin(), iv4.begin());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;reverse翻转后: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv4.begin(), iv4.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** sort: 以升序重新排列指定范围内的元素。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// sort(iv4.begin(), iv4.end(), Comp); // 也可以使用自定义Comp()函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	sort(iv4.begin(), iv4.end(), greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;sort排序（倒序）: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv4.begin(), iv4.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr3[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv5(iarr3, iarr3 <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr3) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>	stable_sort(iv5.begin(), iv5.end(), greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;stable_sort排序（倒序）: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv5.begin(), iv5.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>merge合并后: 0 1 2 3 4 4 5 5 6 6 6 6 6 7 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>random_shuffle打乱后: 8 1 6 2 0 5 7 3 4
</span></span></span><span style=display:flex><span><span style=color:#75715e>nth_element重新排序后: 0 1 2 3 4 5 6 7 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>reverse翻转后: 0 1 2 3 4 5 6 7 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>sort排序（倒序）: 8 7 6 5 4 3 2 1 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>stable_sort排序（倒序）: 6 5 4 4 3 3 2 1 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=3-删除和替换算法>3 删除和替换算法</h3><p>删除和替换算法共 15 个，包含在 头文件中，这里只列出一部分算法：</p><ul><li>copy: 复制序列。</li><li>copy_backward: 与 copy 相同，不过元素是以相反顺序被拷贝。</li><li>remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用 remove 和 remove_if 函数。</li><li>remove_copy: 将所有不匹配元素复制到一个制定容器，返回 OutputIterator 指向被拷贝的末元素的下一个位置。</li><li>remove_if: 删除指定范围内输入操作结果为 true 的所有元素。</li><li>remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdafx.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt; // 定义了greater&lt;int&gt;()</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>display</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span>x) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr1[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv1(iarr1, iarr1 <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr1) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv2(<span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** copy: 复制序列 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt copy(_InIt _First, _InIt _Last,_OutIt _Dest)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	copy(iv1.begin(), iv1.end(), iv2.begin());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;copy(iv2): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv2.begin(), iv2.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,_BidIt2 _Dest)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	copy_backward(iv1.begin(), iv1.end(), iv2.rend());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;copy_backward(iv2): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv2.begin(), iv2.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** remove: 删除指定范围内所有等于指定元素的元素。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	remove(iv1.begin(), iv1.end(), <span style=color:#ae81ff>5</span>); <span style=color:#75715e>// 删除元素5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;remove(iv1): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv1.begin(), iv1.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： 	_OutIt remove_copy(_InIt _First, _InIt _Last,_OutIt _Dest, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv3(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>	remove_copy(iv1.begin(), iv1.end(), iv3.begin(), <span style=color:#ae81ff>4</span>); <span style=color:#75715e>// 去除4 然后将一个容器的元素复制到另一个容器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;remove_copy(iv3): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv3.begin(), iv3.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** remove_if: 删除指定范围内输入操作结果为true的所有元素。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	remove_if(iv3.begin(), iv3.end(), bind2nd(less<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>6</span>)); <span style=color:#75715e>//  将小于6的元素 &#34;删除&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;remove_if(iv3): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv3.begin(), iv3.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 原型： _OutIt remove_copy_if(_InIt _First, _InIt _Last,_OutIt _Dest, _Pr _Pred)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//  将iv1中小于6的元素 &#34;删除&#34;后，剩下的元素再复制给iv3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	remove_copy_if(iv1.begin(), iv1.end(), iv2.begin(), bind2nd(less<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>4</span>));
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;remove_if(iv2): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv2.begin(), iv2.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>copy(iv2): 0 1 2 3 4 5 6 7 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>copy_backward(iv2): 8 7 6 5 4 3 2 1 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>remove(iv1): 0 1 2 3 4 6 7 8 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>remove_copy(iv3): 0 1 2 3 6 7 8 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>remove_if(iv3): 6 7 8 8 6 7 8 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>remove_if(iv2): 4 6 7 8 8 3 2 1 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><ul><li>replace: 将指定范围内所有等于 vold 的元素都用 vnew 代替。</li><li>replace_copy: 与 replace 类似，不过将结果写入另一个容器。</li><li>replace_if: 将指定范围内所有操作结果为 true 的元素用新值代替。</li><li>replace_copy_if: 与 replace_if，不过将结果写入另一个容器。</li><li>swap: 交换存储在两个对象中的值。</li><li>swap_range: 将指定范围内的元素与另一个序列元素值进行交换。</li><li>unique: 清除序列中重复元素，和 remove 类似，它也不能真正删除元素。重载版本使用自定义比较操作。</li><li>unique_copy: 与 unique 类似，不过把结果输出到另一个容器。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdafx.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt; // 定义了greater&lt;int&gt;()</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>display</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span>x) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv(iarr, iarr <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** replace: 将指定范围内所有等于vold的元素都用vnew代替。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： void replace(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Oldval, const _Ty&amp; _Newval)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 将容器中6 替换为 3   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	replace(iv.begin(), iv.end(), <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;replace(iv): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>()); <span style=color:#75715e>// 由于_X是static 所以接着 增长
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// iv:8 10 7 8 3 3 7 8 3 7 8   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** replace_copy: 与replace类似，不过将结果写入另一个容器。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&amp; _Oldval, const _Ty&amp; _Newval)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv2(<span style=color:#ae81ff>12</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 将容器中3 替换为 5，并将结果写入另一个容器。  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	replace_copy(iv.begin(), iv.end(), iv2.begin(), <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;replace_copy(iv2): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv2.begin(), iv2.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());  
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// iv2:8 10 7 8 5 5 7 8 5 7 8 0（最后y一个残留元素）   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** replace_if: 将指定范围内所有操作结果为true的元素用新值代替。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 将容器中小于 5 替换为 2   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	replace_if(iv.begin(), iv.end(), bind2nd(less<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>5</span>), <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;replace_copy(iv): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());   
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// iv:8 10 7 8 2 5 7 8 2 7 8   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** replace_copy_if: 与replace_if，不过将结果写入另一个容器。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 将容器中小于 5 替换为 2，并将结果写入另一个容器。  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	replace_copy_if(iv.begin(), iv.end(), iv2.begin(), bind2nd(equal_to<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>8</span>), <span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;replace_copy_if(iv2): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv2.begin(), iv2.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>()); 
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// iv2:9 10 7 8 2 5 7 9 2 7 8 0(最后一个残留元素)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr3[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv3(iarr3, iarr3 <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr3) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr4[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv4(iarr4, iarr4 <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr4) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** swap: 交换存储在两个对象中的值。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 将两个容器中的第一个元素交换  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	swap(<span style=color:#f92672>*</span>iv3.begin(), <span style=color:#f92672>*</span>iv4.begin());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;swap(iv3): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv3.begin(), iv3.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());  
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** swap_range: 将指定范围内的元素与另一个序列元素值进行交换。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _Dest)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 将两个容器中的全部元素进行交换  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	swap_ranges(iv4.begin(), iv4.end(), iv3.begin());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;swap_range(iv3): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv3.begin(), iv3.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** unique: 清除序列中相邻的重复元素，和remove类似，它也不能真正删除元素。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred) 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	unique(iv3.begin(), iv3.end());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;unique(iv3): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv3.begin(), iv3.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** unique_copy: 与unique类似，不过把结果输出到另一个容器。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	unique_copy(iv3.begin(), iv3.end(), iv4.begin());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;unique_copy(iv4): &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv4.begin(), iv4.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>replace(iv): 8 10 7 8 3 3 7 8 3 7 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>replace_copy(iv2): 8 10 7 8 5 5 7 8 5 7 8 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>replace_copy(iv): 8 10 7 8 2 2 7 8 2 7 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>replace_copy_if(iv2): 9 10 7 9 2 2 7 9 2 7 9 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>swap(iv3): 8 1 2 3 4 5 6 7 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>swap_range(iv3): 0 10 7 8 6 6 7 8 6
</span></span></span><span style=display:flex><span><span style=color:#75715e>unique(iv3): 0 10 7 8 6 7 8 6 6
</span></span></span><span style=display:flex><span><span style=color:#75715e>unique_copy(iv4): 0 10 7 8 6 7 8 6 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=4-排列组合算法>4 排列组合算法</h3><p>排列组合算法共 2 个，包含在 头文件中，用来提供计算给定集合按一定顺序的所有可能排列组合，这里全部列出：</p><ul><li>next_permutation: 取出当前范围内的排列，并重新排序为下一个字典序排列。重载版本使用自定义的比较操作。</li><li>prev_permutation: 取出指定范围内的序列并将它重新排序为上一个字典序排列。如果不存在上一个序列则返回 false。重载版本使用自定义的比较操作。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdafx.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>display</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span>x) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>17</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>22</span>, <span style=color:#ae81ff>23</span>, <span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>33</span>, <span style=color:#ae81ff>40</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv(iarr, iarr <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** next_permutation: 取出当前范围内的排列，并重新排序为下一个字典序排列。***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： bool next_permutation(_BidIt _First, _BidIt _Last)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 生成下一个排列组合（字典序）   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	next_permutation(iv.begin(), iv.end());
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** prev_permutation: 取出指定范围内的序列并将它重新排序为上一个字典序排列。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： bool prev_permutation(_BidIt _First, _BidIt _Last)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	prev_permutation(iv.begin(), iv.end());
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>12 17 20 22 23 30 40 33
</span></span></span><span style=display:flex><span><span style=color:#75715e>12 17 20 22 23 30 33 40
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=5-数值算法>5 数值算法</h3><p>数值算法共 4 个，包含在 头文件中，分别是：</p><ul><li>accumulate: iterator 对标识的序列段元素之和，加到一个由 val 指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。</li><li>partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。</li><li>inner_product: 对两个序列做内积 (对应元素相乘，再求和) 并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。</li><li>adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdafx.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;numeric&gt; // 数值算法</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iterator&gt; // 定义了ostream_iterator</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec2(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>int</span> temp;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	temp <span style=color:#f92672>=</span> accumulate(vec.begin(), vec.end(), val);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;accumulate(val = 0): &#34;</span> <span style=color:#f92672>&lt;&lt;</span> temp <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	val <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	temp <span style=color:#f92672>=</span> accumulate(vec.begin(), vec.end(), val);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;accumulate(val = 1): &#34;</span> <span style=color:#f92672>&lt;&lt;</span> temp <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 这里是：1*1 + 2*2 + 3*3 + 4*4 + 5*5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	temp <span style=color:#f92672>=</span> inner_product(vec.begin(), vec.end(), vec2.begin(), val);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;inner_product(val = 0): &#34;</span> <span style=color:#f92672>&lt;&lt;</span> temp <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 第一次，1   第二次，1+2  第三次，1+2+3  第四次，1+2+3+4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ostream_iterator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> oit(cout, <span style=color:#e6db74>&#34; &#34;</span>); <span style=color:#75715e>// 迭代器绑定到cout上作为输出使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;ostream_iterator: &#34;</span>;
</span></span><span style=display:flex><span>	partial_sum(vec.begin(), vec.end(), oit);<span style=color:#75715e>// 依次输出前n个数的和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 第一次，1   第二次，1-2  第三次，1-2-3  第四次，1-2-3-4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;ostream_iterator(minus): &#34;</span>;
</span></span><span style=display:flex><span>	partial_sum(vec.begin(), vec.end(), oit, minus<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());<span style=color:#75715e>// 依次输出第一个数减去（除第一个数外到当前数的和）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 第一次，1-0   第二次，2-1  第三次，3-2  第四次，4-3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;adjacent_difference: &#34;</span>;
</span></span><span style=display:flex><span>	adjacent_difference(vec.begin(), vec.end(), oit); <span style=color:#75715e>// 输出相邻元素差值 后面-前面
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 第一次，1+0   第二次，2+1  第三次，3+2  第四次，4+3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;adjacent_difference(plus): &#34;</span>;
</span></span><span style=display:flex><span>	adjacent_difference(vec.begin(), vec.end(), oit, plus<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>()); <span style=color:#75715e>// 输出相邻元素差值 后面-前面 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>accumulate(val = 0): 15
</span></span></span><span style=display:flex><span><span style=color:#75715e>accumulate(val = 1): 16
</span></span></span><span style=display:flex><span><span style=color:#75715e>inner_product(val = 0): 55
</span></span></span><span style=display:flex><span><span style=color:#75715e>ostream_iterator: 1 3 6 10 15
</span></span></span><span style=display:flex><span><span style=color:#75715e>ostream_iterator(minus): 1 -1 -4 -8 -13
</span></span></span><span style=display:flex><span><span style=color:#75715e>adjacent_difference: 1 1 1 1 1
</span></span></span><span style=display:flex><span><span style=color:#75715e>adjacent_difference(plus): 1 3 5 7 9
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=6-生成和异变算法>6 生成和异变算法</h3><p>生成和异变算法共 6 个，包含在 头文件中，这里只列出一部分算法：</p><ul><li>fill: 将输入值赋给标志范围内的所有元素。</li><li>fill_n: 将输入值赋给 first 到 first+n 范围内的所有元素。</li><li>for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。</li><li>generate: 连续调用输入的函数来填充指定的范围。</li><li>generate_n: 与 generate 函数类似，填充从指定 iterator 开始的 n 个元素。</li><li>transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdafx.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>display</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span>x) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>//  作用类似于上面结构体，只不过只能显示int类型的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printElem</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> elem)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> elem <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>plus2</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>()(T<span style=color:#f92672>&amp;</span>x)<span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		x <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>even_by_two</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> _x; <span style=color:#75715e>//  注意静态变量   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> <span style=color:#66d9ef>operator</span>()()<span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _x <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> even_by_two<span style=color:#f92672>::</span>_x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>//  初始化静态变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv(iarr, iarr <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** fill: 将输入值赋给标志范围内的所有元素。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： void fill(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val)  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	fill(iv.begin(), iv.end(),<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;fill: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** fill_n: 将输入值赋给first到first+n范围内的所有元素。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty&amp; _Val)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	fill_n(iv.begin(), <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>); <span style=color:#75715e>//  赋4个3给iv 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;fill_n: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	for_each(iv.begin(), iv.end(), plus2<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>()); <span style=color:#75715e>//  每个元素+2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;for_each: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), printElem); <span style=color:#75715e>//  输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** generate: 连续调用输入的函数来填充指定的范围。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//  使用even_by_two()函数返回的值，来填充容器iv
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	generate(iv.begin(), iv.end(), even_by_two());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;generate: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//  使用even_by_two()函数返回的值，来填充容器iv的前三个值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	generate_n(iv.begin(), <span style=color:#ae81ff>3</span>, even_by_two());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;generate_n: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>()); <span style=color:#75715e>//  由于_X是static 所以接着 增长
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 容器的所有值全部减2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	transform(iv.begin(), iv.end(), iv.begin(), bind2nd(minus<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;transform: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>()); <span style=color:#75715e>//  由于_X是static 所以接着 增长
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>fill: 5 5 5 5 5 5 5 5 5
</span></span></span><span style=display:flex><span><span style=color:#75715e>fill_n: 3 3 3 3 5 5 5 5 5
</span></span></span><span style=display:flex><span><span style=color:#75715e>for_each: 5 5 5 5 7 7 7 7 7
</span></span></span><span style=display:flex><span><span style=color:#75715e>generate: 2 4 6 8 10 12 14 16 18
</span></span></span><span style=display:flex><span><span style=color:#75715e>generate_n: 20 22 24 8 10 12 14 16 18
</span></span></span><span style=display:flex><span><span style=color:#75715e>transform: 18 20 22 6 8 10 12 14 16
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=7-关系算法>7 关系算法</h3><p>关系算法共 8 个，包含在 头文件中，这里只列出一部分算法：</p><ul><li>equal: 如果两个序列在标志范围内元素都相等，返回 true。重载版本使用输入的操作符代替默认的等于操作符。</li><li>includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的 &lt; 操作符，成功返回 true。重载版本使用用户输入的函数。</li><li>max: 返回两个元素中较大一个。重载版本使用自定义比较操作。</li><li>min: 返回两个元素中较小一个。重载版本使用自定义比较操作。</li><li>max_element: 返回一个 ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。</li><li>min_element: 返回一个 ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。</li><li>mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对 iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的 last。重载版本使用自定义的比较操作。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdafx.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv1(iarr, iarr <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv2(iarr, iarr <span style=color:#f92672>+</span> <span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  equal: 如果两个序列在标志范围内元素都相等，返回true。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;equal: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> equal(iv1.begin(), iv1.end(), iv2.begin()) <span style=color:#f92672>&lt;&lt;</span> endl;<span style=color:#75715e>//  1 表示相等，因为只比较跟 iv1长度大小的数组      
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 判断判断iv2中元素是否都出现在iv1中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;includes: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> includes(iv1.begin(), iv1.end(), iv2.begin(), iv2.end()) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// max: 返回两个元素中较大一个。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;max: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> max(iv1[<span style=color:#ae81ff>0</span>],iv1[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// min: 返回两个元素中较小一个。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;min: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> min(iv1[<span style=color:#ae81ff>0</span>], iv1[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// max_element: 返回一个ForwardIterator，指出序列中最大的元素。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;max_element: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>max_element(iv1.begin(), iv1.end()) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// min_element: 返回一个ForwardIterator，指出序列中最小的元素。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;min_element: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>min_element(iv1.begin(), iv1.end()) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator<span style=color:#f92672>&gt;</span> pa;
</span></span><span style=display:flex><span>	pa <span style=color:#f92672>=</span> mismatch(iv1.begin(), iv1.end(), iv2.begin());
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (pa.first <span style=color:#f92672>==</span> iv1.end()) <span style=color:#75715e>//  true 表示相等，因为只比较跟iv1长度大小的数组 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;第一个向量与第二个向量匹配&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;两个向量不同点--第一个向量点:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>(pa.first) <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// 这样写很危险，应该判断是否到达end   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;两个向量不同点--第二个向量点:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>(pa.second) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>equal: 1
</span></span></span><span style=display:flex><span><span style=color:#75715e>includes: 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>max: 2
</span></span></span><span style=display:flex><span><span style=color:#75715e>min: 1
</span></span></span><span style=display:flex><span><span style=color:#75715e>max_element: 5
</span></span></span><span style=display:flex><span><span style=color:#75715e>min_element: 1
</span></span></span><span style=display:flex><span><span style=color:#75715e>第一个向量与第二个向量匹配
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=8-集合算法>8 <strong>集合算法</strong></h3><p>集合算法共 4 个，包含在 头文件中，这里全部列出：</p><ul><li>set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。</li><li>set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。</li><li>set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。</li><li>set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集 (并集 - 交集)。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdafx.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iterator&gt; </span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>display</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span>x) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr1[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>11</span> };
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr2[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>13</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	multiset<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s1(iarr1, iarr1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>	multiset<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s2(iarr2, iarr2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;s1: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(s1.begin(), s1.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;s2: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(s2.begin(), s2.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;union of s1 and s2: &#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 两个集合合并，相同元素个数取 max(m,n)。   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	set_union(s1.begin(), s1.end(), s2.begin(), s2.end(), ostream_iterator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(cout, <span style=color:#e6db74>&#34; &#34;</span>));
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Intersection of s1 and s2: &#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 两个集合交集，相同元素个数取 min(m,n).  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), ostream_iterator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(cout, <span style=color:#e6db74>&#34; &#34;</span>));
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Intersection of s1 and s2: &#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 两个集合差集 就是去掉S1中 的s2   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), ostream_iterator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(cout, <span style=color:#e6db74>&#34; &#34;</span>));
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Intersection of s1 and s2: &#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 两个集合对称差集：就是取两个集合互相没有的元素 。两个排序区间，元素相等指针后移，不等输出小的并前进   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 相同元素的个数 abs(m-n)   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	set_symmetric_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), ostream_iterator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(cout, <span style=color:#e6db74>&#34; &#34;</span>));
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>s1: 1 3 5 7 9 11
</span></span></span><span style=display:flex><span><span style=color:#75715e>s2: 1 1 2 3 5 8 13
</span></span></span><span style=display:flex><span><span style=color:#75715e>union of s1 and s2: 1 1 2 3 5 7 8 9 11 13
</span></span></span><span style=display:flex><span><span style=color:#75715e>Intersection of s1 and s2: 1 3 5
</span></span></span><span style=display:flex><span><span style=color:#75715e>Intersection of s1 and s2: 7 9 11
</span></span></span><span style=display:flex><span><span style=color:#75715e>Intersection of s1 and s2: 1 2 7 8 9 11 13
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=9-堆算法>9 堆算法</h3><p>集合算法共 4 个，包含在 头文件中，这里只列出一部分算法：</p><ul><li>make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。</li><li>pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把 first 和 last-1 交换，然后重新生成一个堆。可使用容器的 back 来访问被 &ldquo;弹出&rdquo; 的元素或者使用 pop_back 进行真正的删除。重载版本使用自定义的比较操作。</li><li>push_heap: 假设 first 到 last-1 是一个有效堆，要被加入到堆的元素存放在位置 last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdafx.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>display</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span>x) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> iarr[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iv(iarr, iarr <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(iarr) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** make_heap: 把指定范围内的元素生成一个堆。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： void make_heap(_RanIt _First, _RanIt _Last)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	make_heap(iv.begin(), iv.end());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;make_heap: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： void pop_heap(_RanIt _First, _RanIt _Last)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pop_heap(iv.begin(), iv.end());
</span></span><span style=display:flex><span>	iv.pop_back();
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;pop_heap: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*** push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。 ***/</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//  原型： void push_heap(_RanIt _First, _RanIt _Last)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iv.push_back(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>	push_heap(iv.begin(), iv.end());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;push_heap: &#34;</span>;
</span></span><span style=display:flex><span>	for_each(iv.begin(), iv.end(), display<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>make_heap: 5 4 1 3 2
</span></span></span><span style=display:flex><span><span style=color:#75715e>pop_heap: 4 3 1 2
</span></span></span><span style=display:flex><span><span style=color:#75715e>push_heap: 6 4 1 2 3
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=resouce>Resouce</h3><ul><li><a href=https://www.cnblogs.com/linuxAndMcu/p/10264339.html target=_blank rel="external nofollow noopener noreferrer">https://www.cnblogs.com/linuxAndMcu/p/10264339.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2023-09-24 17:00:04">更新于 2023-09-24&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=liudongdong1.github.io/stl%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://liudongdong1.github.io/edit/master/content/posts%5c%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80%5cC++%5cSTL%e7%ae%97%e6%b3%95-%e5%b8%b8%e7%94%a8%e7%ae%97%e6%b3%95.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=liudongdong1.github.io/stl%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/ data-title=STL算法-常用算法 data-hashtags=C++><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=liudongdong1.github.io/stl%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/ data-hashtag=C++><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=liudongdong1.github.io/stl%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/ data-title=STL算法-常用算法 data-image=https://cdn.pixabay.com/photo/2021/11/11/17/14/year-6786741__340.jpg><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=liudongdong1.github.io/tags/c++/>C++</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=liudongdong1.github.io/>主页</a></span></section></div><div class=post-nav><a href=liudongdong1.github.io/stl%E7%AE%97%E6%B3%95-%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/ class=prev rel=prev title=STL算法-数值算法><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>STL算法-数值算法</a>
<a href=liudongdong1.github.io/stl%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/ class=next rel=next title=STL空间配置器>STL空间配置器<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.118.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.17-RC"><img class=fixit-icon src=/liudongdong1.github.io/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=https://liudongdong1.github.io/ target=_blank rel="external nofollow noopener noreferrer">LiuDongdong</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title='网站运行中 ...'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i>&nbsp;<span class=run-times>网站运行中 ...</span></span></div><div class="footer-line ibruce"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://liudongdong1.github.io/ title="在 GitHub 上查看源代码" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#0076ff;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/liudongdong1.github.io/lib/katex/katex.min.css><link rel=stylesheet href=/liudongdong1.github.io/lib/cookieconsent/cookieconsent.min.css><script src=/liudongdong1.github.io/lib/autocomplete/autocomplete.min.js defer></script><script src=/liudongdong1.github.io/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/liudongdong1.github.io/lib/lazysizes/lazysizes.min.js async defer></script><script src=/liudongdong1.github.io/lib/sharer/sharer.min.js async defer></script><script src=/liudongdong1.github.io/lib/typeit/index.umd.js defer></script><script src=/liudongdong1.github.io/lib/katex/katex.min.js defer></script><script src=/liudongdong1.github.io/lib/katex/auto-render.min.js defer></script><script src=/liudongdong1.github.io/lib/katex/copy-tex.min.js defer></script><script src=/liudongdong1.github.io/lib/katex/mhchem.min.js defer></script><script src=/liudongdong1.github.io/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/liudongdong1.github.io/lib/pangu/pangu.min.js defer></script><script src=/liudongdong1.github.io/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},data:{"typeit-header-subtitle-desktop":`<span style='font-family: MMT,"沐目体";'>吾日三省吾身</span>`,"typeit-header-subtitle-mobile":`<span style='font-family: MMT,"沐目体";'>吾日三省吾身</span>`},enablePWA:!0,enablePangu:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"2R1K9SKLQZ",algoliaIndex:"index.zh-cn",algoliaSearchKey:"4a226aa1c5c98d6859e4d1386adb2bc7",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-12-18T16:15:22+08:00",typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"typeit-header-subtitle-desktop":["typeit-header-subtitle-desktop"],"typeit-header-subtitle-mobile":["typeit-header-subtitle-mobile"]},duration:-1,speed:100},watermark:{appendto:".wrapper>main",colspacing:30,content:'<img class="fixit-icon" src="/fixit.min.svg" alt="FixIt logo" /> FixIt 主题',enable:!0,fontfamily:"inherit",fontsize:.85,height:21,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/liudongdong1.github.io/js/theme.min.js defer></script><script src=/liudongdong1.github.io/js/custom.min.js defer></script></body></html>