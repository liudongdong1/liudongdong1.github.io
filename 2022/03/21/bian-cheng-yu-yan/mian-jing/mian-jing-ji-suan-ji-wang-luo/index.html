<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="面经_计算机网络, AIOT,Space&amp;Temporal Sequence Analysis,SpringBoot,liudongdong1,cloud">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>面经_计算机网络 | DaybyDay</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="DaybyDay" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">DaybyDay</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">

      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/about">
          
          <i class="fas fa-user-circle" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>about</span>
        </a>
      </li>
      
      <li>
        <a href="/resume">
          
          <i class="fa fa-user-secret" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>resume</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/gallery" class="waves-effect waves-light">
      
      <i class="fas fa-camera" style="zoom: 0.6;"></i>
      
      <span>Galleries</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">DaybyDay</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-user-circle"></i>
			
			About
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/about " style="margin-left:75px">
				  
				   <i class="fa fas fa-user-circle" style="position: absolute;left:50px" ></i>
			      
		          <span>about</span>
                  </a>
                </li>
              
                <li>

                  <a href="/resume " style="margin-left:75px">
				  
				   <i class="fa fa fa-user-secret" style="position: absolute;left:50px" ></i>
			      
		          <span>resume</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/gallery" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-camera"></i>
			
			Galleries
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/liudongdong1" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/liudongdong1" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.pixabay.com/photo/2022/02/24/15/17/cat-7032641__340.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">面经_计算机网络</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    .toc-fixed .toc-link::before{
        position: fixed!important;/*当toc的位置改为fixed时，.toc-link::before也要改为fixed*/
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Network/">
                                <span class="chip bg-color">Network</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Network/" class="post-category">
                                Network
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2022-03-21
                </div>
                

                <!-- 
                    <i class="fa fa-pencil"></i> Author: liudongdong1
                  -->

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2022-04-02
                </div>
                

                <!-- 
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    8.9k
                </div>
                 -->

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    32 Min
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p>计算机网络是指将<a href="https://baike.baidu.com/item/地理" target="_blank" rel="noopener">地理</a>位置不同的具有独立功能的多台<a href="https://baike.baidu.com/item/计算机/140338" target="_blank" rel="noopener">计算机</a>及其外部设备，通过通信线路连接起来，在<a href="https://baike.baidu.com/item/网络操作系统/3997" target="_blank" rel="noopener">网络操作系统</a>，<a href="https://baike.baidu.com/item/网络管理软件/6579078" target="_blank" rel="noopener">网络管理软件</a>及<a href="https://baike.baidu.com/item/网络通信协议/4438611" target="_blank" rel="noopener">网络通信协议</a>的管理和协调下，实现<a href="https://baike.baidu.com/item/资源共享/233480" target="_blank" rel="noopener">资源共享</a>和信息传递的计算机系统。 <a href="https://github.com/liudongdong1/AwesomeStudyResource/raw/master/CourseXmindHighSummary/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" target="_blank" rel="noopener">思维导图</a></p>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF.jpg" alt=""></p>
<h5 id="1-网络分层结构"><a href="#1-网络分层结构" class="headerlink" title=".1. 网络分层结构"></a>.1. 网络分层结构</h5><blockquote>
<ul>
<li>易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。</li>
<li>有利于标准化的制定</li>
</ul>
</blockquote>
<ul>
<li><code>OSI七层网络</code>: 物理层（比特流），数据链路层（相邻节点），网络层(路由交换机），传输层（主机进程），会话层，表示层，应用层</li>
<li><code>TCP/IP五层网络</code>；</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/MBXY-CR-7943d7dc8a2afb50c58f3467d45fa768-164801861565817.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/MBXY-CR-ba1e2d8a01c7492d49d39cb93378550f.png" alt=""></p>
<h5 id="1-IP-地址分类"><a href="#1-IP-地址分类" class="headerlink" title=".1. IP 地址分类"></a>.1. IP 地址分类</h5><ul>
<li>A,B,C,D,E 五类</li>
<li>IP 地址 = 网络号 + 主机号。</li>
</ul>
<h5 id="2-三次握手"><a href="#2-三次握手" class="headerlink" title=".2. 三次握手"></a>.2. 三次握手</h5><blockquote>
<ul>
<li>序号：seq，占 32 位，用来标识从发送端到接收端发送的字节流。</li>
<li>确认号：ack，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1。</li>
<li>标志位：<ul>
<li>SYN：发起一个新连接。</li>
<li>FIN：释放一个连接。</li>
<li>ACK：确认序号有效。</li>
</ul>
</li>
</ul>
</blockquote>
<p>假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是 <code>CLOSED</code>。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220227224749976-164801861565819.png" alt=""></p>
<ol>
<li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个<code>起始序列号 x</code>，客户端向服务端发送的字段中包含<code>标志位</code> <code>SYN=1</code>，<code>序列号</code> <code>seq=x</code>。第一次握手前客户端的状态为 <code>CLOSE</code>，第一次握手后客户端的状态为 <code>SYN-SENT</code>。此时服务端的状态为 <code>LISTEN</code>。</li>
<li>第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号 y，然后给客户端回复一段报文，其中包括标志位 <code>SYN=1</code>，<code>ACK=1</code>，序列号 <code>seq=y</code>，确认号 <code>ack=x+1</code>。第二次握手前服务端的状态为 <code>LISTEN</code>，第二次握手后服务端的状态为 <code>SYN-RCVD</code>，此时客户端的状态为 <code>SYN-SENT</code>。（其中 <code>SYN=1</code> 表示要和客户端建立一个连接，<code>ACK=1</code> 表示确认序号有效）</li>
<li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位 <code>ACK=1</code>，序列号 <code>seq=x+1</code>，确认号 <code>ack=y+1</code>。第三次握手前客户端的状态为 <code>SYN-SENT</code>，第三次握手后客户端和服务端的状态都为 <code>ESTABLISHED</code>。此时连接建立完成。</li>
</ol>
<h5 id="3-如果三次握手对方都没收到回怎么样"><a href="#3-如果三次握手对方都没收到回怎么样" class="headerlink" title=".3. 如果三次握手对方都没收到回怎么样"></a>.3. 如果三次握手对方都没收到回怎么样</h5><ol>
<li><p>如果第一次握手消息丢失，那么请求方不会得到 ack 消息，<code>超时后进行重传</code></p>
</li>
<li><p>如果第二次握手消息丢失，那么请求方不会得到 ack 消息，<code>超时后进行重传</code></p>
</li>
<li><p>如果第三次握手消息丢失，那么 <code>Server 端该 TCP 连接的状态为 SYN_RECV, 并且会根据 TCP 的超时重传机制，会等待 3 秒、6 秒、12 秒后重新发送 SYN+ACK 包</code>，以便 Client 重新发送 ACK 包。而 Server 重发 SYN+ACK 包的次数，可以设置 /proc/sys/net/ipv4/tcp_synack_retries 修改，默认值为 5. 如果<code>重发指定次数</code>之后，仍然未收到 client 的 ACK 应答，那么一段时间后，Server 自动关闭这个连接。</p>
<p>client 一般是通过 connect () 函数来连接服务器的，而<code>connect () 是在 TCP 的三次握手的第二次握手完成后就成功返回值</code>。也就是说 client 在接收到 SYN+ACK 包，它的 TCP 连接状态就为 established （已连接），表示该连接已经建立。那么如果 第三次握手中的 ACK 包丢失的情况下，Client 向 server 端发送数据，Server 端将以 RST 包响应，方能感知到 Server 的错误。</p>
</li>
</ol>
<h5 id="3-俩次握手可以吗"><a href="#3-俩次握手可以吗" class="headerlink" title=".3. 俩次握手可以吗"></a>.3. 俩次握手可以吗</h5><ul>
<li>为了防止<code>已失效的连接请求报文段突然又传送到了服务端</code>，因而产生错误, 浪费资源</li>
<li>双方都需要<code>确认对方收到了自己发送的序列号</code>，确认过程最少要进行三次通信。</li>
<li>信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值</li>
</ul>
<p><code>防止已失效的连接请求报文段突然又传输到了服务端</code>，导致产生问题<code>(资源浪费）</code>。</p>
<ul>
<li>比如客户端 A 发出连接请求，可能因为网络阻塞原因，A 没有收到确认报文，于是 A 再重传一次连接请求。</li>
<li>连接成功，等待数据传输完毕后，就释放了连接。</li>
<li>然后 A 发出的第一个连接请求等到连接释放以后的某个时间才到达服务端 B，此时 B 误认为 A 又发出一次新的连接请求，于是就向 A 发出确认报文段。</li>
<li>如果不采用三次握手，只要 B 发出确认，就建立新的连接了，<strong>此时 A 不会响应 B 的确认且不发送数据，则 B 一直等待 A 发送数据，浪费资源。</strong></li>
</ul>
<h5 id="3-什么是MSL，-为什么需要等待连接2MSL的时间才能完全关闭"><a href="#3-什么是MSL，-为什么需要等待连接2MSL的时间才能完全关闭" class="headerlink" title=".3. 什么是MSL， 为什么需要等待连接2MSL的时间才能完全关闭"></a>.3. 什么是MSL， 为什么需要等待连接2MSL的时间才能完全关闭</h5><ol>
<li>MSL 是 Maximum Segment Lifetime 的英文缩写，可译为<code>“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</code></li>
<li>为了保证客户端发送的最后一个 ACK 报文段能够到达服务器。因为这个 ACK 有可能丢失，从而导致处在 LAST-ACK 状态的服务器收不到对 FIN-ACK 的确认报文。服务器会超时重传这个 FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待 2MSL，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就无法正常的进入关闭连接状态。</li>
</ol>
<ul>
<li><p>两个理由：</p>
<ul>
<li><p>保证客户端发送的最后一个 ACK 报文段能够到达服务端。</p>
<p>这个 ACK 报文段有可能丢失，使得处于 LAST-ACK 状态的 B 收不到对已发送的 FIN+ACK 报文段的确认，服务端超时重传 FIN+ACK 报文段，而客户端能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段，接着客户端重传一次确认，重新启动 2MSL 计时器，最后客户端和服务端都进入到 CLOSED 状态，若客户端在 TIME-WAIT 状态不等待一段时间，而是发送完 ACK 报文段后立即释放连接，则无法收到服务端重传的 FIN+ACK 报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到 CLOSED 状态。</p>
</li>
<li><p>防止 “已失效的连接请求报文段” 出现在本连接中。</p>
<p>客户端在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
</li>
</ul>
</li>
</ul>
<h5 id="4-四次挥手"><a href="#4-四次挥手" class="headerlink" title=".4. 四次挥手"></a>.4. 四次挥手</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/MBXY-CR-44ee0cb73ea8397feb1977d138f8f995.png" alt=""></p>
<ol>
<li>A 的应用进程先向其 TCP 发出连接释放报文段（<code>FIN=1，seq=u</code>），并停止再发送数据，主动关闭 TCP 连接，进入 <code>FIN-WAIT-1</code>（终止等待 1）状态，等待 B 的确认。</li>
<li>B 收到连接释放报文段后即发出确认报文段（<code>ACK=1，ack=u+1，seq=v</code>），B 进入 <code>CLOSE-WAIT</code>（关闭等待）状态，此时的 TCP 处于半关闭状态，A 到 B 的连接释放。</li>
<li>A 收到 B 的确认后，进入 <code>FIN-WAIT-2</code>（终止等待 2）状态，等待 B 发出的连接释放报文段。</li>
<li>B 发送完数据，就会发出连接释放报文段（<code>FIN=1，ACK=1，seq=w，ack=u+1</code>），B 进入 <code>LAST-ACK</code>（最后确认）状态，等待 A 的确认。</li>
<li>A 收到 B 的连接释放报文段后，对此发出确认报文段（<code>ACK=1，seq=u+1，ack=w+1</code>），A 进入 <code>TIME-WAIT</code>（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 <code>2MSL</code>（最大报文段生存时间）后，A 才进入 <code>CLOSED</code> 状态。B 收到 A 发出的确认报文段后关闭连接，若没收到 A 发出的确认报文段，B 就会重传连接释放报文段。</li>
</ol>
<h5 id="6-为什么是四次挥手？"><a href="#6-为什么是四次挥手？" class="headerlink" title=".6. 为什么是四次挥手？"></a>.6. 为什么是四次挥手？</h5><ul>
<li>因为 TCP 是<code>全双工模式</code>，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前<code>没传完</code>的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以<code>TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的</code>（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</li>
<li>客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而<code>连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送</code>。</li>
</ul>
<p>因为当 Server 端收到 Client 端的 <code>SYN</code> 连接请求报文后，可以直接发送 <code>SYN+ACK</code> 报文。<strong>但是在关闭连接时，当 Server 端收到 Client 端发出的连接释放报文时，很可能并不会立即关闭 SOCKET</strong>，所以 Server 端先回复一个 <code>ACK</code> 报文，告诉 Client 端我收到你的连接释放报文了。只有等到 Server 端所有的报文都发送完了，这时 Server 端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。</p>
<h5 id="6-服务器出现大量Close-wait-状态"><a href="#6-服务器出现大量Close-wait-状态" class="headerlink" title=".6. 服务器出现大量Close_wait 状态"></a>.6. 服务器出现大量Close_wait 状态</h5><ul>
<li>服务器端收到客户端发送的 <code>FIN</code> 后，TCP 协议栈就会自动发送 ACK，接着进入 <strong>CLOSE_WAIT</strong> 状态。</li>
<li>但是如果服务器端不执行 socket 的 close () 操作，那么就没法进入 LAST_ACK, 导致大量连接处于 CLOSE_WAIT 状态</li>
<li>所以，如果服务器出现了大量 <strong>CLOSE_WAIT</strong> 状态，一般是<code>程序 Bug，或者关闭 socket 不及时</code>。</li>
</ul>
<h5 id="6-客户端突然故障断开链接"><a href="#6-客户端突然故障断开链接" class="headerlink" title=".6. 客户端突然故障断开链接"></a>.6. 客户端突然故障断开链接</h5><blockquote>
<p><code>保活机制原理</code>：设置 TCP 保活机制的<code>保活时间 keepIdle</code>，即在 TCP 链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间<code>间隔 keepInterval</code>；设置保活探测报文的<code>总发送次数</code> keepCount。如果在 keepCount 次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的 TCP 链接。</p>
</blockquote>
<h5 id="7-TCP-有哪些特点？"><a href="#7-TCP-有哪些特点？" class="headerlink" title=".7. TCP 有哪些特点？"></a>.7. TCP 有哪些特点？</h5><ul>
<li>TCP 是<strong>面向连接</strong>的运输层协议。</li>
<li><strong>点对点</strong>，每一条 TCP 连接只能有两个端点。</li>
<li>TCP 提供<strong>可靠交付</strong>的服务。</li>
<li>TCP 提供<strong>全双工通信</strong>。</li>
<li><strong>面向字节流</strong>。</li>
</ul>
<h5 id="7-TCP-粘包"><a href="#7-TCP-粘包" class="headerlink" title=".7. TCP 粘包"></a>.7. TCP 粘包</h5><p><strong>为什么会产生粘包和拆包呢？</strong></p>
<ul>
<li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li>
<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>发送端将每个数据包封装为固定长度</li>
<li>在数据尾部增加特殊字符进行分割</li>
<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li>
</ul>
<h5 id="7-端口及对应服务"><a href="#7-端口及对应服务" class="headerlink" title=".7. 端口及对应服务"></a>.7. 端口及对应服务</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/MBXY-CR-b651e46b88d855f852c6a8f0d93fcc08-164801861565821.png" alt=""></p>
<h5 id="7-TCP-如何保证可靠传输"><a href="#7-TCP-如何保证可靠传输" class="headerlink" title=".7. TCP 如何保证可靠传输"></a>.7. TCP 如何保证可靠传输</h5><ul>
<li>校验和</li>
<li>序列号：TCP 会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答 (ACK 报文)，并且这个 ACK 报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。</li>
<li>超时重传</li>
<li>流量控制： TCP 协议利用了<code>滑动窗口进行了流量控制</code>。在 TCP 首部有一个 16 位字段大小的窗口，<code>窗口的大小就是接收端接收数据缓冲区的剩余大小</code>。接收端会在收到数据包后发送 ACK 报文时，将自己的窗口大小填入 ACK 中，发送方会根据 ACK 报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。</li>
<li>拥塞避免: 如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。拥塞控制主要有四部分组成：<code>慢开始、拥塞避免、快重传、快恢复</code>，如下图 (图片来源于网络)。<ul>
<li>慢开始：为了避免一开始发送大量的数据而产生网络阻塞，会先初始化 <code>cwnd 为 1</code>，当收到 ACK 后到下一个传输轮次，cwnd 为 2，以此类推成指数形式增长。</li>
<li>拥塞避免：因为 cwnd 的数量在慢开始是指数增长的，为了防止 cwnd 数量过大而导致网络阻塞，会设置一个慢开始的<code>门限值 ssthresh</code>，当 cwnd&gt;=ssthresh 时，进入到拥塞避免阶段，cwnd 每个传输轮次加 1。但网络出现超时，会将门限值 ssthresh 变为出现超时 cwnd 数值的一半，cwnd 重新设置为 1，如上图，在第 12 轮出现超时后，cwnd 变为 1，ssthresh 变为 12。</li>
<li>快重传：在网络中如果出现超时或者阻塞，则按慢开始和拥塞避免算法进行调整。但如果只是丢失某一个报文段，如下图 (图片来源于网络)，则使用快重传算法。</li>
<li>快恢复：快恢复是指将<code>ssthresh 设置为发生快重传时的 cwnd 数量的一半</code>，而<code>cwnd 不是设置为 1 而是设置为为门限值 ssthresh</code>，并开始拥塞避免阶段。</li>
</ul>
</li>
</ul>
<blockquote>
<p>拥塞控制是<strong>作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况</strong>。它的目标主要是最大化利用网络上瓶颈链路的带宽</p>
<p>流量控制是作用于接收者的，根据<strong>接收端的实际接收能力控制发送速度</strong>，防止<code>分组丢失</code>的。</p>
</blockquote>
<h5 id="8-TCP-和-UDP-的区别？"><a href="#8-TCP-和-UDP-的区别？" class="headerlink" title=".8. TCP 和 UDP 的区别？"></a>.8. TCP 和 UDP 的区别？</h5><ol>
<li>TCP <strong>面向连接</strong>；UDP 是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP 提供<strong>可靠的服务</strong>；UDP 不保证可靠交付。</li>
<li>TCP <strong>面向字节流</strong>，把数据看成一连串无结构的字节流；UDP 是面向<code>报文</code>的。</li>
<li>TCP 有<strong>拥塞控制</strong>；UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。</li>
<li>每一条 TCP 连接只能是<strong>点到点</strong>的；UDP 支持<code>一对一、一对多、多对一和多对多</code>的通信方式。</li>
<li>TCP 首部开销 20 字节；UDP 的<code>首部开销</code>小，只有 8 个字节。</li>
<li>TCP: HTTP, HTTPS, SSH, Telnet, SMTP;  UDP: DNS, SNMP</li>
</ol>
<h5 id="9-从系统层面上，UDP-如何保证尽量可靠"><a href="#9-从系统层面上，UDP-如何保证尽量可靠" class="headerlink" title=".9. 从系统层面上，UDP 如何保证尽量可靠"></a>.9. 从系统层面上，UDP 如何保证尽量可靠</h5><ol>
<li>UDP 仅提供了最基本的数据传输功能，至于<code>传输时连接的建立和断开、传输可靠性的保证</code>这些 UDP 统统不关心，而是把这些问题抛给了 UDP 上层的应用层程序去处理，自己仅提供传输层协议的最基本功能。</li>
<li>最简单的方式是在<code>应用层模仿传输层 TCP 的可靠性传输</code>。下面不考虑拥塞处理，可靠 UDP 的简单设计。<ul>
<li><code>添加 seq/ack 机制</code>，确保数据发送到对端</li>
<li>添加<code>发送和接收缓冲区</code>，主要是用户超时重传。</li>
<li>添加<code>超时重传机制</code>。</li>
</ul>
</li>
</ol>
<h5 id="9-简述-TCP-协议的延迟-ACK-和累计应答"><a href="#9-简述-TCP-协议的延迟-ACK-和累计应答" class="headerlink" title=".9. 简述 TCP 协议的延迟 ACK 和累计应答"></a>.9. 简述 TCP 协议的延迟 ACK 和累计应答</h5><ol>
<li><code>延迟应答</code>指的是：TCP 在接收到对端的报文后，并不会立即发送 ack，而是<code>等待一段时间发送 ack</code>，以便<code>将 ack 和要发送的数据一块发送</code>。当然 ack 不能无限延长，否则对端会认为包超时而造成报文重传。linux 采用动态调节算法来确定延时的时间。</li>
<li><code>累计应答</code>指的是：为了保证<strong>顺序性</strong>，每一个包都有一个 <strong>ID</strong>（序号），在建立连接的时候，会商定起始的 ID 是多少，然后按照 ID 一个个发送。而为了保证不丢包，对应发送的包都要进行应答，但不是一个个应答，而是会<strong>应答某个之前的 ID</strong>，该模式称为<strong>累计应答</strong></li>
</ol>
<h5 id="9-TCP-如何加速一个大文件的传输"><a href="#9-TCP-如何加速一个大文件的传输" class="headerlink" title=".9. TCP 如何加速一个大文件的传输"></a>.9. TCP 如何加速一个大文件的传输</h5><ol>
<li>建连优化：TCP 在建立连接时，如果丢包，会进入重试，重试时间是 1s、2s、4s、8s 的指数递增间隔，缩短定时器可以让 TCP 在丢包环境建连时间更快，非常适用于高并发短连接的业务场景。</li>
<li>平滑发包：在 RTT 内均匀发包，规避微分时间内的流量突发，尽量避免瞬间拥塞</li>
<li>丢包预判：有些网络的丢包是有规律性的，例如每隔一段时间出现一次丢包，例如每次丢包都连续丢几个等，如果程序能自动发现这个规律（有些不明显），就可以针对性提前多发数据，减少重传时间、提高有效发包率。</li>
<li>RTO 探测：若始终收不到 ACK 报文，则需要触发 RTO 定时器。RTO 定时器一般都时间非常长，会浪费很多等待时间，而且一旦 RTO，CWND 就会骤降（标准 TCP），因此利用 Probe 提前与 RTO 去试探，可以规避由于 ACK 报文丢失而导致的速度下降问题。</li>
<li><code>带宽评估</code>：通过单位时间内收到的 ACK 或 SACK 信息可以得知客户端有效接收速率，通过这个速率可以更<code>合理的控制发包速度</code>。</li>
<li>带宽争抢：有些场景（例如合租）是大家互相挤占带宽的，假如你和室友各 1Mbps 的速度看电影，会把 2Mbps 出口占满，而如果一共有 3 个人看，则每人只能分到 1/3。若此时你的流量流量达到 2Mbps，而他俩还都是 1Mbps，则你至少仍可以分到 2/(2+1+1) * 2Mbps = 1Mbps 的 50% 的带宽，甚至更多，代价就是服务器侧的出口流量加大，增加成本。（TCP 优化的本质就是用带宽换用户体验感）</li>
</ol>
<h5 id="9-HTTP-协议的特点"><a href="#9-HTTP-协议的特点" class="headerlink" title=".9. HTTP 协议的特点"></a>.9. HTTP 协议的特点</h5><ol>
<li>HTTP 允许传输<strong>任意类型</strong>的数据。传输的类型由 Content-Type 加以标记。</li>
<li><strong>无状态</strong>。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。</li>
<li>支持<strong>客户端 / 服务器模式</strong>。</li>
</ol>
<h5 id="10-HTTP-报文格式"><a href="#10-HTTP-报文格式" class="headerlink" title=".10. HTTP 报文格式"></a>.10. HTTP 报文格式</h5><p>HTTP 请求由<strong>请求行、请求头部、空行和请求体</strong>四个部分组成。</p>
<ul>
<li><strong>请求行</strong>：包括请求方法，访问的资源 URL，使用的 HTTP 版本。<code>GET</code> 和 <code>POST</code> 是最常见的 HTTP 方法，除此以外还包括 <code>DELETE、HEAD、OPTIONS、PUT、TRACE</code>。</li>
<li><strong>请求头</strong>：格式为 “属性名：属性值”，服务端根据请求头获取客户端的信息，主要有 <code>cookie、host、connection、accept-language、accept-encoding、user-agent</code>。</li>
<li><strong>请求体</strong>：用户的请求数据如用户名，密码等。</li>
</ul>
<p><strong>请求报文示例</strong>：</p>
<pre><code>POST /xxx HTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=dabin 请求体</code></pre><p>HTTP 响应也由四个部分组成，分别是：<strong>状态行、响应头、空行和响应体</strong>。</p>
<ul>
<li><strong>状态行</strong>：协议版本，状态码及状态描述。</li>
<li><strong>响应头</strong>：响应头字段主要有 <code>connection、content-type、content-encoding、content-length、set-cookie、Last-Modified，、Cache-Control、Expires</code>。</li>
<li><strong>响应体</strong>：服务器返回给客户端的内容。</li>
</ul>
<p><strong>响应报文示例</strong>：</p>
<pre><code>HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

&lt;html&gt;
    &lt;body&gt;响应体&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id="11-HTTP-状态码有哪些？"><a href="#11-HTTP-状态码有哪些？" class="headerlink" title=".11.  HTTP 状态码有哪些？"></a>.11.  HTTP 状态码有哪些？</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828804-164801861565923.png" alt="图片"></p>
<h5 id="12-HTTP1-0-和-HTTP1-1-的区别？"><a href="#12-HTTP1-0-和-HTTP1-1-的区别？" class="headerlink" title=".12. HTTP1.0 和 HTTP1.1 的区别？"></a>.12. HTTP1.0 和 HTTP1.1 的区别？</h5><ul>
<li><strong>长连接</strong>：HTTP1.0 默认使用短连接，<code>每次请求都需要建立新的 TCP 连接，连接不能复用</code>。<strong>HTTP1.1 支持长连接，复用 TCP 连接，允许客户端通过同一连接发送多个请求</strong>。不过，这个优化策略也存在问题，当一个队头的请求不能收到响应的资源时，它将会阻塞后面的请求。这就是 “<strong>队头阻塞</strong>” 问题。</li>
<li><strong>断点续传</strong>：HTTP1.0 <strong>不支持断点续传</strong>。HTTP1.1 新增了 <strong>range</strong> 字段，用来指定数据字节位置，<strong>支持断点续传</strong>。</li>
<li><strong>错误状态响应码</strong>：在 HTTP1.1 中新增了 24 个错误状态响应码，如 <code>409（Conflict）</code>表示请求的资源与资源的当前状态发生冲突、<code>410（Gone）</code>表示服务器上的某个资源被永久性的删除。</li>
<li><strong>Host 头处理</strong>：在 HTTP1.0 中认为<code>每台服务器都绑定一个唯一的 IP 地址</code>，因此，请求消息中的 URL 并没有传递主机名。到了 HTTP1.1 时代，虚拟主机技术发展迅速，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址，故 <code>HTTP1.1 增加了 HOST 信息</code>。</li>
</ul>
<h5 id="13-get-和post-区别"><a href="#13-get-和post-区别" class="headerlink" title=".13. get 和post 区别"></a>.13. get 和post 区别</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220304105225789.png" alt=""></p>
<h5 id="13-HTTP1-1-和-HTTP2-0-的区别？"><a href="#13-HTTP1-1-和-HTTP2-0-的区别？" class="headerlink" title=".13. HTTP1.1 和 HTTP2.0 的区别？"></a>.13. HTTP1.1 和 HTTP2.0 的区别？</h5><p>HTTP2.0 相比 HTTP1.1 支持的特性：</p>
<ul>
<li><strong>新的二进制格式</strong>：HTTP1.1 基于文本格式传输数据；HTTP2.0 采用二进制格式传输数据，解析更高效。</li>
<li><strong>多路复用</strong>：在一个连接里，允许同时发送多个请求或响应，<strong>并且这些请求或响应能够并行的传输而不被阻塞</strong>，避免 HTTP1.1 出现的” 队头堵塞” 问题。</li>
<li><strong>头部压缩</strong>，HTTP1.1 的 header 带有大量信息，而且每次都要重复发送；HTTP2.0 把 header 从数据中分离，并封装成头帧和数据帧，<strong>使用特定算法压缩头帧</strong>，有效减少头信息大小。并且 HTTP2.0 <strong>在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。\</strong>比如请求 a 发送了所有的头信息字段，请求 b 则*<em>只需要发送差异数据*</em>，这样可以减少冗余数据，降低开销。</li>
<li><strong>服务端推送</strong>：HTTP2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。</li>
</ul>
<h5 id="14-HTTPS-与-HTTP-的区别"><a href="#14-HTTPS-与-HTTP-的区别" class="headerlink" title=".14. HTTPS 与 HTTP 的区别"></a>.14. HTTPS 与 HTTP 的区别</h5><ol>
<li>HTTP 是超文本传输协议，信息是<strong>明文传输</strong>；HTTPS 则是具有<strong>安全性</strong>的 ssl 加密传输协议。</li>
<li>HTTP 和 HTTPS 用的端口不一样，<code>HTTP 端口是 80，HTTPS 是 443</code>。</li>
<li>HTTPS 协议<strong>需要到 CA 机构申请证书</strong>，一般需要一定的费用。</li>
<li>HTTP 运行在 TCP 协议之上；HTTPS 运行在 SSL 协议之上，<code>SSL 运行在 TCP 协议</code>之上。</li>
</ol>
<h5 id="15-什么是数字证书"><a href="#15-什么是数字证书" class="headerlink" title=".15.  什么是数字证书"></a>.15.  什么是数字证书</h5><p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/1460000038526733-164801861565925.png" alt=""></p>
<p>服务端可以向证书<code>颁发机构 CA</code>申请证书，以<code>避免中间人攻击</code>（防止证书被篡改）。证书包含三部分内容：<strong>证书内容、证书签名算法和签名</strong>，签名是为了验证身份。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828805-164801861565927.png" alt="图片"></p>
<p>服务端把证书传输给浏览器，<code>浏览器从证书里取公钥</code>。<code>证书可以证明该公钥对应本网站</code>。</p>
<p><strong>数字签名的制作过程</strong>：</p>
<ol>
<li>CA 使用证书签名算法对证书内容进行 <strong>hash 运算</strong>。</li>
<li>对 hash 后的值<strong>用 CA 的私钥加密</strong>，得到数字签名。</li>
</ol>
<p><strong>浏览器验证过程</strong>：</p>
<ol>
<li>获取证书，得到<code>证书内容、证书签名算法和数字签名</code>。</li>
<li>用 CA 机构的公钥<strong>对数字签名解密</strong>（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。</li>
<li>用证书里的签名算法<strong>对证书内容进行 hash 运算</strong>。</li>
<li>比较解密后的数字签名和对证书内容做 hash 运算后得到的哈希值，相等则表明证书可信。</li>
</ol>
<h5 id="16-HTTPS-原理"><a href="#16-HTTPS-原理" class="headerlink" title=".16. HTTPS 原理"></a>.16. HTTPS 原理</h5><p>首先是 <code>TCP 三次握手</code>，然后<code>客户端发起一个 HTTPS 连接建立请求</code>，客户端先发一个 <code>Client Hello</code> 的包，然后服务端响应 <code>Server Hello</code>，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。</p>
<ol>
<li><p><strong>协商加密算法</strong> 。在 <code>Client Hello</code> 里面客户端会告知服务端自己当前的一些<code>信息</code>，包括客户端要使用的 TLS 版本，支持的加密算法，要访问的域名，给服务端生成的一个随机数（Nonce）等。需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828806-164801861565929.png" alt="图片"></p>
</li>
<li><p>服务端响应 <code>Server Hello</code>，告诉客户端服务端<strong>选中的加密算法</strong>。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828807-164801861565931.png" alt=""></p>
</li>
<li><p>接着服务端给客户端发来了 <code>2 个证书。第二个证书是第一个证书的签发机构（CA）的证书</code>。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828808-164801861565933.png" alt=""></p>
</li>
<li><p>客户端使用证书的认证机构 CA 公开发布的 RSA 公钥<strong>对该证书进行验证</strong>，下图表明证书认证成功。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-16459735828809-164801861565935.png" alt="图片"></p>
</li>
<li><p>验证通过之后，浏览器和服务器通过<strong>密钥交换算法</strong>产生共享的<strong>对称密钥</strong>。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-164597358288010-164801861565937.png" alt="图片"></p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-164597358288111-164801861565939.png" alt="图片"></p>
</li>
<li><p>开始传输数据，使用同一个对称密钥来加解密。</p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-164597358288112-164801861565941.png" alt="图片"></p>
</li>
</ol>
<h5 id="17-DNS-的解析过程"><a href="#17-DNS-的解析过程" class="headerlink" title=".17. DNS 的解析过程"></a>.17. DNS 的解析过程</h5><ol>
<li>浏览器搜索<strong>自己的 DNS 缓存</strong></li>
<li>若没有，则搜索<strong>操作系统中的 DNS 缓存和 hosts 文件</strong></li>
<li>若没有，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果，否则依次向<strong>根域名服务器、顶级域名服务器、权限域名服务器</strong>发起查询请求，最终返回 IP 地址给本地域名服务器</li>
<li>本地域名服务器将得到的 IP 地址返回给<strong>操作系统</strong>，同时自己也<strong>将 IP 地址缓存起来</strong></li>
<li><code>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</code></li>
<li>浏览器得到域名对应的 IP 地址</li>
</ol>
<h5 id="18-浏览器中输入-URL-返回页面过程"><a href="#18-浏览器中输入-URL-返回页面过程" class="headerlink" title=".18. 浏览器中输入 URL 返回页面过程"></a>.18. 浏览器中输入 URL 返回页面过程</h5><ol>
<li><strong>解析域名</strong>，找到主机 IP。</li>
<li><code>浏览器</code>利用 IP 直接与<code>网站主机</code>通信，<strong>三次握手</strong>，建立 TCP 连接。浏览器会以一个随机端口向服务端的 web 程序 <code>80</code>端口发起 TCP 的连接。</li>
<li>建立 TCP 连接后，浏览器向主机发起一个 <code>HTTP 请求</code>。</li>
<li>服务器<strong>响应请求</strong>，返回<code>响应数据</code>。</li>
<li>浏览器<strong>解析响应内容，进行渲染</strong>，呈现给用户。</li>
</ol>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/640-164597358288113-164801861565943.png" alt="图片"></p>
<h5 id="19-Cookie-和-Session-的区别"><a href="#19-Cookie-和-Session-的区别" class="headerlink" title=".19. Cookie 和 Session 的区别"></a>.19. Cookie 和 Session 的区别</h5><ul>
<li><strong>作用范围不同</strong>，Cookie 保存在<code>客户端</code>，Session 保存在<code>服务器端</code>。</li>
<li><strong>有效期不同</strong>，Cookie 可设置为<code>长时间保持</code>，比如我们经常使用的默认登录功能，Session 一般失效时间较短，<code>客户端关闭或者 Session 超时</code>都会失效。</li>
<li><strong>隐私策略不同</strong>，Cookie 存储在客户端，容易被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li><strong>存储大小不同</strong>， 单个<code>Cookie 保存的数据不能超过 4K</code>；对于 Session 来说存储没有上限，但出于对服务器的性能考虑，Session 内不要存放过多的数据，并且需要设置 Session 删除机制。</li>
</ul>
<blockquote>
<p>Session 的作用是在服务端来保持状态，<code>通过 sessionid 来进行确认身份</code>，但 sessionid 一般是通过 Cookie 来进行传递的。如果 Cooike 被禁用了，可以通过在<code>URL 中传递 sessionid</code></p>
</blockquote>
<blockquote>
<p><code>Servlet 不是线程安全的，多线程的读写会导致数据不同步的问题</code>。</p>
</blockquote>
<h5 id="20-什么是对称加密和非对称加密？"><a href="#20-什么是对称加密和非对称加密？" class="headerlink" title=".20. 什么是对称加密和非对称加密？"></a>.20. 什么是对称加密和非对称加密？</h5><p><strong>对称加密</strong>：通信双方使用<strong>相同的密钥</strong>进行加密。特点是加密速度快，但是缺点是密钥泄露会导致密文数据被破解。常见的对称加密有 <code>AES</code> 和 <code>DES</code> 算法。</p>
<p><strong>非对称加密</strong>：它需要生成两个密钥，<strong>公钥和私钥</strong>。公钥是公开的，任何人都可以获得，而私钥是私人保管的。公钥负责加密，私钥负责解密；或者私钥负责加密，公钥负责解密。这种加密算法<strong>安全性更高</strong>，但是<strong>计算量相比对称加密大很多</strong>，加密和解密都很慢。常见的非对称算法有 <code>RSA</code> 和 <code>DSA</code>。</p>
<h5 id="21-URI-和URL"><a href="#21-URI-和URL" class="headerlink" title=".21. URI 和URL"></a>.21. URI 和URL</h5><blockquote>
<ul>
<li>URI (Uniform Resource Identifier)：中文全称为统一资源标志符，主要作用是唯一标识一个资源。</li>
<li>URL (Uniform Resource Location)：中文全称为统一资源定位符，主要作用是提供资源的路径。</li>
</ul>
</blockquote>
<h5 id="22-ARP-协议"><a href="#22-ARP-协议" class="headerlink" title=".22. ARP 协议"></a>.22. ARP 协议</h5><blockquote>
<p>ARP 协议属于<code>网络层的协议</code>，主要作用是实现从<code>IP 地址转换为 MAC 地址</code>。在每个<code>主机或者路由器</code>中都建有一个 <code>ARP 缓存表</code>，表中有 IP 地址及 IP 地址对应的 MAC 地址。</p>
<ul>
<li>IP 地址：IP 地址是指互联网协议地址,它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异</li>
<li>MAC 地址：MAC 地址又称物理地址，由网络设备制造商生产时写在硬件内部，不可更改，并且每个以太网设备的 MAC 地址都是唯一的。</li>
</ul>
<p>计算机的 IP 地址可由用户<code>自行更改</code>，管理起来相对困难，而 MAC 地址不可更改</p>
<p>路由器通过 IP 地址的前缀就知道设备在在哪个子网上了，而只用 MAC 地址的话，路由器则需要记住每个 MAC 地址在哪个子网，这需要路由器有极大的存储空间</p>
</blockquote>
<h5 id="23-路由器和交换机"><a href="#23-路由器和交换机" class="headerlink" title=".23. 路由器和交换机"></a>.23. 路由器和交换机</h5><table>
<thead>
<tr>
<th align="center">所属网络模型的层级</th>
<th align="center">功能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">路由器</td>
<td align="center">网络层</td>
<td>识别 IP 地址并根据 IP 地址转发数据包，维护数据表并基于数据表进行最佳路径选择</td>
</tr>
<tr>
<td align="center">交换机</td>
<td align="center"><code>数据链库层</code></td>
<td>识别<code>MAC 地址并根据 MAC 地址转发数据帧</code></td>
</tr>
</tbody></table>
<h5 id="24-Ping-过程"><a href="#24-Ping-过程" class="headerlink" title=".24. Ping 过程"></a>.24. Ping 过程</h5><blockquote>
<ol>
<li>向目的主机发送多个<code>ICMP 回送请求报文</code></li>
<li>根据目的主机返回的回送报文的<code>时间</code>和<code>成功响应的次数</code>估算出数据包<code>往返时间及丢包率</code>。</li>
</ol>
</blockquote>
<h5 id="25-WebSocket-和-socket-区别"><a href="#25-WebSocket-和-socket-区别" class="headerlink" title=".25. WebSocket 和 socket 区别"></a>.25. WebSocket 和 socket 区别</h5><ul>
<li>Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。 <strong>IP 地址 + 端口 + 协议</strong></li>
<li>Socket 一个是<strong>网编编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</li>
<li>WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决 <strong>http 不支持持久化连接</strong>的问题。</li>
</ul>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/v2-72ef367f52a4512d44e7811c52d5ad90_720w.jpg" alt=""></p>
<h5 id="26-ARP-协议工作流程"><a href="#26-ARP-协议工作流程" class="headerlink" title=".26. ARP 协议工作流程"></a>.26. ARP 协议工作流程</h5><ul>
<li>每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系.</li>
<li>源主机需要将一个<code>数据包要发送</code>到目的主机时，会首先检查自己的 <code>ARP 列表，是否存在该 IP 地址对应的 MAC 地址</code>；如果有, 就直接将数据包发送到这个 MAC 地址；如果没有，就向<code>本地网段</code>发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求的数据包里，包括<code>源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址</code>。</li>
<li>网络中<code>所有的主机收到这个 ARP 请求</code>后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。</li>
<li><code>源主机收到这个 ARP 响应数据包</code>后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</li>
</ul>
<blockquote>
<ul>
<li>Mac 不可修改</li>
<li>子网概念, 网络地址+主机号, 节省存储空间</li>
</ul>
</blockquote>
<h5 id="27-TCP-流量控制"><a href="#27-TCP-流量控制" class="headerlink" title=".27. TCP 流量控制"></a>.27. TCP 流量控制</h5><blockquote>
<p>TCP 三次握手，发送端和接收端进入到 ESTABLISHED 状态，它们即可以愉快地传输数据啦。但是发送端不能疯狂地向接收端发送数据，因为<code>接收端接收不过来的话</code>，接收方<code>只能把处理不过来的数据存在缓存区里</code>。如果<code>缓存区都满了</code>，发送方还在疯狂发送数据的话，接收方只能把收到的数据包<code>丢掉</code>，这就浪费了网络资源啦。</p>
<ul>
<li><strong>流量控制</strong>: 让发送端根据接收端的实际接收能力控制发送的数据量, 通过win来控制大小</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/image-20220304124334918.png" alt=""></p>
<p><img src="https://gitee.com/github-25970295/blogimgv2022/raw/master/MBXY-CR-8f6389c120734508b1e3367a8a8c4d9f.png" alt=""></p>
<ul>
<li>首先双方三次握手，<code>初始化各自的窗口大小</code>，均为 400 个字节。</li>
<li>假如当前发送方给接收方发送了 200 个字节，那么，发送方的 <code>SND.NXT</code> 会<code>右移 200 个字节</code>，也就是说当前的可用窗口减少了 200 个字节。</li>
<li>接受方收到后，放到<code>缓冲队列</code>里面，REV.WND =400-200=200 字节，所以 win=200 字节返回给发送方。<code>接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节</code></li>
<li>发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100 字节，即 win=100 返回发送方。</li>
<li>发送方继续干活，发送 100 字节过来，这时候，接受窗口 win 变为 0。</li>
<li>发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送。</li>
</ul>
<h5 id="28-VPN-和NAT"><a href="#28-VPN-和NAT" class="headerlink" title=".28. VPN 和NAT"></a>.28. VPN 和NAT</h5><ul>
<li>VPN（Virtual Private Network，虚拟专用网）</li>
<li>NAT（Network Address Translation，网络地址转换）</li>
</ul>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><ul>
<li><a href="https://www.eet-china.com/mp/a68780.html" target="_blank" rel="noopener">https://www.eet-china.com/mp/a68780.html</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://liudongdong1.github.io" rel="external nofollow noreferrer">liudongdong1</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://liudongdong1.github.io/2022/03/21/bian-cheng-yu-yan/mian-jing/mian-jing-ji-suan-ji-wang-luo/">https://liudongdong1.github.io/2022/03/21/bian-cheng-yu-yan/mian-jing/mian-jing-ji-suan-ji-wang-luo/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="https://liudongdong1.github.io" target="_blank">liudongdong1</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Network/">
                                    <span class="chip bg-color">Network</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2022/03/21/bian-cheng-yu-yan/mian-jing/mian-jing-jvm/">
                    <div class="card-image">
                        
                        <img src="https://cdn.pixabay.com/photo/2021/04/20/15/04/hare-6194141__340.jpg" class="responsive-img" alt="面经_JVM">
                        
                        <span class="card-title">面经_JVM</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            .1. 简述垃圾回收机制
在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
若 GC 一
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-03-21
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JVM/">
                        <span class="chip bg-color">JVM</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/03/20/linux/shell/shell-history/">
                    <div class="card-image">
                        
                        <img src="https://cdn.pixabay.com/photo/2022/03/02/14/25/flower-7043267__340.jpg" class="responsive-img" alt="shell_history">
                        
                        <span class="card-title">shell_history</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
Linux 命令的历史记录，会持久化存储，默认位置是当前用户家目录的 .bash_history 文件。
当 Linux 系统启动一个 Shell 时，Shell 会从 .bash_history 文件中，读取历史记录，存储在相应内存的缓
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-03-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/shell/">
                        <span class="chip bg-color">shell</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <!-- <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="463294659"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://liudongdong1.github.io" target="_blank">liudongdong</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">1413.5k</span>&nbsp;字
            
            
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/liudongdong1/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:3463264078@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>














    <a href="https://blog.csdn.net/liudongdong19/" class="tooltipped" target="_blank" data-tooltip="关注我的CSDN: https://blog.csdn.net/liudongdong19/" data-position="top" data-delay="50">
        <i class="fab fa-csdn">C</i>
    </a>





</div>
    </div>
</footer>

<div class="progress-bar"></div>
 -->

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script type="text/javascript" src="/js/CFS.Snow.min.js"></script>
    <!-- 点击爆灯效果 -->
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <!--动态线条背景-->
    <script type="text/javascript"
        color="122 103 238" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
    </script>
    <!-- 天气 -->
    <!-- weather -->
    <!-- weather -->
    <script type="text/javascript">
         WIDGET = {FID: 'knAMQaFanP'}
    </script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>
    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
    <!-- {% include '_custom/custom.swig' %} -->

</body>

</html>
