<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>RedisRelative - DAY By DAY</title><meta name="author" content="LiuDongdong">
<meta name="author-link" content="https://liudongdong1.github.io/">
<meta name="description" content="Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表" /><meta name="keywords" content='Database, redis, Java' /><meta itemprop="name" content="RedisRelative">
<meta itemprop="description" content="Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表"><meta itemprop="datePublished" content="2021-07-08T16:00:04+00:00" />
<meta itemprop="dateModified" content="2023-12-31T16:21:08+08:00" />
<meta itemprop="wordCount" content="15104"><meta itemprop="image" content="https://liudongdong1.github.io/logo.png"/>
<meta itemprop="keywords" content="Database,redis,Java," /><meta property="og:title" content="RedisRelative" />
<meta property="og:description" content="Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liudongdong1.github.io/redisrelative/" /><meta property="og:image" content="https://liudongdong1.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-08T16:00:04+00:00" />
<meta property="article:modified_time" content="2023-12-31T16:21:08+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://liudongdong1.github.io/logo.png"/>

<meta name="twitter:title" content="RedisRelative"/>
<meta name="twitter:description" content="Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表"/>
<meta name="application-name" content="DAY By DAY">
<meta name="apple-mobile-web-app-title" content="DAY By DAY"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://liudongdong1.github.io/redisrelative/" /><link rel="prev" href="https://liudongdong1.github.io/javajvm_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" /><link rel="next" href="https://liudongdong1.github.io/mmwavestudio/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "RedisRelative",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/liudongdong1.github.io\/redisrelative\/"
    },"genre": "posts","keywords": "Database, redis, Java","wordcount":  15104 ,
    "url": "https:\/\/liudongdong1.github.io\/redisrelative\/","datePublished": "2021-07-08T16:00:04+00:00","dateModified": "2023-12-31T16:21:08+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
      "@type": "Organization",
      "name": "LiuDongdong","logo": "https:\/\/liudongdong1.github.io\/images\/person.png"},"author": {
        "@type": "Person",
        "name": "liudongdong1"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="auto" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper"><script type="text/javascript"
        async
        src="https://cdnjs.cloudflare.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
<header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper" data-github-corner="right">
    <div class="header-title">
      <a href="/" title="DAY By DAY"><img
    class="lazyload logo"
    src="/svg/loading.min.svg"
    data-src="/fixit.min.svg"
    data-srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x"
    data-sizes="auto"
    alt="DAY By DAY"
    title="DAY By DAY"/><span class="header-title-text"></span></a><span id="typeit-header-subtitle-desktop" class="typeit header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 所有文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/friends/"
                title="友情链接"
                
              ><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden="true"></i> 友链</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/about/"
                
                
              ><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden="true"></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item language">
            <span role="button" aria-label="选择语言" title="选择语言">简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden="true"></i>
            </span>
            <ul class="sub-menu"><li class="menu-item">没有更多翻译</li></ul>
          </li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容 ..." id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li>
      </ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="DAY By DAY"><img
    class="lazyload logo"
    src="/svg/loading.min.svg"
    data-src="/fixit.min.svg"
    data-srcset="/fixit.min.svg, /fixit.min.svg 1.5x, /fixit.min.svg 2x"
    data-sizes="auto"
    alt="/fixit.min.svg"
    title="/fixit.min.svg"/><span class="header-title-text"></span></a><span id="typeit-header-subtitle-mobile" class="typeit header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容 ..." id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 所有文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/friends/"
                  title="友情链接"
                  
                ><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden="true"></i> 友链</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/about/"
                  
                  
                ><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden="true"></i> 关于</a></li><li
              class="menu-item text-center"
            ><a
                  class="menu-link"
                  href="/"
                  title="GitHub"
                  
                ><i class='fa-brands fa-github fa-fw' aria-hidden='true'></i> </a></li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li><li class="menu-item language">
            <span role="button" aria-label="选择语言" title="选择语言">简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden="true"></i>
            </span>
            <select class="language-select" onchange="location = this.value;"><option disabled>没有更多翻译</option></select>
          </li></ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container" data-page-style="normal"><aside class="toc" id="toc-auto"><h2 class="toc-title">目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom" id="aside-sakana">
    

<div class="sakana-widget">
  <div class="sakana-item" id="takina-widget"></div>
  <div class="sakana-item" id="chisato-widget"></div>
</div>
<script>
  function initSakanaWidget() {
    const takina = SakanaWidget.getCharacter('takina')
    SakanaWidget.registerCharacter('takina-slow', takina);
    new SakanaWidget({
      character: 'takina-slow',
      controls: false,
      autoFit: true,
      stroke: {
        color: "#b4b4b4",
        width: 2
      }
    }).mount('#takina-widget');

    const chisato = SakanaWidget.getCharacter('chisato')
    SakanaWidget.registerCharacter('chisato-slow', chisato);
    new SakanaWidget({
      character: 'chisato-slow',
      controls: false,
      autoFit: true,
      stroke: {
        color: "#b4b4b4",
        width: 2
      }
    }).mount('#chisato-widget');
  }
</script>
<script async onload="initSakanaWidget()" src="https://cdn.jsdelivr.net/npm/sakana-widget@2.3.0/lib/sakana.min.js">
</script></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX">
        <span>RedisRelative</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><i class="fa-solid fa-user-circle" aria-hidden="true"></i>
      liudongdong1</span></span>
          <span class="post-category">收录于 <a href="/categories/"><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Categories</a>&ensp;<a href="/categories/storage/"><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Storage</a></span></div>
      <div class="post-meta-line"><span title=2021-07-08&#32;16:00:04>
            <i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-07-08" >2021-07-08</time>
          </span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 15104 字&nbsp;
        <i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 31 分钟&nbsp;<span id="busuanzi_container_page_pv" class="busuanzi_visitors comment-visitors" data-flag-title="RedisRelative">
            <i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv">-</span>&nbsp;次阅读
          </span>&nbsp;</div>
    </div><div class="featured-image"><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://cdn.stocksnap.io/img-thumbs/280h/macro-flower_FKID7EXJPL.jpg"
    data-srcset="https://cdn.stocksnap.io/img-thumbs/280h/macro-flower_FKID7EXJPL.jpg, https://cdn.stocksnap.io/img-thumbs/280h/macro-flower_FKID7EXJPL.jpg 1.5x, https://cdn.stocksnap.io/img-thumbs/280h/macro-flower_FKID7EXJPL.jpg 2x"
    data-sizes="auto"
    alt="https://cdn.stocksnap.io/img-thumbs/280h/macro-flower_FKID7EXJPL.jpg"
    title="https://cdn.stocksnap.io/img-thumbs/280h/macro-flower_FKID7EXJPL.jpg"/></div><div class="details toc" id="toc-static" kept="true">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-基本概念">1. 基本概念</a>
      <ul>
        <li><a href="#1-nosql简介">.1. NoSql简介</a></li>
        <li><a href="#2-分布式数据库cap原理base">.2. 分布式数据库CAP原理+BASE</a></li>
      </ul>
    </li>
    <li><a href="#2-redishttpsredisiocommands">2. <a href="https://redis.io/commands">Redis</a></a>
      <ul>
        <li><a href="#0-应用场景">.0. 应用场景</a></li>
        <li><a href="#1-安装">.1. 安装</a></li>
        <li><a href="#2-数据结构">2. 数据结构</a></li>
        <li><a href="#3-持久化">3. 持久化</a></li>
        <li><a href="#4--消息传递">4.  消息传递</a></li>
        <li><a href="#5-事件机制">5. 事件机制</a></li>
        <li><a href="#6-事务机制">6. 事务机制</a></li>
        <li><a href="#7-主从复制">7. 主从复制</a></li>
        <li><a href="#8-哨兵机制">8. 哨兵机制</a></li>
        <li><a href="#9-分片计数">9. 分片计数</a></li>
        <li><a href="#10-一致性缓存">10. 一致性缓存</a></li>
        <li><a href="#11-运维监控">11. 运维监控</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div
      class="content"
      id="content"
      
      
    ><blockquote>
<p>Redis是一种支持key-value等多种数据结构的存储系统。可用于<code>缓存</code>，<code>事件发布或订阅</code>，<code>高速队列</code>等场景。支持<code>网络</code>，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p>
</blockquote>
<blockquote>
<p>学习转载于： <a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-data-types.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.pdai.tech/md/db/nosql-redis/db-redis-data-types.html<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ul>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> 过一遍,了解redis知识体系, 有哪些部分,能在什么场景使用</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> 深入学习中间件知识,Stream机制,然后使用在AIOT场景中</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> 学习一些数据结构,使用</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> 事件处理机制功能代码,能不能自己分离出来,使用在自己项目中,或者在redis基础上.</li>
</ul>
</blockquote>
<h2 id="1-基本概念">1. 基本概念</h2>
<h3 id="1-nosql简介">.1. NoSql简介</h3>
<blockquote>
<p>NoSql泛指非关系型数据库，这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展</p>
<ul>
<li><code>K-V键值对(Redis)  </code></li>
<li><code>文档型数据库(MongDB) </code></li>
<li><code>列存储数据库 </code></li>
<li><code>图关系数据库</code></li>
</ul>
</blockquote>
<h3 id="2-分布式数据库cap原理base">.2. 分布式数据库CAP原理+BASE</h3>
<ul>
<li>
<p><strong>CAP是什么</strong></p>
<ul>
<li>C(Consistency)  强一致性</li>
<li>A(Availability) 高可用性</li>
<li>P(Partition tolerance)分区容错性</li>
</ul>
</li>
<li>
<p><strong>分布式数据库CAP特性不能三个都满足，只能满足其中的两条，其中P即分区容错性必须要实现。</strong></p>
</li>
<li>
<p>传统的Oracle Mysql等满足CA, 传统的关系型数据库: ACID即原子性 一致性 隔离性 持久性</p>
</li>
<li>
<p><strong>BASE是什么</strong></p>
<ul>
<li>BASE是为了解决关系数据库强一致性引起的问题而引发的可用性降低而提出的解决方案。</li>
<li>BA(Basically Available)基本可用</li>
<li>S(Soft state)软状态</li>
<li>E(Eventually consistent)最终一致性</li>
</ul>
</li>
</ul>
<h2 id="2-redishttpsredisiocommands">2. <a href="https://redis.io/commands"target="_blank" rel="external nofollow noopener noreferrer">Redis<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h2>
<ul>
<li>单线程 | K-V键值对 | 默认端口6379 | 共有16个数据库，且索引从零开始</li>
<li>命令参考大全:http://redisdoc.com</li>
</ul>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://lddpicture.oss-cn-beijing.aliyuncs.com/picture/image-20210707224001891.png"
    data-srcset="https://lddpicture.oss-cn-beijing.aliyuncs.com/picture/image-20210707224001891.png, https://lddpicture.oss-cn-beijing.aliyuncs.com/picture/image-20210707224001891.png 1.5x, https://lddpicture.oss-cn-beijing.aliyuncs.com/picture/image-20210707224001891.png 2x"
    data-sizes="auto"
    alt="https://lddpicture.oss-cn-beijing.aliyuncs.com/picture/image-20210707224001891.png"
    title="https://lddpicture.oss-cn-beijing.aliyuncs.com/picture/image-20210707224001891.png"/></p>
<h3 id="0-应用场景">.0. 应用场景</h3>
<h4 id="1-热点数据的缓存">1. 热点数据的缓存</h4>
<p>作为缓存使用时，一般有两种方式保存数据：</p>
<ul>
<li>读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。</li>
<li>插入数据时，同时写入Redis。</li>
</ul>
<p>方案一：实施起来简单，但是有两个需要注意的地方：</p>
<ul>
<li>避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）</li>
<li>数据的实时性相对会差一点。</li>
</ul>
<p>方案二：数据实时性强，但是开发时不便于统一处理。</p>
<p>当然，两种方式根据实际情况来适用。如：<code>方案一</code>适用于<code>对于数据实时性要求不是特别高</code>的场景。<code>方案二</code>适用于<code>字典表、数据量不大</code>的数据存储。</p>
<h4 id="2-限时业务的运用">2. 限时业务的运用</h4>
<blockquote>
<p>redis中可以使用<code>expire命令设置一个键的生存时间</code>，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p>
</blockquote>
<h4 id="3-计数器相关问题">3. 计数器相关问题</h4>
<blockquote>
<p>redis由于<code>incrby命令可以实现原子性的递增</code>，所以可以运用于<code>高并发的秒杀活动</code>、<code>分布式序列号的生成</code>、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p>
</blockquote>
<h4 id="4-分布式锁">4. 分布式锁</h4>
<blockquote>
<p>这个主要利用redis的setnx命令进行，<code>setnx：&quot;set if not exists&quot;就是如果不存在则成功设置缓存同时返回1</code>，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，<code>定时任务可能在两台机器上都会运行</code>，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个<code>lock加一个过期时间</code>，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。在<code>分布式锁</code>的场景中，主要用在比如秒杀系统等。</p>
</blockquote>
<h4 id="5-延时操作">5. 延时操作</h4>
<blockquote>
<p>比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本<code>提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道</code>，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。当然我们也可以利用<code>rabbitmq</code>、<code>activemq</code>等<code>消息中间件</code>的延迟队列服务实现该需求。</p>
</blockquote>
<h4 id="6-排行榜相关问题">6. 排行榜相关问题</h4>
<blockquote>
<p>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助<code>redis的SortedSet进行热点数据的排序</code>。比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p>
</blockquote>
<h4 id="7-点赞好友等相互关系的存储">7. 点赞、好友等相互关系的存储</h4>
<blockquote>
<p>Redis 利用集合的一些命令，比如求<code>交集、并集、差集</code>等。在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</p>
</blockquote>
<h4 id="8-简单队列">8. 简单队列</h4>
<blockquote>
<p>由于Redis有<code>list push和list pop</code>这样的命令，所以能够很方便的执行队列操作。</p>
</blockquote>
<h3 id="1-安装">.1. 安装</h3>
<ul>
<li>D:\database\Redis\</li>
</ul>
<h5 id="1-软件安装">1. 软件安装</h5>
<ul>
<li>二进制方式安装</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#下载地址： https://github.com/tporadowski/redis/releases</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 现在.msi文件</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 启动 redis-server.exe</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看redis默认配置文件： redis-server.exe redis.windows.conf </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 客户端连接： redis-cli.exe -h 192.168.10.61 -p 6379</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 启动 redis-sli.exe</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 输入ping ； 如果返回 PONG 则说明启动成功。</span>
</span></span></code></pre></div><ul>
<li>源码编译安装</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#下载</span>
</span></span><span style="display:flex;"><span>wget http://download.redis.io/releases/redis-5.0.5.tar.gz
</span></span><span style="display:flex;"><span><span style="color:#75715e">#解压</span>
</span></span><span style="display:flex;"><span>tar -zxvf redis-5.0.5.tar.gz
</span></span><span style="display:flex;"><span><span style="color:#75715e">#make编译</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#不存在gcc时的解决方案</span>
</span></span><span style="display:flex;"><span>yum install gcc-c++      make distclean
</span></span><span style="display:flex;"><span>make
</span></span><span style="display:flex;"><span><span style="color:#75715e">#安装</span>
</span></span><span style="display:flex;"><span>make install <span style="color:#f92672">(</span>默认安装目录在/opt/redis-5.0.5/src<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#运行redis,需要修改redis.conf,使得redis可以在后台运行</span>
</span></span><span style="display:flex;"><span>cd /usr/local/bin/          redis-server /redis/redis.conf
</span></span><span style="display:flex;"><span><span style="color:#75715e">#命令行操作</span>
</span></span><span style="display:flex;"><span>cd /usr/local/bin/             redis-cli -p <span style="color:#ae81ff">6379</span>
</span></span></code></pre></div><ul>
<li>Dockr安装(推荐)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#搜索redis镜像</span>
</span></span><span style="display:flex;"><span>docker search redis
</span></span><span style="display:flex;"><span><span style="color:#75715e">#拉取redis镜像</span>
</span></span><span style="display:flex;"><span>docker pull redis
</span></span><span style="display:flex;"><span><span style="color:#75715e">#启动redis</span>
</span></span><span style="display:flex;"><span>docker run -p 6379:6379  -d redis  redis-server --appendonly yes
</span></span><span style="display:flex;"><span><span style="color:#75715e">#连接到redis</span>
</span></span><span style="display:flex;"><span>docker exec -it <span style="color:#f92672">[</span>reids容器id<span style="color:#f92672">]</span> redis-cli
</span></span></code></pre></div><ul>
<li>安装后的杂项配置</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#该命令用于测试redis的性能如何</span>
</span></span><span style="display:flex;"><span>redis-benchmark
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Redis总共有16个数据库，默认从0库开始使用</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> 0-15选择要使用的库
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看某一个库中键的数量</span>
</span></span><span style="display:flex;"><span>DBSIZE
</span></span><span style="display:flex;"><span><span style="color:#75715e">#FLUSHALL清除所有库中的键值对，FLUSHDB清除当前库中的键值对</span>
</span></span><span style="display:flex;"><span>FLUSHALL FLUSHDB
</span></span></code></pre></div><h5 id="2-配置文件">2. 配置文件</h5>
<ul>
<li>
<p>配置文件放在/usr/redis-5.0.5/中，想要修改该配置文件时先复制出一份到某个路径下，避免造成文件损坏</p>
</li>
<li>
<p>Units单位</p>
<p><strong>Redis中1k与1kb的区别，另外Redis对大小写不敏感</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 1k =&gt; 1000 bytes</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1kb =&gt; 1024 bytes</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1m =&gt; 1000000 bytes</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1mb =&gt; 1024*1024 bytes</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1g =&gt; 1000000000 bytes</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1gb =&gt; 1024*1024*1024 bytes</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span>
</span></span></code></pre></div></li>
<li>
<p>INCLUDES用于包含Redis的其他的配置文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Include one or more other config files here.  This is useful if you</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># have a standard template that goes to all Redis servers but also need</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># to customize a few per-server settings.  Include files can include</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># other files, so use this wisely.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Notice option &#34;include&#34; won&#39;t be rewritten by command &#34;CONFIG REWRITE&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># from admin or Redis Sentinel. Since Redis always uses the last processed</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># line as value of a configuration directive, you&#39;d better put includes</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># at the beginning of this file to avoid overwriting config change at runtime.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># If instead you are interested in using includes to override configuration</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># options, it is better to use include as the last line.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># include /path/to/local.conf</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># include /path/to/other.conf</span>
</span></span></code></pre></div></li>
<li>
<p>GENERAL指通用的标准配置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#是否允许Redis在后台运行，默认为no，如果开启后台运行会在/var/run/redis.pid写入一个pid文件</span>
</span></span><span style="display:flex;"><span>daemonize yes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Redis的日志级别，默认为notice</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># debug (a lot of information, useful for development/testing)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># verbose (many rarely useful info, but not a mess like the debug level)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># notice (moderately verbose, what you want in production probably)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># warning (only very important / critical messages are logged)</span>
</span></span><span style="display:flex;"><span>loglevel notice
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 指定日志文件的名称，默认为&#34;&#34;,日志文件将保存在/dev/null目录下</span>
</span></span><span style="display:flex;"><span>logfile <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#默认系统日志关闭</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># syslog-enabled no</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 默认系统日志以redis开头</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># syslog-ident redis</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 系统日志设备使用LOCAL0-LOCAL7，默认为local0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># syslog-facility local0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#总数据库个数为16个，默认使用第0个，数据库下标0-15，可以使用select 0-15进行数据库的切换</span>
</span></span><span style="display:flex;"><span>databases <span style="color:#ae81ff">16</span>
</span></span></code></pre></div></li>
<li>
<p>NETWORK</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#Redis绑定可以访问的ip地址，默认为本机</span>
</span></span><span style="display:flex;"><span>bind 127.0.0.1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#端口号，如果端口号为0，Redis不会监听TCP连</span>
</span></span><span style="display:flex;"><span>port <span style="color:#ae81ff">6379</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># TCP listen() backlog.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># In high requests-per-second environments you need an high backlog in order</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># to avoid slow clients connections issues. Note that the Linux kernel</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># in order to get the desired effect.</span>
</span></span><span style="display:flex;"><span>tcp-backlog <span style="color:#ae81ff">511</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 空闲多少秒以后关闭这个连接，如果为0则不会自动关闭(0 to disable)</span>
</span></span><span style="display:flex;"><span>timeout <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#单位为秒，如果设置为0则不会进行keepalive检测，建议设置为60，每隔多少秒进行一次检测，检测该redis连接是否可用</span>
</span></span><span style="display:flex;"><span>tcp-keepalive <span style="color:#ae81ff">300</span>
</span></span></code></pre></div></li>
<li>
<p>SECURITY</p>
<p>连接安装在Linux上的Redis默认不需要输入密码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#连接Redis以后输入下面命令可以获得默认的密码</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#设定Redis的密码，在设定密码后每次进行Redis的访问都需要输入密码</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#连接Redis进行访问，存在密码时输入密码进行验证密码的命令</span>
</span></span><span style="display:flex;"><span>config get requirepass
</span></span><span style="display:flex;"><span>config set requirepass
</span></span><span style="display:flex;"><span>auth password
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#得到启动Redis的路径(一般日志会保存在Redis启动的目录下面)</span>
</span></span><span style="display:flex;"><span>config get dirCLIENTS
</span></span></code></pre></div></li>
<li>
<p>CLIENTS</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 设置同一时间内最大连接数，默认为10000</span>
</span></span><span style="display:flex;"><span>maxclients <span style="color:#ae81ff">10000</span>
</span></span></code></pre></div></li>
<li>
<p>MEMORY MANAGEMENT</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 最大的内存用量</span>
</span></span><span style="display:flex;"><span>maxmemory &lt;bytes&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#当达到Redis的最大可用内存时，Redis中缓存的过期策略，有一下8种选择:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.(使用LRU算法移除key，只对设置了过期时间的key有用)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># allkeys-lru -&gt; Evict any key using approximated LRU.(使用LRU算法移除key)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.(使用LFU算法移除key，只对设置了过期时间的key有用)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># allkeys-lfu -&gt; Evict any key using approximated LFU.(使用LFU算法移除key)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># volatile-random -&gt; Remove a random key among the ones with an expire set.(在过期的集合中随机移除key，只对设置了过期时间的key有用)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># allkeys-random -&gt; Remove a random key, any key.(随机移除key)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># volatile-ttl -&gt; Remove the key with the nearest expire time (移除ttl最小的key即最近要过期的key)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># noeviction -&gt; Don&#39;t evict anything, just return an error on write operations.(永不过期，达到最大缓存时报错)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#默认的缓存过期策略</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># maxmemory-policy noeviction</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#LRU，LFU和最小TTL算法不是精确的算法，而是近似算法（为了节省内存），因此您可以调整它以获得速度或精度。 默认情况下，Redis将检查五个键并选择最近使用的键，您可以使用以下配置指令更改样本大小。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#默认值为5会产生足够好的结果。 10近似非常接近真实的LRU但成本更高的CPU。 3更快但不是很准确</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># maxmemory-samples 5</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="2-数据结构">2. 数据结构</h3>
<h4 id="1-基本数据类型">.1. 基本数据类型</h4>
<blockquote>
<p>首先对redis来说，<code>所有的key（键）都是字符串</code>。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。</p>
</blockquote>
<h5 id="1-string-字符串">1. String 字符串</h5>
<blockquote>
<p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p>
<ul>
<li><strong>缓存</strong>： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li>
<li><strong>计数器</strong>：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li>
<li><strong>session</strong>：常见方案spring session + redis实现session共享</li>
</ul>
</blockquote>
<h5 id="2-list-列表">2. List 列表</h5>
<blockquote>
<p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p>
<ul>
<li>lpush+lpop=Stack(栈)</li>
<li>lpush+rpop=Queue（队列）</li>
<li>lpush+ltrim=Capped Collection（有限集合）</li>
<li>lpush+brpop=Message Queue（消息队列）</li>
<li><strong>微博TimeLine</strong>: 有人发布微博，用lpush加入时间轴，展示新的列表信息。</li>
<li><strong>消息队列</strong></li>
</ul>
</blockquote>
<h5 id="3-sethttpswwwrunoobcomredisredis-setshtml">3. <a href="https://www.runoob.com/redis/redis-sets.html"target="_blank" rel="external nofollow noopener noreferrer">Set<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h5>
<blockquote>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<ul>
<li><strong>标签</strong>（tag）,给用户添加标签，或者用户给消息添加标签，这样<code>有同一标签或者类似标签</code>的可以给<code>推荐</code>关注的事或者关注的人。</li>
<li><strong>点赞，或点踩，收藏等</strong>，可以放到set中实现</li>
</ul>
</blockquote>
<h5 id="4-hash-散列">4. Hash 散列</h5>
<blockquote>
<p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<ul>
<li><strong>缓存</strong>： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等</li>
</ul>
</blockquote>
<h5 id="5-zset-有序集合httpswwwrunoobcomredisredis-sorted-setshtml">5. <a href="https://www.runoob.com/redis/redis-sorted-sets.html"target="_blank" rel="external nofollow noopener noreferrer">Zset 有序集合<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h5>
<blockquote>
<p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是<code>通过分数来为集合中的成员进行从小到大的排序</code>。</p>
<ul>
<li><strong>排行榜</strong>：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li>
</ul>
</blockquote>
<h4 id="2-特殊数据类型">.2. 特殊数据类型</h4>
<h5 id="1-hyperloglogs基数统计">1. HyperLogLogs（基数统计）</h5>
<blockquote>
<p>举个例子，A = {1, 2, 3, 4, 5}， B = {3, 5, 6, 7, 9}；那么基数（不重复的元素）= 1, 2, 4, 6, 7, 9； （允许容错，即可以接受一定误差）</p>
<ul>
<li>非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等</li>
</ul>
</blockquote>
<h5 id="2-bitmap-位存储">2. Bitmap （位存储）</h5>
<blockquote>
<p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p>
<ul>
<li>统计用户信息，活跃，不活跃！ 登录，未登录！ 打卡，不打卡！ <strong>两个状态的，都可以使用 Bitmaps</strong>！</li>
</ul>
</blockquote>
<h5 id="3-geospatial-地理位置httpwwwjsonscnlngcode">3. geospatial (<a href="http://www.jsons.cn/lngcode"target="_blank" rel="external nofollow noopener noreferrer">地理位置<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>)</h5>
<blockquote>
<p>推算地理位置的信息: 两地之间的距离, 方圆几里的人</p>
<ul>
<li>有效的经度从-180度到180度。</li>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#添加地理位置</span>
</span></span><span style="display:flex;"><span>geoadd china:city 118.76 32.04 manjing 112.55 37.86 taiyuan 123.43 41.80 shenyang
</span></span><span style="display:flex;"><span><span style="color:#75715e">#获取指定的成员的经度和纬度</span>
</span></span><span style="display:flex;"><span>geopos china:city taiyuan manjing
</span></span><span style="display:flex;"><span><span style="color:#75715e">#获取俩地方距离</span>
</span></span><span style="display:flex;"><span>geodist china:city taiyuan shenyang m
</span></span><span style="display:flex;"><span><span style="color:#75715e">#附近的人 ==&gt; 获得所有附近的人的地址, 定位, 通过半径来查询</span>
</span></span><span style="display:flex;"><span>georadius china:city <span style="color:#ae81ff">110</span> <span style="color:#ae81ff">30</span> <span style="color:#ae81ff">1000</span> km			<span style="color:#75715e">#以 100,30 这个坐标为中心, 寻找半径为1000km的城市</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 显示与指定成员一定半径范围内的其他成员</span>
</span></span><span style="display:flex;"><span> georadiusbymember china:city taiyuan <span style="color:#ae81ff">1000</span> km withcoord withdist count <span style="color:#ae81ff">2</span>
</span></span></code></pre></div><h4 id="3-stream-数据类型">.3. Stream 数据类型</h4>
<blockquote>
<p>Redis Stream也是一种<code>超轻量MQ</code>并没有完全实现消息队列所有设计要点</p>
<ul>
<li></li>
</ul>
<p><strong>PUB/SUB，订阅/发布模式</strong></p>
<ul>
<li>但是<code>发布订阅模式是无法持久化的</code>，如果出现网络断开、Redis 宕机等，消息就会被丢弃；</li>
</ul>
<p>基于<strong>List LPUSH+BRPOP</strong> 或者 <strong>基于Sorted-Set</strong>的实现</p>
<ul>
<li>支持了持久化，但是<code>不支持多播，分组消费等</code></li>
</ul>
</blockquote>
<h5 id="1-结构">1. 结构</h5>
<p>![](<a href="https://lddpicture.oss-cn-beijing.aliyuncs.com/picture/image-20210708075818540.png"target="_blank" rel="external nofollow noopener noreferrer">https://lddpicture.oss-cn-beijing.aliyuncs.com/picture/image-20210708075818540.png<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ul>
<li>
<p><code>Consumer Group</code> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer), 这些消费者之间是竞争关系。</p>
</li>
<li>
<p><code>last_delivered_id</code> ：游标，每个消费组会有个游标 last_delivered_id，<code>任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</code></p>
</li>
<li>
<p><code>pending_ids</code> ：<code>消费者(Consumer)的状态变量</code>，作用是<code>维护消费者的未确认的 id</code>。 pending_ids 记录了<code>当前已经被客户端读取的消息</code>，但是还没有 <code>ack</code> (Acknowledge character：确认字符）。如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack，它就开始减少。这个pending_ids变量在Redis官方被称之为PEL，也就是Pending Entries List，这是一个很核心的数据结构，它用来确保客户端<code>至少消费了消息一次</code>，而不会在网络传输的中途丢失了没处理。</p>
</li>
<li>
<p><code>消息ID</code>: 消息ID的形式是timestampInMillis-sequence，例如1527846880572-5，它表示当前的消息在毫米时间戳1527846880572时产生，并且是该毫秒内产生的第5条消息。消息ID可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是整数-整数，而且必须是后面加入的消息的ID要大于前面的消息ID。</p>
</li>
<li>
<p><code>消息内容</code>: 消息内容就是键值对，形如hash结构的键值对，这没什么特别之处。</p>
</li>
</ul>
<h5 id="2-增删查改">2. 增删查改</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#XADD - 添加消息到末尾</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># *号表示服务器自动生成ID，后面顺序跟着一堆key/value</span>
</span></span><span style="display:flex;"><span>xadd codehole * name laoqian age <span style="color:#ae81ff">30</span>  <span style="color:#75715e">#  名字叫laoqian，年龄30岁</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#XTRIM - 对流进行修剪，限制长度</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#XDEL - 删除消息</span>
</span></span><span style="display:flex;"><span>del codehole  <span style="color:#75715e"># 删除整个Stream</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#XLEN - 获取流包含的元素数量，即消息长度</span>
</span></span><span style="display:flex;"><span>xlen codehole
</span></span><span style="display:flex;"><span><span style="color:#75715e">#XRANGE - 获取消息列表，会自动过滤已经删除的消息</span>
</span></span><span style="display:flex;"><span>xrange codehole - +  <span style="color:#75715e"># -表示最小值, +表示最大值</span>
</span></span><span style="display:flex;"><span>xrange codehole 1527849629172-0 +  <span style="color:#75715e"># 指定最小消息ID的列表</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#XREVRANGE - 反向获取消息列表，ID 从大到小</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#XREAD - 以阻塞或非阻塞方式获取消息列表</span>
</span></span></code></pre></div><h5 id="3-独立消费">3. 独立消费</h5>
<blockquote>
<p>当Stream没有新消息时，甚至可以<code>阻塞等待</code>。Redis设计了一个单独的消费指令xread，可以将Stream当成普通的消息队列(list)来使用。使用xread时，我们可以完全忽略消费组(Consumer Group)的存在，就好比Stream就是一个普通的列表(list)。</p>
<ul>
<li>客户端如果想要使用xread进行顺序消费，一定要记住当前消费到哪里了，也就是返回的消息ID。下次继续调用xread时，将上次返回的最后一个消息ID作为参数传递进去，就可以继续消费后续的消息。</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#block 0表示永远阻塞，直到消息到来，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil</span>
</span></span><span style="display:flex;"><span>xread block <span style="color:#ae81ff">1000</span> count <span style="color:#ae81ff">1</span> streams codehole $
</span></span></code></pre></div><h5 id="4-消费组消费">4. 消费组消费</h5>
<h4 id="4--对象机制详解">.4.  对象机制详解</h4>
<blockquote>
<ul>
<li>Redis的每种对象其实都由<strong>对象结构(redisObject)</strong> 与 <strong>对应编码的数据结构</strong>组合而成，而每种对象类型对应若干编码方式，不同的编码方式所对应的底层数据结构是不同的。</li>
<li><strong>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</strong>.</li>
<li><strong>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理</strong>.</li>
<li>redisObject 对象:  基于redisObject对象类型检查; 显示多态函数; 分配,共享和销毁机制;</li>
</ul>
</blockquote>
<h5 id="1-redisobject数据结构">1. redisObject数据结构</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Redis 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> redisObject {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> type:<span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 编码方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> encoding:<span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> lru:LRU_BITS; <span style="color:#75715e">// LRU_BITS: 24
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 引用计数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> refcount;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 指向底层数据结构实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} robj;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 对象类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_STRING 0 </span><span style="color:#75715e">// 字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_LIST 1 </span><span style="color:#75715e">// 列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_SET 2 </span><span style="color:#75715e">// 集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ZSET 3 </span><span style="color:#75715e">// 有序集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_HASH 4 </span><span style="color:#75715e">// 哈希表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 对象编码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_RAW 0     </span><span style="color:#75715e">/* Raw representation */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_INT 1     </span><span style="color:#75715e">/* Encoded as integer */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_HT 2      </span><span style="color:#75715e">/* Encoded as hash table */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_ZIPMAP 3  </span><span style="color:#75715e">/* 注意：版本2.6后不再使用. */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_LINKEDLIST 4 </span><span style="color:#75715e">/* 注意：不再使用了，旧版本2.x中String的底层之一. */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_ZIPLIST 5 </span><span style="color:#75715e">/* Encoded as ziplist */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_INTSET 6  </span><span style="color:#75715e">/* Encoded as intset */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_SKIPLIST 7  </span><span style="color:#75715e">/* Encoded as skiplist */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_EMBSTR 8  </span><span style="color:#75715e">/* Embedded sds string encoding */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_QUICKLIST 9 </span><span style="color:#75715e">/* Encoded as linked list of ziplists */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_STREAM 10 </span><span style="color:#75715e">/* Encoded as a radix tree of listpacks */</span><span style="color:#75715e">
</span></span></span></code></pre></div><h5 id="2-处理过程">2. 处理过程</h5>
<ul>
<li>根据给定的key，在数据库字典中<code>查找和他相对应的redisObject</code>，如果没找到，就返回NULL；</li>
<li>检查redisObject的<code>type属性</code>和<code>执行命令所需的类型是否相符</code>，如果不相符，返回类型错误；</li>
<li>根据redisObject的<code>encoding属性所指定的编码</code>，选择合适的操作函数来处理<code>底层的数据结构</code>；</li>
<li>返回数据结构的<code>操作结果作为命令的返回值</code>。</li>
</ul>
<h5 id="3-对象共享">3. 对象共享</h5>
<blockquote>
<p>redis一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。</p>
<ul>
<li>
<p>共享对象只能<code>被字典和双向链表这类能带有指针的数据结构使用</code>。像整数集合和压缩列表这些只能保存字符串、整数等自勉之的内存数据结构</p>
</li>
<li>
<p><strong>为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象</strong>？</p>
</li>
</ul>
<p>列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。</p>
<p>如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)</p>
<p>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)</p>
<p>如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)</p>
</blockquote>
<p><strong>redis<code>预分配的值对象</code>如下</strong>：</p>
<ul>
<li>各种<code>命令的返回值</code>，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li>
<li>包括0 在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）</li>
</ul>
<h5 id="4-引用计数">4. 引用计数</h5>
<blockquote>
<p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p>
<ul>
<li>当新创建一个对象时，它的refcount属性被设置为1；</li>
<li>当对一个对象进行共享时，redis将这个对象的refcount加一；</li>
<li>当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一；</li>
<li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放</li>
</ul>
</blockquote>
<h4 id="5-底层数据结构httpswwwpdaitechmddbnosql-redisdb-redis-x-redis-dshtml">.5. <a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html"target="_blank" rel="external nofollow noopener noreferrer">底层数据结构<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h4>
<h5 id="1-简单动态字符串---sds">1. 简单动态字符串 - sds</h5>
<blockquote>
<p>用于存储二进制数据的一种结构, 具有动态扩容的特点. 其实现位于src/sds.h与src/sds.c中。</p>
</blockquote>
<h5 id="2-压缩列表---ziplist">2. 压缩列表 - ZipList</h5>
<h5 id="3-快表---quicklist">3. 快表 - QuickList</h5>
<blockquote>
<p>以ziplist为结点的双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist.</p>
</blockquote>
<ul>
<li><code>quicklistNode</code>, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例</li>
<li><code>quicklistLZF</code>, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li>
<li><code>quicklistBookmark</code>, 在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li>
<li><code>quicklist</code>. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li>
<li><code>quicklistIter</code>是一个迭代器</li>
<li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下</li>
</ul>
<h5 id="4-字典哈希表---dict">4. 字典/哈希表 - Dict</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictht{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//哈希表数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dictEntry <span style="color:#f92672">**</span>table;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//哈希表大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//哈希表大小掩码，用于计算索引值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//总是等于 size-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> sizemask;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//该哈希表已有节点的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> used;
</span></span><span style="display:flex;"><span>}dictht
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictEntry{
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">//键
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key;
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">//值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">union</span>{
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val;
</span></span><span style="display:flex;"><span>          uint64_tu64;
</span></span><span style="display:flex;"><span>          int64_ts64;
</span></span><span style="display:flex;"><span>     }v;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">//指向下一个哈希表节点，形成链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">struct</span> dictEntry <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}dictEntry
</span></span></code></pre></div><h5 id="5-整数集---intset">5. 整数集 - IntSet</h5>
<blockquote>
<p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> intset {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> encoding;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> length;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int8_t</span> contents[];
</span></span><span style="display:flex;"><span>} intset;
</span></span></code></pre></div><ul>
<li><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</li>
<li><code>length</code> 代表其中存储的整数的个数</li>
<li><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。（虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 encoding 属性的值）</li>
</ul>
<h5 id="6-跳表---zskiplist">6. 跳表 - ZSkipList</h5>
<blockquote>
<p>跳跃表结构在 Redis 中的运用场景只有一个，那就是作为<code>有序列表 (Zset) 的使用</code>。跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p>
</blockquote>
<h3 id="3-持久化">3. 持久化</h3>
<blockquote>
<p>Redis是个基于内存的数据库。那服务一旦宕机，内存中的数据将全部丢失。通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复，1、会对数据库带来巨大的压力，2、数据库的性能不如Redis。Redis服务提供四种持久化存储方案：<code>RDB</code>、<code>AOF</code>、<code>虚拟内存（VM）</code>和　<code>DISKSTORE</code>。</p>
</blockquote>
<h5 id="1-rdb-持久化">1. RDB 持久化</h5>
<blockquote>
<p>RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。</p>
<ul>
<li>RDB方式<code>实时性不够</code>，无法做到秒级的持久化；</li>
<li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，<code>频繁执行成本较高</code>；</li>
<li>R<code>DB文件是二进制的，没有可读性</code>，AOF文件在了解其结构的情况下可以手动修改或者补全；</li>
<li><code>版本兼容RDB文件问题</code>；</li>
</ul>
</blockquote>
<ul>
<li><strong>手动触发</strong>
<ul>
<li><strong>save命令</strong>：<code>阻塞</code>当前Redis服务器，<code>直到RDB过程完成为止</code>，对于内存 比较大的实例会造成长时间<strong>阻塞</strong>，线上环境不建议使用</li>
<li><strong>bgsave命令</strong>：Redis进程执行<code>fork操作创建子进程</code>，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短
<ol>
<li>redis客户端执行bgsave命令或者自动触发bgsave命令;</li>
<li><code>主进程判断当前是否已经存在正在执行的子进程</code>，如果存在，那么主进程直接返回；</li>
<li>如果不存在正在执行的子进程，那么就<code>fork一个新的子进程进行持久化数据</code>，fork过程是阻塞的，<code>fork操作完成后主进程即可执行其他操作</code>；</li>
<li>子进程<code>先将数据写入到临时的rdb文件中</code>，<code>待快照数据写入完成后再原子替换旧的rdb文件</code>；</li>
<li><code>同时发送信号给主进程，通知主进程rdb持久化完成</code>，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）。</li>
</ol>
</li>
</ul>
</li>
<li><strong>自动触发</strong>
<ul>
<li>redis.conf中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</li>
<li><code>主从复制时</code>，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</li>
<li>执行<code>debug reload命令重新加载redis时也会触发bgsave操作</code>；</li>
<li>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p>
</blockquote>
<h5 id="2-aof-持久化">2. AOF 持久化</h5>
<blockquote>
<p>Redis是“写后”日志，R<code>edis先执行命令，把数据写入内存，然后才记录日志</code>。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。</p>
<ul>
<li>AOF日志<code>记录Redis的每个写命令</code>，步骤分为：<code>命令追加（append）、文件写入（write）和文件同步（sync）</code>。</li>
</ul>
</blockquote>
<h3 id="4--消息传递">4.  消息传递</h3>
<blockquote>
<p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
</blockquote>
<h5 id="1-基于频道的发布订阅">1. 基于频道的发布/订阅</h5>
<blockquote>
<p>当客户端调用 SUBSCRIBE 命令时， 程序就将客户端和要订阅的频道在 pubsub_channels 字典中关联起来。</p>
<p>举个例子，如果客户端 client10086 执行命令 <code>SUBSCRIBE channel1 channel2 channel3</code></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#subscribe。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#message。表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非&#34;发布/订阅&#34;模式的命令了。</span>
</span></span><span style="display:flex;"><span>publish channel:1 hi
</span></span><span style="display:flex;"><span>subscribe channel:1
</span></span></code></pre></div><h5 id="2-基于模式的发布订阅">2. 基于模式的发布/订阅</h5>
<blockquote>
<p>通配符中?表示1个占位符，*表示任意个占位符(包括0)，?*表示1个以上占位符。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//数据结构 redisServer.pubsub_patterns 属性是一个链表，链表中保存着所有和模式相关的信息：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> redisServer {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    list <span style="color:#f92672">*</span>pubsub_patterns;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">//链表中的每个节点都包含一个 redis.h/pubsubPattern 结构：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> pubsubPattern {
</span></span><span style="display:flex;"><span>    redisClient <span style="color:#f92672">*</span>client;
</span></span><span style="display:flex;"><span>    robj <span style="color:#f92672">*</span>pattern;
</span></span><span style="display:flex;"><span>} pubsubPattern;
</span></span></code></pre></div><h3 id="5-事件机制">5. 事件机制</h3>
<blockquote>
<p>Redis中的事件驱动库只关注网络IO，以及定时器。</p>
<p>该事件库处理下面两类事件：</p>
<ul>
<li><strong>文件事件</strong>(file  event)：用于处理 Redis 服务器和客户端之间的网络IO。</li>
<li><strong>时间事件</strong>(time  eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li>
</ul>
<p>事件驱动库的代码主要是在<code>src/ae.c</code>中实现的,<code>aeEventLoop</code>是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p>
</blockquote>
<h5 id="1-文件事件">1. 文件事件</h5>
<blockquote>
<p>Redis基于<strong>Reactor模式</strong>开发了自己的网络事件处理器，也就是文件事件处理器。文件事件处理器使用<strong>IO多路复用技术</strong>（ <a href="">Java IO多路复用详解</a> ），同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p>
<ul>
<li>文件事件处理器有四个组成部分，它们分别是<code>套接字</code>、<code>I/O多路复用程序</code>、<code>文件事件分派器</code>以及<code>事件处理器</code>。</li>
</ul>
</blockquote>
<ol>
<li>客户端向服务端发起<strong>建立 socket 连接的请求</strong>，那么监听套接字将产生 AE_READABLE 事件，触发连接应答处理器执行。处理器会对客户端的连接请求</li>
<li>进行<strong>应答</strong>，然后创建客户端套接字，以及客户端状态，并将客户端套接字的 AE_READABLE 事件与命令请求处理器关联。</li>
<li>客户端建立连接后，向服务器<strong>发送命令</strong>，那么客户端套接字将产生 AE_READABLE 事件，触发命令请求处理器执行，处理器读取客户端命令，然后传递给相关程序去执行。</li>
<li><strong>执行命令获得相应的命令回复</strong>，为了将命令回复传递给客户端，服务器将客户端套接字的 AE_WRITEABLE 事件与命令回复处理器关联。当客户端试图读取命令回复时，客户端套接字产生 AE_WRITEABLE 事件，触发命令回复处理器将命令回复全部写入到套接字中。</li>
</ol>
<blockquote>
<p>图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。</p>
</blockquote>
<h5 id="2-事件事件">2. 事件事件</h5>
<blockquote>
<ul>
<li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li>
<li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>服务器所有的时间事件都放在一个<code>无序链表中</code>，每当时间事件执行器运行时，它就遍历整个链表，<code>查找所有已到达的时间事件</code>，并调用相应的事件处理器。正常模式下的<code>Redis服务器只使用serverCron一个时间事件</code>，而在benchmark模式下，服务器也只使用两个时间事件，所以不影响事件执行的性能</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> aeTimeEvent {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 全局唯一ID */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> id; <span style="color:#75715e">/* time event identifier. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 秒精确的UNIX时间戳，记录时间事件到达的时间*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> when_sec; <span style="color:#75715e">/* seconds */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 毫秒精确的UNIX时间戳，记录时间事件到达的时间*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> when_ms; <span style="color:#75715e">/* milliseconds */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 时间处理器 */</span>
</span></span><span style="display:flex;"><span>    aeTimeProc <span style="color:#f92672">*</span>timeProc;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 事件结束回调函数，析构一些资源*/</span>
</span></span><span style="display:flex;"><span>    aeEventFinalizerProc <span style="color:#f92672">*</span>finalizerProc;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 私有数据 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>clientData;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 前驱节点 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> aeTimeEvent <span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 后继节点 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> aeTimeEvent <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} aeTimeEvent;
</span></span></code></pre></div><h5 id="3-aeeventoop-具体实现httpswwwpdaitechmddbnosql-redisdb-redis-x-eventhtml">3. <a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-x-event.html"target="_blank" rel="external nofollow noopener noreferrer">aeEventoop 具体实现<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></h5>
<ol>
<li>首先<code>创建aeEventLoop对象</code>。</li>
<li>初始化<code>未就绪文件事件表</code>、<code>就绪文件事件表</code>。events指针指向未就绪文件事件表、fired指针指向就绪文件事件表。表的内容在后面添加具体事件时进行初变更。</li>
<li>初始化<code>时间事件列表</code>，设置<code>timeEventHead和timeEventNextId属性</code>。</li>
<li><code>调用aeApiCreate 函数创建epoll实例，并初始化 apidata</code>。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>aeEventLoop <span style="color:#f92672">*</span><span style="color:#a6e22e">aeCreateEventLoop</span>(<span style="color:#66d9ef">int</span> setsize) {
</span></span><span style="display:flex;"><span>    aeEventLoop <span style="color:#f92672">*</span>eventLoop;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 创建事件状态结构 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((eventLoop <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>eventLoop))) <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 创建未就绪事件表、就绪事件表 */</span>
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>events <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(aeFileEvent)<span style="color:#f92672">*</span>setsize);
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>fired <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(aeFiredEvent)<span style="color:#f92672">*</span>setsize);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (eventLoop<span style="color:#f92672">-&gt;</span>events <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> eventLoop<span style="color:#f92672">-&gt;</span>fired <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 设置数组大小 */</span>
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>setsize <span style="color:#f92672">=</span> setsize;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 初始化执行最近一次执行时间 */</span>
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>lastTime <span style="color:#f92672">=</span> <span style="color:#a6e22e">time</span>(NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 初始化时间事件结构 */</span>
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>timeEventHead <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>timeEventNextId <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>stop <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>maxfd <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>beforesleep <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>aftersleep <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 将多路复用io与事件管理器关联起来 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">aeApiCreate</span>(eventLoop) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 初始化监听事件 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> setsize; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        eventLoop<span style="color:#f92672">-&gt;</span>events[i].mask <span style="color:#f92672">=</span> AE_NONE;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> eventLoop;
</span></span><span style="display:flex;"><span>err:
</span></span><span style="display:flex;"><span>   .....
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">aeApiCreate</span>(aeEventLoop <span style="color:#f92672">*</span>eventLoop) {
</span></span><span style="display:flex;"><span>    aeApiState <span style="color:#f92672">*</span>state <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(aeApiState));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>state) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 初始化epoll就绪事件表 */</span>
</span></span><span style="display:flex;"><span>    state<span style="color:#f92672">-&gt;</span>events <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> epoll_event)<span style="color:#f92672">*</span>eventLoop<span style="color:#f92672">-&gt;</span>setsize);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>state<span style="color:#f92672">-&gt;</span>events) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">zfree</span>(state);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 创建 epoll 实例 */</span>
</span></span><span style="display:flex;"><span>    state<span style="color:#f92672">-&gt;</span>epfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">epoll_create</span>(<span style="color:#ae81ff">1024</span>); <span style="color:#75715e">/* 1024 is just a hint for the kernel */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (state<span style="color:#f92672">-&gt;</span>epfd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">zfree</span>(state<span style="color:#f92672">-&gt;</span>events);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">zfree</span>(state);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 事件管理器与epoll关联 */</span>
</span></span><span style="display:flex;"><span>    eventLoop<span style="color:#f92672">-&gt;</span>apidata <span style="color:#f92672">=</span> state;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> aeApiState {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* epoll_event 实例描述符*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> epfd;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 存储epoll就绪事件表 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> epoll_event <span style="color:#f92672">*</span>events;
</span></span><span style="display:flex;"><span>} aeApiState;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> aeFileEvent {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 监听事件类型掩码,值可以是 AE_READABLE 或 AE_WRITABLE */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mask;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 读事件处理器 */</span>
</span></span><span style="display:flex;"><span>    aeFileProc <span style="color:#f92672">*</span>rfileProc;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 写事件处理器 */</span>
</span></span><span style="display:flex;"><span>    aeFileProc <span style="color:#f92672">*</span>wfileProc;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 多路复用库的私有数据 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>clientData;
</span></span><span style="display:flex;"><span>} aeFileEvent;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 使用typedef定义的处理器函数的函数类型 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">aeFileProc</span>(<span style="color:#66d9ef">struct</span> aeEventLoop <span style="color:#f92672">*</span>eventLoop, 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>clientData, <span style="color:#66d9ef">int</span> mask);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">aeCreateFileEvent</span>(server.el,fd,AE_READABLE<span style="color:#f92672">|</span>AE_WRITABLE,syncWithMaster,NULL);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//以fd为索引，在events未就绪事件表中找到对应事件。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//调用aeApiAddEvent函数，该事件注册到具体的底层 I/O 多路复用中，本例为epoll。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//填充事件的回调、参数、事件类型等参数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/* 符合aeFileProc的函数定义 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">syncWithMaster</span>(aeEventLoop <span style="color:#f92672">*</span>el, <span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">int</span> mask) {....}
</span></span></code></pre></div><h3 id="6-事务机制">6. 事务机制</h3>
<blockquote>
<p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<ul>
<li>MULTI ：<code>开启事务</code>，redis会<code>将后续的命令逐个放入队列中</code>，然后<code>使用EXEC命令来原子化执行这个命令系列。</code></li>
<li>EXEC：<code>执行</code>事务中的所有操作命令。</li>
<li>DISCARD：取消事务，<code>放弃执行事务块中的所有命令</code>。</li>
<li>WATCH：<code>监视一个或多个key</code>,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li>
<li>UNWATCH：<code>取消WATCH对所有key的监视</code>。</li>
</ul>
</blockquote>
<h5 id="1-cas-操作乐观锁">1. CAS 操作乐观锁</h5>
<blockquote>
<p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。</span>
</span></span><span style="display:flex;"><span>WATCH mykey
</span></span><span style="display:flex;"><span>val <span style="color:#f92672">=</span> GET mykey
</span></span><span style="display:flex;"><span>val <span style="color:#f92672">=</span> val + <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>MULTI
</span></span><span style="display:flex;"><span>SET mykey $val
</span></span><span style="display:flex;"><span>EXEC
</span></span></code></pre></div><h5 id="2-执行过程">2. 执行过程</h5>
<ul>
<li>Redis使用<code>WATCH命令来决定事务是继续执行还是回滚</code>，那就需要<code>在MULTI之前使用WATCH来监控某些键值对</code>，然后使<code>用MULTI命令来开启事务</code>，执行对数据结构操作的各种命令，此时这些命令入队列。</li>
<li>当<code>使用EXEC执行事务时</code>，首先会<code>比对WATCH所监控的键值对</code>，如果<code>没发生改变</code>，它会执行事务队列中的命令，<code>提交事务</code>；如果<code>发生变化</code>，将<code>不会执行事务中的任何命令，同时事务回滚</code>。当然无论是否回滚，Redis都会<code>取消执行事务前的WATCH命令</code>。</li>
</ul>
<h3 id="7-主从复制">7. 主从复制</h3>
<blockquote>
<p><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>
<p><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>
<p><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
<p><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
</blockquote>
<h5 id="1-全量复制">1. 全量复制</h5>
<blockquote>
<p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p>
</blockquote>
<h5 id="2-增量复制">2. 增量复制</h5>
<ul>
<li><code>repl_backlog_buffer</code>：它是为了从库断开之后，<code>如何找到主从差异数据而设计的环形缓冲区</code>，从而避免全量复制带来的性能开销。如果从库<code>断开时间太久</code>，<code>repl_backlog_buffer环形缓冲区被主库的写命令覆盖了</code>，那么从库连上主库后只能乖乖地进行一次<code>全量复制</code>，所以<strong>repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量复制的概率</strong>。而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。</li>
<li><code>replication buffer</code>：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：<code>Redis先把数据写到这个buffer中</code>，<code>然后再把buffer中的数据发到client socket中再通过网络发送出去</code>，这样就完成了数据交互。所以主从在增量同步时，<code>从库作为一个client，也会分配一个buffer</code>，只不过这<code>个buffer专门用来传播用户的写命令到从库</code>，保证主从数据一致，我们通常把它叫做replication buffer。</li>
</ul>
<h3 id="8-哨兵机制">8. 哨兵机制</h3>
<blockquote>
<p>解决在主从复制的时候, 如果注节点出现故障该怎么办呢？ 在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的问题.</p>
<ul>
<li><strong>监控（Monitoring）</strong>：哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li><strong>自动故障转移（Automatic failover）</strong>：当主节点不能正常工作时，<code>哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点</code>，并<code>让其他从节点改为复制新的主节点</code>。</li>
<li><strong>配置提供者（Configuration provider）</strong>：客户端在初始化时，通过<code>连接哨兵来获得当前Redis服务的主节点地址</code>。</li>
<li><strong>通知（Notification）</strong>：哨兵可以<code>将故障转移的结果发送给客户端</code>。</li>
</ul>
</blockquote>
<h5 id="1-哨兵集群的组建">.1. 哨兵集群的组建</h5>
<blockquote>
<p>在主从集群中，主库上有一个名为<code>__sentinel__:hello</code>的频道，不同哨兵就是通过它来相互发现，实现互相通信的。在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到<code>__sentinel__:hello</code>频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。然后，哨兵 2、3 可以和哨兵 1 建立网络连接。</p>
</blockquote>
<h5 id="2-哨兵监控redis库">.2. 哨兵监控Redis库</h5>
<blockquote>
<p>由哨兵向主库发送 INFO 命令来完成的。就像下图所示，哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。</p>
</blockquote>
<h5 id="3-主库下线的判定">.3. 主库下线的判定</h5>
<ul>
<li>
<p><strong>主观下线</strong>：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；</p>
</li>
<li>
<p><strong>客观下线</strong>：有哨兵集群共同决定Redis节点是否下线；</p>
</li>
<li>
<p><strong>哨兵集群的选举</strong>： Raft选举算法： <strong>选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举</strong></p>
</li>
</ul>
<h5 id="4-新主库的选出">.4. 新主库的选出</h5>
<ul>
<li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li>
<li>选择<code>salve-priority</code>从节点优先级最高（redis.conf）的</li>
<li>选择复制偏移量最大，指复制最完整的从节点</li>
</ul>
<h3 id="9-分片计数">9. 分片计数</h3>
<h3 id="10-一致性缓存">10. 一致性缓存</h3>
<h3 id="11-运维监控">11. 运维监控</h3>
</div>
<div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title=2023-12-31&#32;16:21:08>更新于 2023-12-31&nbsp;</span>
      </div><div class="post-info-license">
          <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
        </div></div>
    <div class="post-info-line">
      <div class="post-info-md"><span><a href="/redisrelative/index.md" title="阅读原始文档" class="link-to-markdown">阅读原始文档</a></span><span><a href="https://liudongdong1.github.io/edit/master/content/posts%5c%e5%ad%98%e5%82%a8%e8%ae%be%e8%ae%a1%5cDatabase%5cRedisRelative.md" title="编辑此页"target="_blank" rel="external nofollow noopener noreferrer" class="link-to-edit">编辑此页</a></span></div>
      <div class="post-info-share">
        <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://liudongdong1.github.io/redisrelative/" data-title="RedisRelative" data-hashtags="Database,redis,Java"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://liudongdong1.github.io/redisrelative/" data-hashtag="Database"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://liudongdong1.github.io/redisrelative/" data-title="RedisRelative" data-image="https://cdn.stocksnap.io/img-thumbs/280h/macro-flower_FKID7EXJPL.jpg"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/database/">Database</a>,&nbsp;<a href="/tags/redis/">redis</a>,&nbsp;<a href="/tags/java/">Java</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/javajvm_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="prev" rel="prev" title="JavaJVM_垃圾收集器"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>JavaJVM_垃圾收集器</a>
      <a href="/mmwavestudio/" class="next" rel="next" title="mmwavestudio">mmwavestudio<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.118.2">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.2.17-RC"><img class="fixit-icon" src="/fixit.min.svg" alt="FixIt logo" />&nbsp;FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2020 - 2023</span><span class="author" itemprop="copyrightHolder">
              <a href="https://liudongdong1.github.io/"target="_blank" rel="external nofollow noopener noreferrer">LiuDongdong</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class="site-time" title='网站运行中 ...'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden="true"></i>&nbsp;<span class="run-times">网站运行中 ...</span></span></div><div class="footer-line ibruce">
          <span id="busuanzi_container_site_uv" title='总访客数'><i class="fa-regular fa-user fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span><span id="busuanzi_container_site_pv" class="footer-divider" title='总访问量'><i class="fa-regular fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span>
        </div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric">0%</span>
        </div></div><a href="https://liudongdong1.github.io/" title="在 GitHub 上查看源代码"target="_blank" rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;--bg-progress: #0076ff;--bg-progress-dark: #fff;"></div><noscript>
    <div class="noscript-warning">FixIt 主题在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/algoliasearch/algoliasearch-lite.umd.min.js" defer></script><script src="/lib/lazysizes/lazysizes.min.js" async defer></script><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/typeit/index.umd.js" defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="/lib/pangu/pangu.min.js" defer></script><script src="/lib/cell-watermark/watermark.min.js" defer></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":10},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"data":{"typeit-header-subtitle-desktop":"\u003cspan style='font-family: MMT,\"沐目体\";'\u003e吾日三省吾身\u003c/span\u003e","typeit-header-subtitle-mobile":"\u003cspan style='font-family: MMT,\"沐目体\";'\u003e吾日三省吾身\u003c/span\u003e"},"enablePWA":true,"enablePangu":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"2R1K9SKLQZ","algoliaIndex":"index.zh-cn","algoliaSearchKey":"4a226aa1c5c98d6859e4d1386adb2bc7","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"siteTime":"2020-12-18T16:15:22+08:00","typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"typeit-header-subtitle-desktop":["typeit-header-subtitle-desktop"],"typeit-header-subtitle-mobile":["typeit-header-subtitle-mobile"]},"duration":-1,"speed":100},"watermark":{"appendto":".wrapper\u003emain","colspacing":30,"content":"\u003cimg class=\"fixit-icon\" src=\"/fixit.min.svg\" alt=\"FixIt logo\" /\u003e FixIt 主题","enable":true,"fontfamily":"inherit","fontsize":0.85,"height":21,"opacity":0.0125,"rotate":15,"rowspacing":60,"width":150}};</script><script src="/js/theme.min.js" defer></script><script src="/js/custom.min.js" defer></script></body>
</html>
